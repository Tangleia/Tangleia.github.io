{"meta":{"title":"归子莫的博客","subtitle":"","description":"归子莫的个人博客","author":"归子莫","url":"https://Tangleia.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-09-18T15:00:33.586Z","updated":"2020-06-18T07:40:45.000Z","comments":true,"path":"404.html","permalink":"https://tangleia.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-09-18T15:00:33.822Z","updated":"2020-06-18T07:41:34.000Z","comments":true,"path":"index.html","permalink":"https://tangleia.github.io/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-09-18T15:00:33.819Z","updated":"2020-06-18T07:29:22.000Z","comments":true,"path":"about/index.html","permalink":"https://tangleia.github.io/about/index.html","excerpt":"","text":"本站是个人博客，希望一起交流学习。 本站所使用的主题是：Volantis，与主题相关的疑问请前去主题文档页面查询或者提 issue 求助！"},{"title":"我的朋友们","date":"2020-09-18T15:00:33.821Z","updated":"2020-06-18T07:37:44.000Z","comments":true,"path":"friends/index.html","permalink":"https://tangleia.github.io/friends/index.html","excerpt":"","text":""},{"title":"","date":"2020-09-18T15:00:33.823Z","updated":"2020-06-18T08:12:32.000Z","comments":true,"path":"mylist/index.html","permalink":"https://tangleia.github.io/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"面试题（2020）微信小程序常见面试题","slug":"面试题（2020）微信小程序常见面试题","date":"2020-10-26T15:35:03.856Z","updated":"2020-10-27T03:55:25.063Z","comments":true,"path":"2020/10/26/面试题（2020）微信小程序常见面试题/","link":"","permalink":"https://tangleia.github.io/2020/10/26/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%882020%EF%BC%89%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"面试题（2020）微信小程序常见面试题","text":"面试题（2020）微信小程序常见面试题 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 1、微信的小程序的主要文件 WXML——模板文件 JSON——配置/设置文件，如标题,tabbar,页面注册 WXSS——样式文件，样式可直接用import导入 JS——脚本逻辑文件，逻辑处理，网络请求 app.json——配置文件入口，整个小程序的全局配置，网络超时时间、底部tab、页面路径，window字段是小程序所有页面的顶部背景颜色、文字颜色 app.js——可以没有内容，可以在里边监听生命周期函数、声明全局变量 app.wxss——全局配置样式文件 2、数据请求怎么封装 将所有的接口放在统一的js文件中并导出（或者将请求地址、头、方法在一个js文件里统一定义为一个常量并导出） 在app.js创建封装请求数据的方法 在子页面中调用封装的方法请求数据 3、参数传递 给HTML元素中添加data-*属性来传递需要的值，之后通过e.currentTarget.dataset或onload的param参数获取。注意不能有大写字母，不可以存放对象 跳转页面时通过navigator传递需要的参数值 设置id的方法标识，通过e.currentTarget.id获取设置的id值，然后通过设置全局变量的方法来传递数值 4、生命周期函数 onLoad——页面加载，调一次 onShow——页面显示，每次打开页面都调用 onReady——初次渲染完成，调一次 onHide——页面隐藏，当navigateTo或底部tab切换时调用 onUnload——页面卸载，当redirectTo或navigateBack时调用 5、小程序的双向绑定和vue哪里不一样 小程序直接this.data的属性是不可以同步到视图的，必须调用this.setData({}) 6、1px = 2rpx7、如何自定义组件（弹窗） 先创建一个components文件夹，用来存放所有自定义组件的，目录结构依然是js,wxml,json,wxss 基本配置： .json——进行自定义组件声明 123&#123; &quot;component&quot;: true&#125; 使用组件： 假如在index.wxml中使用这个自定义的组件，首先在index.json中进行声明 12345&#123; &quot;usingComponents&quot;: &#123; &quot;toastdemo&quot;: &quot;&#x2F;components&#x2F;toastdemo&#x2F;toastdemo&quot; &#125; &#125; 接着在index.wxml中引用 然后在index.js进行配置 使用时直接执行this.toastdemo.showToast(‘弹框组件调用成功’,2000)就可以了 8、小程序内的页面跳转 wx.navigateTo——保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面（参数必须为字符串） wx.redirectTo——关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 tabbar 页面 wx.switchTab——跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面，路径后不能带参数 wx.navigateBack——关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层 wx.reLaunch——关闭所有页面，打开到应用内的某个页面 9、小程序和Vue写法的区别 循环遍历：小程序是wx:for=”list”，vue是v-for=”inforin list” 调用data模型：小程序是this.data.unifo，vue是this.unifo 给模型赋值：小程序是this.setData({unifo:1})，vue是直接this.unifo=1 10、小程序的双向绑定和vue哪里不一样 小程序直接this.data的属性是不可以同步到视图的，必须调用this.setData({}) 11、小程序的优点和缺点小程序的优点 无需下载 打开速度快 开发成本低 为用户提供良好的安全保障。发布有一套严格的审查流程，不能通过审查的程序无法发布上线 服务请求快 小程序的缺点 依托微信，不能开发后台管理功能 大小限制不能超过2M，不能打开超过5个层级的页面 12、简述小程序原理 小程序分为两个部分webview和appService，webview用来展现UI，appService用来处理业务逻辑、数据及接口调用，它们在两个进程中运行，通过系统层JSBridge实现通信，完成UI渲染、事件处理。 13、提高小程序的应用速度的方法 减少默认data的大小 组件化方案，公用的如弹框等写个自定义的组件，然后调用 14、简述小程序原理 小程序分为两个部分webview和appService，webview用来展现UI，appService用来处理业务逻辑、数据及接口调用，它们在两个进程中运行，通过系统层JSBridge实现通信，完成UI渲染、事件处理 15、setData的回调函数微信小程序的setData实现是和react的setData实现类似的，所以它也是一个异步函数，并且有回调函数的参数，当然平时小量数据我们可能并没有感觉到它的异步，但是为了确保逻辑的正确执行，在需要用到setData后 data里的数据的步骤，请写入setData的回调函数中，如下示例： 1234this.setData(&#123; a: this.data.a++ &#125;,()&#x3D;&gt;&#123;&#125;) 16、如何实现下拉刷新 先在app.json或page.json中配置enablePullDownRefresh:true page里用onPullDownRefresh函数，在下拉刷新时执行 在下拉函数执行时发起数据请求，请求返回后，调用wx.stopPullDownRefresh停止下拉刷新的状态 17、bindtap和catchtap的区别是什么 bindtap不会阻止冒泡事件，catchtap阻止冒泡 18、微信小程序与H5的区别？①运行环境不同（小程序在微信运行，h5在浏览器运行）； ②开发成本不同（h5需要兼容不同的浏览器）； ③获取系统权限不同（系统级权限可以和小程序无缝衔接）； ④应用在生产环境的运行流畅度（h5需不断对项目优化来提高用户体验）； 19、小程序关联微信公众号如何确定用户的唯一性？使用wx.getUserInfo方法 withCredentials为true时，可获取encryptedData，里面有union_id.后端需要进行对称解密。 20、webview中的页面怎么跳回小程序中 先在管理后台配置域名白名单， 然后引入jweixin-1.3.2.js（https://res.wx.qq.com/open/js/jweixin-1.3.0.js） 12wx.miniProgram.navigateTo(&#123;url: &#39;&#x2F;pages&#x2F;login&#x2F;login&#39;+&#39;$params&#39;&#125;)wx.miniProgram.navigateTo(&#123;url: &#39;&#x2F;path&#x2F;to&#x2F;page&#39;&#125;) 21、webview的页面怎么跳转到小程序导航的页面？小程序导航的页面可以通过switchTab，但默认情况是不会重新加载数据的。若需加载新数据，则在success属性中加入以下代码即可： 123456789success: function (e) &#123; var page &#x3D; getCurrentPages().pop(); if (page &#x3D;&#x3D; undefined || page &#x3D;&#x3D; null) return; page.onLoad();&#125;&#x2F;&#x2F;webview的页面，则通过wx.miniProgram.switchTab(&#123; url: &#39;&#x2F;pages&#x2F;index&#x2F;index&#39; &#125;) 22、小程序和小程序之间的跳转 在同一主体公众号上关联2个小程序appid， 用navigator，对应设置一些属性即可 target：miniProgram——其他小程序 target：self——当前小程序 感谢 万能的网络 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"前端面试—Js面试题汇总","slug":"前端面试—Js面试题汇总","date":"2020-09-27T05:15:01.959Z","updated":"2020-09-29T08:02:38.507Z","comments":true,"path":"2020/09/27/前端面试—Js面试题汇总/","link":"","permalink":"https://tangleia.github.io/2020/09/27/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94Js%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"前端面试—Js面试题汇总","text":"前端面试—Js面试题汇总 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 1、有几种方式可以实现继承JS里常用的有如下两种继承方式：原型链继承（对象间的继承）类式继承（构造函数间的继承） 方法一：原型链原型链的基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。每一个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的指针。如果：我们让原型对象A等于另一个类型B的实例，那么原型对象A就会有一个指针指向B的原型对象，相应的B的原型对象中保存着指向其构造函数的指针。假如B的原型对象又是另一个类型的实例，那么上述的关系依旧成立，如此层层递进，就构成了实例与原型的链条。注意： 通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做会重写原型链。问题： 原型链很强大，可以利用它来实现继承，但是也有一些问题，主要的问题还是包含引用类型值的原型属性会被所有实例共享。因此我们在构造函数中定义实例属性。但是在通过原型来实现继承时，原型对象其实变成了另一个类型的实例。于是原先定义在构造函数中的实例属性变成了原型属性了。原型链的另一个问题是： 在创建子类型的实例时，不能在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 方法二：构造函数为了解决原型中包含引用类型值带来的一些问题，引入了借用构造函数的技术。这种技术的基础思想是：在子类型构造函数的内部调用超类型构造函数。 Parent.call(this)在新创建的Child实例环境下调用Parent构造函数。这样，就在新的Child对象上，此处的kid1和kid2对象上执行Parent()函数中定义的对象初始化代码。这样，每个Child实例就都会具有自己的friends属性的副本了。 借用构造函数的方式可以在子类型的构造函数中向超类型构造函数传递参数。构造函数模式的问题： 在于方法都在构造函数中定义，函数复用无从谈起，因此，借用构造函数的模式也很少单独使用。 方法三：组合继承组合继承指的是将原型链和借用构造函数的技术组合在一块，从而发挥二者之长。即：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 Person构造函数定义了两个属性：name和friends。Person的原型定义了一个方法sayName()。Child构造函数在调用Parent构造函数时，传入了name参数，紧接着又定义了自己的属性age。然后将Person的实例赋值给Child的原型，然后又在该原型上定义了方法sayAge().这样，两个不同的Child实例既分别拥有自己的属性,包括引用类型的属性，又可以使用相同的方法了。 组合继承避免了原型链和构造函数的缺陷，融合了他们的有点，成为JavaScript中最常用的继承模式。而且，instanceOf和isPropertyOf()也能够识别基于组合继承创建的对象。 方法四：原型式继承这是另一种继承，没有严格意义上的构造函数。思路是：借助原型可以基于已有的对象创建新对象，同时还不必要创建自定义类型。在object()函数内部，先创建一个临时的构造函数，然后将传入的对象作为构造函数的原型，最后返回这个临时类型的一个新实例。从本质上讲，object()对传入其中的对象执行了一次浅复制。 方法五：寄生式继承寄生式继承是与原型式继承紧密相关的一种思路，与寄生式构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。使用寄生式继承来为对象添加函数，会由于不能做到函数的复用而降低效率；这一点和构造函数继承模式类似。 方法六：寄生组合式继承所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链来继承方法。寄生组合式继承的基本思路：不必为了指定子类型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承超类型的原型，然后再将结果指定给子类型的原型。 原型实现继承的优缺点及解决方式优点： 可以继承构造函数属性，也可继承原型属性 缺点： 在创建子类实例化时，不能向超类型的构造函数中传参 子类型继承了父类型原型中的所有属性和方法，但对于引用类型属性值所有实例共享，故不能在不改变其他实例情况下改变。 解决方式： 使用组合继承。 垃圾回收机制（闭包的延伸）js拥有特殊的垃圾回收机制，当一个变量在内存中失去引用，js会通过特殊的算法将其回收，并释放内存。分为以下两个阶段： 标记阶段：垃圾回收器，从根对象开始遍历，访问到的每一个对象都会被标示为可到达对象。 清除阶段：垃圾回收器在对内存当中进行线性遍历，如果发现该对象没有被标记为可到达对象，那么就会被垃圾回收机制回收。这里面牵扯到了引用计数法，每次引用都被会‘➕1’ 如果标记清零，那么就会被回收掉。 简述深浅拷贝浅拷贝 通常需要拷贝的对象内部只有一层的这种对象。 常用的方法 Object.assign方法来实现 扩展运算符 ...obj 深拷贝 通常是嵌套二层或以上的复杂对象 常用方法 JSON.parse(JSON.stringfy(object)); 该方法忽略掉undefined、忽略Symbol、忽略function。只适合简单深拷贝 手写递归方法去实现。 通过第三方库提供的深拷贝实现。 讲一下let、var、const的区别 var 没有块级作用域，支持变量提升。 let 有块级作用域，不支持变量提升。不允许重复声明，暂存性死区。不能通过window.变量名进行访问. const 有块级作用域，不支持变量提升，不允许重复声明，暂存性死区。声明一个变量一旦声明就不能改变，改变报错。 call apply区别，原生实现bindcall、apply区别相同点：都是重定向this指针的方法。不同点：call和apply的第二个参数不相同，call是若干个参数的列表。apply是一个数组 手写一个call方法 123456789101112131415161718192021222324252627282930313233343536// 在这之前需要重新认识一下call方法的执行操作let mock = &#123; value : 1 &#125;;function mockNum()&#123; console.log('value',this.value)&#125;mockNum.call(mock) // 改变了函数中this的指向，当前this指向了mock对象转换一下实现方法就是let mock = &#123; value:1; mockNum:function()&#123; console.log('value',this.value) &#125;&#125;mock.mockNum();所以经过上面这个操作的演化而来的结果就是如下步骤：1. 将函数设为一个对象的属性2. 并将这个函数的属性调用3. 删除该函数Function.prototype.Mycall = function(context)&#123; let obj = context || window; obj.fn = this; // 这一步可以看做是this其实就指的当前函数。 let args = [...arguments].slice(1); // 返回删除第一个元素的数组； let result = obj.fn(...args); // 调用函数 delete obj.fn; return result;&#125;// 操作一下let mock = &#123; value : 1 &#125;;function mockNum()&#123; console.log('value',this.value);&#125;mockNum.Mycall(mock) // value 1 然后根据上面的方法再手写一个apply方法 1234567891011121314Function.prototype.Myapply = function (context)&#123; let obj = context || window; obj.fn = this; let result = arguments[1] ? obj.fn(arguments[1]) : obj.fn([]); delete obj.fn; return result;&#125;let mock3 = &#123; arr: [1, 2, 3, 4, 5],&#125;;function arrx2(arr) &#123; return this.arr.concat(arr).map((x) =&gt; x * 2);&#125;console.log(\"arrx2\", arrx2.myApply(mock3)); bindbind方法是直接返回一个新的函数，需要手动去调用才能执行。 创建一个新函数，当这个新函数被调用时，bind()方法的第一个参数将作为运行他的this，之后的一系列参数将会在传递的实参传入作为他的参数； 特点：1. 返回一个函数。 2. 可以传入参数； 】手写一个bind方法 1234567891011121314151617181920例如：let foo = &#123; value : 1 &#125;;function bar() &#123; console.log('bindFoo',this.value); // return this.value // 考虑到函数可能有返回值&#125;let bindFoo = bar.bind(foo);bindFoo() // 1 // 如果有返回值的情况下 bindFoo() === 1;Function.prototype.Mybind = function(obj)&#123; if(typeof this !== 'function') throw new Error('not a function'); let self = this; let args = [...arguments].clice(1); return function F()&#123; if(this instanceof F)&#123; return new self(...args,...arguments); &#125; return self.apply(obj,args.concat([...arguments])); &#125;&#125; 捕获和冒泡捕获：就是从根元素开始向目标元素递进的一个关系；从上而下冒泡：是从目标元素开始向根元素冒泡的过程；想象一下水里的泡泡从下而上。 stopPropagation 通常理解它是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。 箭头函数和普通函数的区别是什么普通函数this： this总是代表它的直接调用者。 在默认情况下，没找到直接调用者，this指的是window。 在严格模式下，没有直接调用者的函数中的this是undefined。 使用call,apply,bind绑定，this指的是绑定的对象。 箭头函数this： 在使用=&gt;定义函数的时候，this的指向是 定义时所在的对象，而不是使用时所在的对象； 不能够用作构造函数，这就是说，不能够使用new命令，否则就会抛出一个错误； 不能够使用 arguments 对象； 不能使用 yield 命令； js跨域如何解决———————-目前暂时已知的跨域方法是： jsonp跨域，原理：script标签没有跨域限制的漏洞实现的一种跨域方法，只支持get请求。安全问题会受到威胁。 cors跨域，通过后端服务器实现，Access-Control-Allow-Origin。 postMessage window的一个属性方法。 websocket nginx反向代理 iframe跨域 webpack proxy跨域首先需要明白webpack proxy跨域只能用作与开发阶段，临时解决本地请求服务器产生的跨域问题。并不适合线上环境。配置在webpack的devServer属性中。webpack中的devsever配置后，打包阶段在本地临时生成了一个node服务器，浏览器请求服务器相当于请求本地服务。 深度优先和广度优先广度优先：尝试访问尽可能靠近它的目标节点，然后逐层向下遍历，直至最远的节点层级。深度优先：从起始节点开始，一直向下找到最后一个节点，然后返回，又继续下一条路径。知道找遍所有的节点。 简单介绍一下event loopjs作为单线程语言。在执行过程中，会产生执行环境。这些执行环境中的代码被顺序的加入到执行栈中，如果遇到异步代码，会被挂起并加入到任务队列当中，等到主线程任务执行完毕，event loop就会从任务队列取出需要执行的代码放入到执行栈中执行。所以本质上来讲，js中的异步还是同步的行为。 任务队列有分为宏任务和微任务队列。 一次正确的event loop执行顺序如下： 执行所有同步代码 执行栈为空，查询是否有需要执行的微任务。 微任务（有：则执行，无：则跳出） 必要的话开始渲染UI 开始下一轮的任务队列执行宏任务中的异步代码。 如何实现图片懒加载当访问一个页面的时候，先把img元素或是其他元素的背景图片路径替换成一张大小为1*1px图片的路径（这样就只需请求一次），只有当图片出现在浏览器的可视区域内时，才设置图片真正的路径，让图片显示出来。这就是图片懒加载。通常可以借助IntersectionObserver API。 instanceof和typeofinstanceof原理instanceOf用来判断右边的prototype是否在左边的原型链上，告诉我们左边是否是右边的实例。 typeof 检测对象 除开函数是function类型之外。像常见的数组，对象或者是正则,日期等等都是object； 感谢 万能的网络 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"前端面试—Html面试题汇总","slug":"前端面试—Html面试题汇总","date":"2020-09-23T05:16:31.506Z","updated":"2020-09-23T05:16:31.506Z","comments":true,"path":"2020/09/23/前端面试—Html面试题汇总/","link":"","permalink":"https://tangleia.github.io/2020/09/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94Html%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"前端面试—Html面试题汇总","text":"前端面试—Html面试题汇总 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 1、语义化为什么要语义化?a. 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看； b. 用户体验：例如title、alt用于解释名词或解释图片信息的标签尽量填写有含义的词语、label标签的活用； c. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； d. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以有意义的方式来渲染网页； e. 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 2. 写HTML代码时，应注意什么？ 尽可能少的使用无语义的标签div和span； 在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、u等，改用css设置。 需要强调的文本，可以包含在strong或em标签中，strong默认样式是加粗（不要用b），em是斜体（不要用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 补充一点：不仅写html结构时，要用语义化标签，给元素写css类名时，也要遵循语义化原则，不要，随便起个名字就用，那样等以后，再重构时，非常难读。最忌讳的是不会英文，用汉语拼音代替。别那么LOW 。 HTML5新增了哪些语义化标签？1、header元素 header元素代表“网页“和”section”的页眉。通常包含H1~H6元素或者hgroup元素。作为整个页面或者内容块的标题，也可以包裹一节的目录部分，一个搜索框，一个nav，或者任何相关logo。整个页面没有限制header元素的个数，可以拥有多个，可以为每个内容块增加一个header元素 header使用注意： 可以是“网页”或任意“section”的头部部分； 没有个数限制。 如果hgroup或h1-h6自己就能工作的很好，那就不要用header。 2、footer元素 footer元素代表“网页”或“section”的页脚，通常含有该页面的一些基本信息，例如：文档创作者的姓名、文档的版权信息、使用条款的链接、联系信息等等。。 footer使用注意： 可以是“网页”或任意“section”的底部部分； 没有个数限制，除了包裹的内容不一样，其他跟header类似。 3、hgroup元素 hgroup元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将h1到h6元素放在其内，譬如文章的主标题和副标题的组合 hgroup使用注意： 如果只需要一个h1-h6标签就不用hgroup 如果有连续多个h1-h6标签就用hgroup 如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签 4、nav元素 nav元素代表页面的导航链接区域。用于定义页面的主要导航部分。但是我在有些时候却情不自禁的想用它，譬如：侧边栏上目录，面包屑导航，搜索样式，或者下一篇上一篇文章，但是事实上规范上说nav只能用在页面主要导航部分上。页脚区域中的链接列表，虽然指向不同网站的不同区域，譬如服务条款，版权页等，这些footer元素就能够用了。 nav使用注意： 用在整个页面主要导航部分上，不合适就不要用nav元素； 5、aside元素 aside元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名词解释等。（特殊的section） 在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。 aside使用总结： aside在article内表示主要内容的附属信息， 在article之外则可做侧边栏，没有article与之对应，最好不用。 如果是广告，其他日志链接或者其他分类导航也可以用 6、article元素 article元素最容易跟section和div容易混淆，其实article代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。（特殊的section） 除了它的内容，article会有一个标题（通常会在header里），会有一个footer页脚。 article使用注意： 自身独立的情况下：用article 是相关内容：用section 没有语义的：用div HTML5的十大新特性(1)语义标签 (2)增强型表单 (3)视频和音频 4)Canvas绘图 (5)SVG绘图 (6)地理定位 Geolocation (7)拖放API (8)Web Worker (9)Web Storage (10)WebSocket input与textarea的区别input是单行文本框，不会换行。通过size属性指定显示字符的长度，注意：当使用css限定了宽高，那么size属性就不再起作用。value属性指定初始值，Maxlength属性指定文本框可以输入的最长长度。可以通过width和height设置宽高，但是也不会增加行数。 textarea 是多行文本输入框，文本区中可容纳无限数量的文本，无value属性，其中的文本的默认字体是等宽字体（通常是 Courier） ，可以通 过 cols 和 rows 属性来规定 textarea 的尺寸，不过更好的办法是使用 CSS 的 height 和 width 属性。 用div模拟textarea在div标签里面加入contenteditable=”true” 1234567891011121314151617&lt;style&gt; .textarea&#123; min-height: 100px; border: 1px solid #a0b3d6; width: 300px; font-size: 14px; max-height: 300px; overflow-y: auto; &#125;&lt;/style&gt; &lt;body&gt; &lt;!--用div模拟textarea--&gt; &lt;div class=\"textarea\" contenteditable=\"true\"&gt; &lt;/div&gt;&lt;/body&gt; 感谢 万能的网络 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"前端面试—CSS面试题汇总","slug":"前端面试—CSS面试题汇总","date":"2020-09-23T04:57:39.032Z","updated":"2020-09-23T04:57:39.032Z","comments":true,"path":"2020/09/23/前端面试—CSS面试题汇总/","link":"","permalink":"https://tangleia.github.io/2020/09/23/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94CSS%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/","excerpt":"前端面试—CSS面试题汇总","text":"前端面试—CSS面试题汇总 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 1、flex常见面试题Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 123456789101112131415161718191 flex-direction:属性决定主轴的方向； row 水平方向，起点在左端 row-reverse 水平方向，起点右端 column 纵向方向，起点在上 column 纵向方向，起点在下2 flex-wrap:决定是否换行，默认都是排在一行 no-wrap;(默认)不换行 wrap; &#x2F;&#x2F;换行，第一行在上方 wrap-reverse;&#x2F;&#x2F;换行；第二行在上方3 flex-flow:flex-direction和flex-wrap的缩写，默认为row nowrap flex-flow:&lt;flex-direction&gt; ||&lt;flex-wrap&gt;4 justify-content:定义在item在主轴上的对齐方式 flex-start 从左到右 flex-end 从右到左 center 居中 space-between 两端对齐 space-around 每个item两侧中间相等5 justify-content:定义在item在主轴上的对齐方式 左中右三等分给父元素添加display:flex 左右布局，一侧定宽，一侧自适应撑满12345678&lt;div style=\"display:flex; height:100%; width:100%;\"&gt; &lt;div style=\"width:300px; background:red;\"&gt; sss &lt;/div&gt; &lt;div style=\"width:100%; background:green;\"&gt; ssssss &lt;/div&gt;&lt;/div&gt; 未知高宽上下左右居中12345678910111213141516171819202122//csshtml,body &#123; height: 100%&#125;.main &#123; display: flex; height: 100%; justify-content: center; align-items: center&#125;.box &#123; width: 300px; border: 1px solid red;&#125;//html &lt;div class=\"main\"&gt; &lt;div class=\"box\"&gt;未知高度上下左右居中&lt;/div&gt;&lt;/div&gt; 2、盒模型面试题什么是盒模型页面就是由一个个盒模型堆砌起来的，每个HTML元素都可以叫做盒模型，盒模型由外而内包括：边距（margin）、边框（border）、填充（padding）、内容（content）。它在页面中所占的实际宽度是margin + border + paddint + content 的宽度相加。 标准盒模型和IE的盒模型的区别 不同之处就是标准盒模型的内容大小就是content的大小，而IE的则是content + padding +border 总的大小 怎么设置标准盒模型和IE的盒模型通过设置 box-sizing:content-box(W3C)/border-box(IE)就可以达到自由切换的效果 BFC面试题BFC的基本概念BFC就是“块级格式化上下文”的意思，也有译作“块级格式化范围”。它是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。通俗的讲，就是一个特殊的块，内部有自己的布局方式，不受外边元素的影响。 BFC原理 BFC内部的盒子，会在垂直方向，一个接一个地放置。垂直方向上也会发生边距重叠。 BFC就是页面上的一个独立容器，容器里面的子元素不会影响到外面的元素，外边的也不会影响里边的。 BFC的区域不会与float box重叠。 计算BFC的高度时，浮动元素也被计算在内。 BFC如何产生1234overflow: auto&#x2F; hidden;position: absolute&#x2F; fixed;float: left&#x2F; right;display: inline-block&#x2F; table-cell&#x2F; table-caption&#x2F; flex&#x2F; inline-flex 在属性值为这些的情况下，都会让所属的box产生BFC。 CSS布局面试题有哪些布局 float布局的兼容性比较好。解决办法：给橙色块添加overflow: hidden（生成了一个BFC）。浮动元素父元素还存在高度塌陷问题，解决方法： 父元素生成一个BFC。 absolute布局的有点是简单直接，兼容性好。缺点，脱离了文档流。 flex布局的优点，布局简单、灵活，移动端友好；缺点是ie8以下不兼容。 table布局的优点是兼容性好，有时候布局相对简单。缺点是它是对TABLE标签的不正规使用，一直以来被大家所诟病。当需要内容高度不一致时并不适应。 grid布局优点，是第一个基于二维方向的布局模块。它是第一个基于网格的原生布局系统。缺点是对低版本浏览器兼容性不好。 CSS预处理器Less（基于Node写的）、Sass（基于Ruby写的） CSS预处理器功能1.嵌套 反映层级和约束2.变量和计算 减少重复代码3.Extend和Mixin 代码片段复用4.循环 适用于复杂有规律的样式5.import CSS文件模块化 CSS新特性css3的新选择器E:nth-child(n) 选择器匹配其父元素的第n个子元素，不论元素类型，n可以使数字，关键字，或公式 E:nth-of-type(n) 选择与之其匹配的父元素的第N个子元素 E:frist-child 相对于父级做参考，“所有”子元素的第一个子元素，并且“位置”要对应 E：frist-of-type 相对于父级做参考，“特定类型”（E）的第一个子元素 E：empty 选择没有子元素的每个E元素 E:target 选择当前活动的E元素 ::selection 选择被用户选取的元素部分 属性选择器 E[abc*=”def”] 选择adc属性值中包含子串”def”的所有元素 2、文本 text-shadow:2px 2px 8px #000;参数1为向右的偏移量，参数2为向左的偏移量，参数3为渐变的像素，参数4为渐变的颜色 text-overflow:规定当文本溢出包含元素时发生的事情 text-overflow:ellipsis(省略) text-wrap:规定文本换行的规则 word-break 规定非中日韩文本的换行规则 word-wrap 对长的不可分割的单词进行分割并换行到下一行 white-space: 规定如何处理元素中的空白 white-space:nowrap 规定段落中的文本不进行换行 3、边框border-raduis:50%边框的圆角 border-image 边框图片 .border-image { border-image-source:url(images/border.png); boder-image-slice:27; border-image-width:10px; border-iamge-repeat:round; (round平铺) 平铺效果不作用于四角，只适应与四边 } 4、背景rgba backgrounnd-size:cover/contain，其中background-size：cover，会使“最大”边进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。background-size:contain，会使“最小”边进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片 5、渐变linear-gradient background-image:linear-gradient(90deg,yellow 20%,green 80%) radial-gradient background-iamge:radial-gradient(120px at center center,yellow,green) 6、多列布局column-count column-width column-gap column-rule 7、过渡transition transition-property:width //property为定义过渡的css属性列表，列表以逗号分隔 transition-duration:2s; //过渡持续的时间 transition-timing-function:ease; transition-delay:5s //过渡延迟5s进行 8、动画、旋转animation transform ：translate（x,y) rotate(deg) scale(x,y) translate scale rotate skew（倾斜） 9、flex布局10、@media媒体查询display的几种常用取值1、none 此元素不会被显示，并且不占据页面空间，这也是与visibility:hidden不同的地方，设置visibility:hidden的元素，不会被显示，但是还是会占据原来的页面空间。 2、inline 行内元素 元素会在一行内显示，超出屏幕宽度自动换行，不能设置宽度和高度，元素的宽度和高度只能是靠元素内的内容撑开。 示例元素：span,b,i,a,u,sub,sup,strong,em 3、block 块级元素 会独占一行，如果不设置宽度，其宽度会自动填满父元素的宽度，可以设置宽高，即使设置了宽度，小于父元素的宽度，块级元素也会独占一行。 示例元素：div,h1-h6,ul,ol,dl,p 4、inline-block 行内块元素 与行内元素一样可以再一行内显示，而且可以设置宽高，可以设置margin和padding。 示例元素：input,button,img 5、list-item 列表元素 示例元素：li 6、table 会作为块级表格来显示(类似于)，表格前后带有换行符。 7、inline-table 会作为内联表格来显示(类似于)，表格前后没有换行符。 8、flex 多栏多列布局，火狐可以直接使用，谷歌和欧朋需要在属性值前面加-webkit-前缀，比较适合移动端开发使用。 相邻的两个inline-block节点为什么会出现间隔，该如何解决元素被当成行内元素排版的时候，原来HTML代码中的回车换行被转成一个空白符，在字体不为0的情况下，空白符占据一定宽度，所以inline-block的元素之间就出现了空隙。这些元素之间的间距会随着字体的大小而变化，当行内元素font-size:16px时，间距为8px。 解决： 1、font-size 2、改变书写方式 3、使用margin负值 4、使用word-spacing或letter-spacing Viewport面试题手机浏览器会把页面放入到一个虚拟的“视口”（viewpoint）中，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域大，也可能比浏览器的可视区域小。通常这个虚拟的“视口”（viewport）比屏幕宽，会把网页挤到一个很小的窗口。如果不显示地设置viewport，那么浏览器就会把width默认设置为980。但后果是浏览器出现横向滚动条，因为浏览器可视区域的宽度比默认的viewport的宽度小。然后浏览器引进了 viewport 这个 meta tag，让网页开发者来控制 viewport 的大小和缩放。 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; CSS实现宽度自适应100%，宽高16:9的比例的矩形第一步先计算高度，假设宽100%，那么高为h=9/16=56.25% 第二步利用之前所说设置padding-bottom方法实现矩形 12345678910111213141516171819202122232425html&lt;div class=\"box\"&gt; &lt;div class=\"scale\"&gt; &lt;p&gt;这是一个16：9的矩形&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;css.box &#123; width: 80%;&#125;.scale &#123; width: 100%; padding-bottom: 56.25%; height: 0; position: relative;&#125;.item &#123; width: 100%; height: 100%; background-color: aquamarine; position: absolute;&#125; rem布局的优缺点优点：能让我们在手机各个机型的适配方面；大大减少我们代码的重复性，是我们的代码更兼容。 缺点：目前ie不支持 对pc页面来讲使用次数不多； 数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配； 实现一个简单的三角形元素的border是由三角形组合而成 123456div &#123; width: 0; height: 0; border: 40px solid; border-color: transparent transparent red;&#125; 如何解决1px问题（1像素边框问题）1. 媒体查询利用设备像素比缩放，设置小数像素IOS8下已经支持带小数的px值, media query对应devicePixelRatio有个查询值-webkit-min-device-pixel-ratio, css可以写成这样 1234567.border &#123; border: 1px solid #999 &#125;@media screen and (-webkit-min-device-pixel-ratio: 2) &#123; .border &#123; border: 0.5px solid #999 &#125;&#125;@media screen and (-webkit-min-device-pixel-ratio: 3) &#123; .border &#123; border: 0.333333px solid #999 &#125;&#125; 【缺点】对设备有要求，小数像素目前兼容性较差。 2. viewport + rem 方案该方案是对上述方案的优化，整体思路就是利用viewport + rem + js 动态的修改页面的缩放比例，实现小于1像素的显示。在页面初始化时，在头部引入原始默认状态如下： 12&lt;meta http-equiv&#x3D;&quot;Content-Type&quot; content&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;&gt; &lt;meta name&#x3D;&quot;viewport&quot; id&#x3D;&quot;WebViewport&quot; content&#x3D;&quot;initial-scale&#x3D;1, maximum-scale&#x3D;1, minimum-scale&#x3D;1, user-scalable&#x3D;no&quot;&gt; 接下来的任务就是js的动态修改缩放比 以及 实现rem根元素字体大小的设置。 1234567891011121314var viewport &#x3D; document.querySelector(&quot;meta[name&#x3D;viewport]&quot;)if (window.devicePixelRatio &#x3D;&#x3D; 1) &#123; viewport.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width, initial-scale&#x3D;1, maximum-scale&#x3D;1, minimum-scale&#x3D;1, user-scalable&#x3D;no&#39;)&#125; if (window.devicePixelRatio &#x3D;&#x3D; 2) &#123; viewport.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width, initial-scale&#x3D;0.5, maximum-scale&#x3D;0.5, minimum-scale&#x3D;0.5, user-scalable&#x3D;no&#39;)&#125; if (window.devicePixelRatio &#x3D;&#x3D; 3) &#123; viewport.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width, initial-scale&#x3D;0.333333333, maximum-scale&#x3D;0.333333333, minimum-scale&#x3D;0.333333333, user-scalable&#x3D;no&#39;)&#125; var docEl &#x3D; document.documentElement;var fontsize &#x3D; 10 * (docEl.clientWidth &#x2F; 320) + &#39;px&#39;;docEl.style.fontSize &#x3D; fontsize; 【缺点】以为缩放涉及全局的rem单位，比较适合新项目，对于老项目可能要涉及到比较多的改动。 3. 设置 border-image 方案12345.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url(&quot;border.png&quot;) 2 0 stretch; border-image: url(&quot;border.png&quot;) 2 0 stretch;&#125; 【解释】border-width 指定边框的宽度，可以设定四个值，分别为上右下左border-width: top right bottom left。border-image 该例意为：距离图片上方2px（属性值上没有单位）裁剪边框图片作为上边框，下方2px裁剪作为下边框。距离左右0像素裁剪图片即没有边框，以拉伸方式展示 结合起来就是：在边框图片中，裁剪图片上下方的2个像素宽度作为上下边框，并展示在宽度为1个像素的边框空间里。左右没有边框。 注意这里的1个像素是特殊的，专指物理像素，而平时设定的长宽1px则表示逻辑像素，当然，这种方式引入了图片，我们还能将图片装换成base64形式表现 12345.border-image-1px &#123; border-width: 1px 0px; -webkit-border-image: url(&quot;data:image&#x2F;png;base64,xxx&quot;) 2 0 stretch; border-image: url(&#39;如上&#39;);&#125; 【缺点】需要制作图片，圆角可能出现模糊 4. background-image 渐变实现 除了使用图片外，当然也能使用纯css来实现，百度糯米团就是采用的这种方案。 12345678910.border &#123; background-image:linear-gradient(180deg, red, red 50%, transparent 50%), linear-gradient(270deg, red, red 50%, transparent 50%), linear-gradient(0deg, red, red 50%, transparent 50%), linear-gradient(90deg, red, red 50%, transparent 50%); background-size: 100% 1px,1px 100% ,100% 1px, 1px 100%; background-repeat: no-repeat; background-position: top, right top, bottom, left top; padding: 10px; &#125; 【思路】将原本1个物理像素的边框大小利用线性渐变分割成几个部分（百分比控制），实现小于1像素效果【解释】linear-gradient指定线性渐变，接受大于等于3个参数，第一个为渐变旋转角度，第二个开始为渐变的颜色和到哪个位置（百分比）全部变为该颜色，该例子中，第一句就是，渐变方向旋转180度，即从上往下（默认为0度从下往上），从红色开始渐变，到50%的位置还是红色，再渐变为继承父元素颜色。【缺点】因为每个边框都是线性渐变颜色实现，因此无法实现圆角 5. box-shadow 方案利用阴影也可以实现，优点是没有圆角问题，缺点是颜色不好控制 123div &#123; -webkit-box-shadow: 0 1px 1px -1px rgba(0, 0, 0, 0.5);&#125; 【理解】来回顾一下box-shadow属性的用法。 box-shadow: h-shadow v-shadow [blur] [spread] [color] [inset]; 参数分别表示: 水平阴影位置，垂直阴影位置，模糊距离， 阴影尺寸，阴影颜色，将外部阴影改为内部阴影，后四个可选。该例中为何将阴影尺寸设置为负数？设置成-1px 是为了让阴影尺寸稍小于div元素尺寸，这样左右两边的阴影就不会暴露出来，实现只有底部一边有阴影的效果。从而实现分割线效果（单边边框）。 6. transform: scale(0.5) 方案 - 推荐: 很灵活在以上的用法种，无非逃不开一种思想，就是将1px缩小为0.5px来展示，然而。0.5px并不是所有的设备或浏览器都支持，就考虑用媒体查询或viewport将其缩放比例。其实1像素问题的产生基本发生在设置边框或分割线的时候，场景并不覆盖全局样式，因此，直接缩放需要设置的元素，才是我们真正需要的。tranform就能实现这个需求。 设置height: 1px，根据媒体查询结合transform缩放为相应尺寸。 1234567div &#123; height:1px; background:#000; -webkit-transform: scaleY(0.5); -webkit-transform-origin:0 0; overflow: hidden;&#125; 2.用::after和::befor,设置border-bottom：1px solid #000,然后在缩放-webkit-transform: scaleY(0.5);可以实现两根边线的需求 12345div::after&#123; content:&#39;&#39;;width:100%; border-bottom:1px solid #000; transform: scaleY(0.5);&#125; 3.用::after设置border：1px solid #000; width:200%; height:200%,然后再缩放scaleY(0.5); 优点可以实现圆角，京东就是这么实现的，缺点是按钮添加active比较麻烦。 12345678910111213.div::after &#123; content: &#39;&#39;; width: 200%; height: 200%; position: absolute; top: 0; left: 0; border: 1px solid #bfbfbf; border-radius: 4px; -webkit-transform: scale(0.5,0.5); transform: scale(0.5,0.5); -webkit-transform-origin: top left;&#125; 7. 媒体查询 + transfrom 对方案1的优化123456789101112131415&#x2F;* 2倍屏 *&#x2F;@media only screen and (-webkit-min-device-pixel-ratio: 2.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125;&#125;&#x2F;* 3倍屏 *&#x2F;@media only screen and (-webkit-min-device-pixel-ratio: 3.0) &#123; .border-bottom::after &#123; -webkit-transform: scaleY(0.33); transform: scaleY(0.33); &#125;&#125; 感谢 万能的网络 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"前端面试题（一）","slug":"前端面试题（一）","date":"2020-09-22T10:44:34.487Z","updated":"2020-09-22T10:44:34.489Z","comments":true,"path":"2020/09/22/前端面试题（一）/","link":"","permalink":"https://tangleia.github.io/2020/09/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"前端面试题（一）","text":"前端面试题（一） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 1、请你讲一下js监听对象属性的改变具体是怎么实现的，它们各自有什么特点？ 在ES5中可以通过Object.defineProperty来实现已有属性的监听 1Object.defineProperty(user,&#39;name&#39;,&#123; set：function(key,value)&#123; &#125; &#125;) 缺点：如果id不在user对象中，则不能监听id的变化 在ES6中可以通过Proxy来实现 1var user &#x3D; new Proxy(&#123;&#125;，&#123; set：function(target,key,value,receiver)&#123; &#125; &#125;) 这样即使有属性在user中不存在，通过user.id来定义也同样可以这样监听这个属性的变化 2、如果要画一条0.5px的线，你会怎么去实现呢？讲讲你的方法 先画1px的，然后transform:scaleY(0.5) 利用hr标签，设置元素属性为0.5px 3、浅谈CSS3中的content-box和border-box的区别 content-box是符合w3c标准的盒模型，也是默认的盒模型 border-box是不符合w3c标准的盒模型，也称为怪异盒子 他们二者有什么区别呢？content-box是先根据设定的样式确定元素content的宽高，有border和padding的情况下再额外增加盒子的宽高，内容宽高不受影响，设定多少就是多少。 border-box是先根据设定的样式固定盒子的宽高，如果有border和padding的情况下，再根据盒子的宽高减去border或者padding，内容的宽高会受到影响，会被减去border或者padding。 4、display:none;visibility:hidden;和opacity:0;的区别 display:none; visibility:hidden; opacity:0; 它们都可以让元素隐藏掉，但是它们之间还是有区别的 display:none;隐藏后不占空间，而另外两个虽然隐藏了元素，但是还是占据着空间 而transition对于display:none;和visibility:hidden;是无效的，但是对于opacity:0;是有效的 5、状态码301，302，304不同301表示永久重定向（301 moved permanently），表示请求的资源分配了新url，以后应使用新url。 302表示临时性重定向（302 found），请求的资源临时分配了新url，本次请求暂且使用新url。302与301的区别是，302表示临时性重定向，重定向的url还有可能还会改变。 303 表示请求的资源路径发生改变，使用GET方法请求新url。她与302的功能一样，但是明确指出使用GET方法请求新url。 304 not modified 客户端发送附带条件的请求时（if-matched,if-modified-since,if-none-match,if-range,if-unmodified-since任一个）服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）。 304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3xx类别中，但是和重定向没有关系。 6、Vue的v-model的原理，Vue实例是怎么拿到data属性的在vue中v-model这个语法糖能够很方便的实现表单和数据之间的绑定，v-model实现的原理封装了一些逻辑例如：在input上绑定Message,并通过input事件获取当前事件的target.value,并赋值给message。使用v-model的组件会自动监听Input事件，并把这个input事件所携带的值，传递给v-model所绑定的属性。这样组件内部的值就给到了父组件中 7、CSS动画，transition和animation，哪一个性能更好其主要区别在于：transition需要触发一个事件才会随着时间改变其CSS属性；animation在不需要触发任何事件的情况下，也可以显式的随时间变化来改变元素CSS属性，达到一种动画的效果 transition是使一个或多个属性值产生过渡效果，animation则作用于元素本身，强调流程与控制，是关键帧动画的范畴。简单的效果可以用animation，复杂的或想要更自由地掌控应该选择transition。我认为transition会更占资源一些。 8、Vue-router 中hash模式和history模式的区别hash模式url里面永远带着#号，我们在开发当中默认使用这个模式。那么什么时候要用history模式呢？如果用户考虑url的规范那么就需要使用history模式，因为history模式没有#号，是个正常的url适合推广宣传。当然其功能也有区别，比如我们在开发app的时候有分享页面，那么这个分享出去的页面就是用vue或是react做的，咱们把这个页面分享到第三方的app里，有的app里面url是不允许带有#号的，所以要将#号去除那么就要使用history模式，但是使用history模式还有一个问题就是，在访问二级页面的时候，做刷新操作，会出现404错误，那么就需要和后端人配合让他配置一下apache或是nginx的url重定向，重定向到首页路由上。 hash原理比如在用超链接制作锚点跳转的时候，就会发现，url后面跟了”#id”，hash值就是url中从”#”号开始到结束的部分。hash值变化浏览器不会重新发起请求，但是会触发window.hashChange事件，假如我们在hashChange事件中获取当前的hash值，并根据hash值来修改页面内容，则达到了前端路由的目的。 history原理history模式原理可以这样理解，首先我们要改造我们的超链接，给每个超链接增加onclick方法，阻止默认的超链接跳转，改用history.pushState或history.replaceState来更改浏览器中的url，并修改页面内容。由于通过history的api调整，并不会向后端发起请求，所以也就达到了前端路由的目的 Koa和Express的区别，以及Koa中间键的原理 9、用JS实现一个sleep函数123456789101112131415161718192021222324252627282930//方法一function sleep1(ms,callback)&#123; setTimeout(callback,ms)&#125;sleep1(1000,()=&gt;&#123; console.log(1000)&#125;)//方法二function sleep2(ms)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(resolve,ms) &#125;)&#125;sleep2(2000).then(()=&gt;&#123; console.log(2000)&#125;)//方法三function sleep3(ms)&#123; return new Promise(function(resolve,reject)&#123; setTimeout(resolve,ms) &#125;)&#125;async function init( await sleep3(3000))init().then(()=&gt;&#123; console.log(3000)&#125;) 10、bootstrap实现响应式布局原理Bootstrap的官方解释：Bootstrap提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口（viewport）尺寸的增加，系统会自动分为做12列。 11、浏览器的重排和重绘是什么意思？重绘的触发条件？如何避免重绘重排？当 DOM 元素的属性发生变化 (如 color) 时, 浏览器会通知 render 重新描绘相应的元素, 此过程称为 repaint。 如果该次变化涉及元素布局 (如 width), 浏览器则抛弃原有属性, 重新计算并把结果传递给 render 以重新描绘页面元素, 此过程称为 reflow 减少重绘重排1.分离读写操作 2.样式集中改变 可以添加一个类，样式都在类中改变 3.可以使用absolute脱离文档流。 4.使用 display:none ，不使用 visibility，也不要改变 它的 z-index 5.能用css3实现的就用css3实现。 跨域问题JSONP Hash postMessage(HTML5) WebSocket CORS(支持跨域通信的Ajax) CORS背后的思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。 同源策略 URL 说明 是否允许通信 http://www.a.com/a.js http://www.a.com/b.js 同一域名下 允许 http://www.a.com/lab/a.js http://www.a.com/script/b.js 同一域名下不同文件夹 允许 http://www.a.com:8000/a.js http://www.a.com/b.js 同一域名，不同端口 不允许 http://www.a.com/a.js https://www.a.com/b.js 同一域名，不同协议 不允许 http://www.a.com/a.js http://70.32.92.74/b.js 域名和域名对应ip 不允许 http://www.a.com/a.js http://script.a.com/b.js 主域相同，子域不同 不允许 http://www.a.com/a.js http://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问） http://www.cnblogs.com/a.js http://www.a.com/b.js 不同域名 不允许 如何产生闭包当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时，产生闭包 HTTP 2.0 给我们带了很多新的特性，简单总结一下： 二进制分帧 多路复用 首部压缩 流量控制 请求优先级 服务器推送 感谢 浅述函数防抖和函数节流 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"前端面试—函数防抖与函数节流","slug":"前端面试—函数防抖与函数节流","date":"2020-09-22T04:24:20.344Z","updated":"2020-09-22T04:24:20.344Z","comments":true,"path":"2020/09/22/前端面试—函数防抖与函数节流/","link":"","permalink":"https://tangleia.github.io/2020/09/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81/","excerpt":"前端面试—函数防抖与函数节流","text":"前端面试—函数防抖与函数节流 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 函数防抖（debounce）函数防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 简单的说，当一个动作连续触发，则只执行最后一次。 举例打个比方，坐公交，司机需要等最后一个人进入才能关门。每次进入一个人，司机就会多等待几秒再关门。 应用场景连续的事件，只需触发一次回调的场景有： 搜索框搜索输入。只需用户最后一次输入完，再发送请求 手机号、邮箱验证输入检测 窗口大小Resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。 简单实现函数防抖在执行目标方法时，会等待一段时间。当又执行相同方法时，若前一个定时任务未执行完，则 clear 掉定时任务，重新定时。 1234567const _.debounce = (func, wait) =&gt; &#123; let timer; return () =&gt; &#123; clearTimeout(timer); timer = setTimeout(func, wait); &#125;;&#125;; 函数节流（throttle）限制一个函数在一定时间内只能执行一次。 举例乘坐地铁，过闸机时，每个人进入后3秒后门关闭，等待下一个人进入。 应用场景间隔一段时间执行一次回调的场景有： 滚动加载，加载更多或滚到底部监听 谷歌搜索框，搜索联想功能 高频点击提交，表单重复提交 简单实现函数节流的目的，是为了限制函数一段时间内只能执行一次。因此，通过使用定时任务，延时方法执行。在延时的时间内，方法若被触发，则直接退出方法。从而，实现函数一段时间内只执行一次。 123456789101112const _.throttle = (func, wait) =&gt; &#123; let timer; return () =&gt; &#123; if (timer) &#123; return; &#125; timer = setTimeout(() =&gt; &#123; func(); timer = null; &#125;, wait); &#125;;&#125;; 感谢 浅述函数防抖和函数节流 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"前端面试—Koa与Express的区别","slug":"前端面试—Koa与Express的区别","date":"2020-09-22T03:45:02.377Z","updated":"2020-09-22T03:45:02.377Z","comments":true,"path":"2020/09/22/前端面试—Koa与Express的区别/","link":"","permalink":"https://tangleia.github.io/2020/09/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94Koa%E4%B8%8EExpress%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"前端面试—Koa与Express的区别","text":"前端面试—Koa与Express的区别 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍Koa 基于node的一个web开发框架，利用co作为底层运行框架，利用Generator的特性，实现“无回调”的异步处理； ES7; 更小、更富有表现力、更健壮的基石； 利用async函数、Koa丢弃回调函数，增强错误处理； 很小的体积，因为没有捆绑任何中间件； 类似堆栈的方式组织和执行； 低级中间件层中提供高级“语法糖”，提高了互操性、稳健性； Express Node的基础框架，基础Connect中间件，自身封装了路由、视图处理等功能； 线性逻辑，路由和中间件完美融合，清晰明了； 弊端是callback回调方式，不可组合、异常不可捕获； ES5; connect的执行流程： connect的中间件模型是线性的，即一个一个往下执行； 区别 Handler的处理 12Express普通回调函数，在同一线程上完成当前进程的所有Http请求；Koa利用Generator Function作为响应器，co作为底层运行框架，利用Generator特性，实现“协程响应”； 路由 12Express的路由是自身集成的； Koa的需要引入中间件Koa-router； 启动方式 12koa采用new Koa()express采用传统的函数形式function； 回调 12Koa没有回调express有回调； Http Request 1koa1使用this取代Express的req、res； Context 12Koa新增了一个Context对象，用来代替Express的Request和Response，作为请求的上下文对象。 还有Node原生提供的req、res、socket等对象； 生命周期 12Express的生命周期不确定：express内部执行异步函数，不能确定什么时候执行完； Koa确定：koa是基于await&#x2F;async，在执行下一步操作的时候，必须等待前端await执行完； 异步流程 123Express采用callback来处理异步(ES5)；Koa1采用generator(ES6)；Koa2采用async&#x2F;await(ES7)； 错误处理 12Express使用callback捕获异常，深层次的异常捕获不了；Koa使用try catch，很好的解决异常捕获； 中间件 123456789koa2的中间件： 1、通过async await实现的，中间件执行的顺序是“洋葱圈”模型。 2、中间件之间通过next函数联系，当一个中间件调用next()后，会将控制权交给下一个中间件，直到下一个中间件不再执行next()后，会沿路返回，将控制权交给前一个中间件。Express中间件： 1、一个接一个顺序执行，response响应写在最后一个中间件中。 2、特点： a.app.use用来注册中间件； b.遇到http请求，根据path和method判断触发哪些中间件； c.实现next机制，即上一个中间件会通过next触发下一个中间件； 感谢 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"前端面试—Http请求头中Referer的含义和作用","slug":"前端面试—Http请求头中Referer的含义和作用","date":"2020-09-22T01:32:17.209Z","updated":"2020-09-22T01:32:17.209Z","comments":true,"path":"2020/09/22/前端面试—Http请求头中Referer的含义和作用/","link":"","permalink":"https://tangleia.github.io/2020/09/22/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94Http%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%ADReferer%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8/","excerpt":"前端面试—Http请求头中Referer的含义和作用","text":"前端面试—Http请求头中Referer的含义和作用 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。 作用防盗链假如在www.google.com里有一个`www.baidu.com`链接，那么点击进入这个`www.baidu.com`，它的header信息里就有：Referer=http://www.google.com 只允许我本身的网站访问本身的图片服务器，假如域是www.google.com，那么图片服务器每次取到Referer来判断一下域名是不是www.google.com，如果是就继续访问，不是就拦截。 将这个http请求发给服务器后，如果服务器要求必须是某个地址或者某几个地址才能访问，而你发送的referer不符合他的要求，就会拦截或者跳转到他要求的地址，然后再通过这个地址进行访问。 防止恶意请求比如静态请求是*.html结尾的，动态请求是*.shtml，那么由此可以这么用，所有的*.shtml请求，必须Referer为我自己的网站。 空Referer定义：Referer头部的内容为空，或者，一个HTTP请求中根本不包含Referer头部（一个请求并不是由链接触发产生的） 直接在浏览器的地址栏中输入一个资源的URL地址，那么这种请求是不会包含Referer字段的，因为这是一个“凭空产生”的HTTP请求，并不是从一个地方链接过去的。 那么在防盗链设置中，允许空Referer和不允许空Referer有什么区别？ 允许Referer为空，意味着你允许比如浏览器直接访问。 防御CSRF比对HTTP 请求的来源地址，如果Referer中的地址是安全可信任的地址，那么就放行 感谢 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"Http状态码详解","slug":"Http状态码详解","date":"2020-09-21T02:42:09.504Z","updated":"2020-09-21T02:42:09.510Z","comments":true,"path":"2020/09/21/Http状态码详解/","link":"","permalink":"https://tangleia.github.io/2020/09/21/Http%E7%8A%B6%E6%80%81%E7%A0%81%E8%AF%A6%E8%A7%A3/","excerpt":"Http状态码详解","text":"Http状态码详解 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码。 100（继续） 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101（切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx （成功）表示成功处理了请求的状态码。 200（成功） 服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果是对您的 robots.txt 文件显示此状态码，则表示 Googlebot 已成功检索到该文件。 201（已创建） 请求成功并且服务器创建了新的资源。 202（已接受） 服务器已接受请求，但尚未处理。 203（非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204（无内容） 服务器成功处理了请求，但没有返回任何内容。 205（重置内容） 服务器成功处理了请求，但没有返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如，清除表单内容以输入新内容）。 206（部分内容） 服务器成功处理了部分 GET 请求。 3xx （重定向）要完成请求，需要进一步操作。通常，这些状态码用来重定向。 300（多种选择） 针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301（永久移动） 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302（临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303（查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304（未修改） 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。. 305（使用代理） 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307（临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 &lt;a href=answer.py?answer=&gt;301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个页面或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理。 400（错误请求） 服务器不理解请求的语法。 401（未授权） 请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403（禁止） 服务器拒绝请求。 404（未找到） 服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。 405（方法禁用） 禁用请求中指定的方法。 406（不接受） 无法使用请求的内容特性响应请求的网页。 407（需要代理授权） 此状态码与 &lt;a href=answer.py?answer=35128&gt;401（未授权）类似，但指定请求者应当授权使用代理。如果服务器返回此响应，还表示请求者应当使用代理。 408（请求超时） 服务器等候请求时发生超时。 409（冲突） 服务器在完成请求时发生冲突。服务器必须在响应中包含有关冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，以及两个请求的差异列表。 410（已删除） 如果请求的资源已永久删除，服务器就会返回此响应。该代码与 404（未找到）代码类似，但在资源以前存在而现在不存在的情况下，有时会用来替代 404 代码。如果资源已永久移动，您应使用 301 指定资源的新位置。 411（需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412（未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 413（请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414（请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415（不支持的媒体类型） 请求的格式不受请求页面的支持。 416（请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态码。 417（未满足期望值） 服务器未满足”期望”请求标头字段的要求。 5xx（服务器错误）这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500（服务器内部错误） 服务器遇到错误，无法完成请求。 501（尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502（错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 503（服务不可用） 服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。 504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505（HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。 感谢 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"前端面试—new操作符的原理解析","slug":"前端面试—new操作符的原理解析","date":"2020-09-21T02:24:14.612Z","updated":"2020-09-21T02:24:14.612Z","comments":true,"path":"2020/09/21/前端面试—new操作符的原理解析/","link":"","permalink":"https://tangleia.github.io/2020/09/21/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94new%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/","excerpt":"前端面试—new操作符的原理解析","text":"前端面试—new操作符的原理解析 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ new实例JavaScript中new操作符用于创建一个给定构造函数的对象实例 123456function Person(name, age)&#123; this.name = name; this.age = age;&#125;const res = new Person('Tom', 20)console.log(res) // Person &#123;name: \"Tom\", age: 20&#125; 原型，构造函数，实例的关系 原型（prototype）:一个简单的对象，用于实现对象的属性继承。可以简单理解成对象的父亲。在火狐和谷歌中，每个js对象中都包含一个proto(非标准)的属性指向它爹（该对象原型），可obj.proto进行访问。 构造函数：可以 通过new来新建一个对象 的函数。 实例：通过 构造函数 和 new 创建出来的 对象，就是实例。实例通过proto指向原型，通过constructor指向构造函数。 因此看得出三者的关系1234实例.__proto__&#x3D;&#x3D;&#x3D;原型原型.constructor &#x3D;&#x3D;&#x3D; 构造函数构造函数.prototype &#x3D;&#x3D;&#x3D; 原型实例.constructor &#x3D;&#x3D;&#x3D; 构造函数 new操作符实现原理 新生成一个对象 链接到原型 绑定this 返回新对象（如果构造函数有自己 retrun 时，则返回该值） 1234567891011121314function myNew(constrc, ...args) &#123; const obj = &#123;&#125;; // 1. 创建一个空对象 obj.__proto__ = constrc.prototype; // 2. 将obj的[[prototype]]属性指向构造函数的原型对象 const result = constrc.apply(obj, args); // 3.将constrc执行的上下文this绑定到obj上，并执行 return result instanceof Object ? result : obj; //4. 如果构造函数返回的是对象，则使用构造函数执行的结果。否则，返回新创建的对象&#125;// 使用的例子：function Person(name, age)&#123; this.name = name; this.age = age;&#125;const res = myNew(Person, 'Tom', 20)console.log(res) // Person &#123;name: \"Tom\", age: 20&#125; 感谢 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–链表中倒数第k个节点","slug":"LeetCode–链表中倒数第k个节点","date":"2020-09-11T11:20:12.000Z","updated":"2020-09-11T11:20:12.000Z","comments":true,"path":"2020/09/11/LeetCode–链表中倒数第k个节点/","link":"","permalink":"https://tangleia.github.io/2020/09/11/LeetCode%E2%80%93%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"LeetCode–链表中倒数第k个节点","text":"LeetCode–链表中倒数第k个节点 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 22. 链表中倒数第k个节点 题目输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例：123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.返回链表 4-&gt;5. 思路 初始化： 前指针 former 、后指针 latter ，双指针都指向头节点 head 。 构建双指针距离： 前指针 former 先向前走 k 步（结束后，双指针 former 和 latter 间相距 k 步）。 双指针共同移动： 循环中，双指针 former 和 latter 每轮都向前走一步，直至 former 走过链表 尾节点 时跳出（跳出后， latter 与尾节点距离为 k-1，即 latter 指向倒数第 k 个节点）。 返回值： 返回 latter 即可。 代码123456789101112131415161718192021/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode getKthFromEnd(ListNode head, int k) &#123; ListNode former = head, latter = head; for(int i = 0; i &lt; k; i++)&#123; former = former.next; &#125; while(former != null)&#123; former = former.next; latter = latter.next; &#125; return latter; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–调整数组顺序使奇数位于偶数前面","slug":"LeetCode–调整数组顺序使奇数位于偶数前面","date":"2020-09-11T09:59:04.000Z","updated":"2020-09-11T09:59:04.000Z","comments":true,"path":"2020/09/11/LeetCode–调整数组顺序使奇数位于偶数前面/","link":"","permalink":"https://tangleia.github.io/2020/09/11/LeetCode%E2%80%93%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","excerpt":"LeetCode–调整数组顺序使奇数位于偶数前面","text":"LeetCode–调整数组顺序使奇数位于偶数前面 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 题目输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例：123输入：nums &#x3D; [1,2,3,4]输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 提示：121 &lt;&#x3D; nums.length &lt;&#x3D; 500001 &lt;&#x3D; nums[i] &lt;&#x3D; 10000 思路 初始化： i , j 双指针，分别指向数组 nums 左右两端； 循环交换： 当i=j 时跳出； 指针 i遇到奇数则执行 i = i + 1跳过，直到找到偶数； 指针 j 遇到偶数则执行 j = j - 1 跳过，直到找到奇数； 交换 nums[i] 和 nums[j] 值； 返回值： 返回已修改的 nums 数组。 代码1234567891011121314151617class Solution &#123; public int[] exchange(int[] nums) &#123; int i = 0, j = nums.length - 1,temp; while(i &lt; j)&#123; while(i &lt; j &amp;&amp; (nums[i] &amp; 1) == 1)&#123; i++; &#125; while(i &lt; j &amp;&amp; (nums[j] &amp; 1) == 0)&#123; j--; &#125; temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; return nums; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–正则表达式匹配","slug":"LeetCode–正则表达式匹配","date":"2020-09-11T09:42:12.000Z","updated":"2020-09-11T09:42:12.000Z","comments":true,"path":"2020/09/11/LeetCode–正则表达式匹配/","link":"","permalink":"https://tangleia.github.io/2020/09/11/LeetCode%E2%80%93%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"LeetCode–正则表达式匹配","text":"LeetCode–正则表达式匹配 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 19. 正则表达式匹配 主站 10 题目请实现一个函数用来匹配包含’. ‘和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但与”aa.a”和”ab*a”均不匹配。 示例 1:12345输入:s &#x3D; &quot;aa&quot;p &#x3D; &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2:12345输入:s &#x3D; &quot;aa&quot;p &#x3D; &quot;a*&quot;输出: true解释: 因为 &#39;*&#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#39;a&#39;。因此，字符串 &quot;aa&quot; 可被视为 &#39;a&#39; 重复了一次。 示例 3:12345输入:s &#x3D; &quot;ab&quot;p &#x3D; &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&#39;*&#39;）任意字符（&#39;.&#39;）。 示例 4:12345输入:s &#x3D; &quot;aab&quot;p &#x3D; &quot;c*a*b&quot;输出: true解释: 因为 &#39;*&#39; 表示零个或多个，这里 &#39;c&#39; 为 0 个, &#39;a&#39; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5:123456输入:s &#x3D; &quot;mississippi&quot;p &#x3D; &quot;mis*is*p*.&quot;输出: falses 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 &#39;*&#39;。 思路 如果 BB 的最后一个字符是正常字符，那就是看 A[n-1] 是否等于 B[m-1]，相等则看 A_{0..n-2}与 B_{0..m-2} ，不等则是不能匹配，这就是子问题。 如果 BB 的最后一个字符是’.’，它能匹配任意字符，直接看 A_{0..n-2}与 B_{0..m-2} 如果 B 的最后一个字符是’‘,它代表 B[m-2]=c 可以重复0次或多次，它们是一个整体 c 情况一：A[n-1] 是 0 个 c，B 最后两个字符废了，能否匹配取决于 A_{0..n-1}和 B_{0..m-3}是否匹配 情况二：A[n-1] 是多个 c 中的最后一个（这种情况必须 A[n-1]=c 或者 c=’.’），所以 A 匹配完往前挪一个，B继续匹配，因为可以匹配多个，继续看 A_{0..n-2}和 B_{0..m-1}是否匹配。 代码123456789101112131415161718192021222324252627class Solution &#123; public boolean isMatch(String s, String p) &#123; int n = s.length(), m = p.length(); boolean[][] f = new boolean[n+1][m+1]; for(int i = 0; i &lt;= n; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; if(j == 0)&#123; f[i][j] = i == 0; &#125;else&#123; //非空正则 if(p.charAt(j-1) != '*')&#123; //非* if(i &gt; 0 &amp;&amp; (s.charAt(i-1) == p.charAt(j-1) || p.charAt(j-1) == '.'))&#123; f[i][j] = f[i-1][j-1]; &#125; &#125;else&#123; //* if(j &gt;= 2)&#123; f[i][j] |= f[i][j-2]; &#125; if(i &gt;= 1 &amp;&amp; j &gt;= 2 &amp;&amp; (s.charAt(i-1) == p.charAt(j-2) || p.charAt(j-2) == '.'))&#123; f[i][j] |= f[i-1][j]; &#125; &#125; &#125; &#125; &#125; return f[n][m]; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"uni-app搜索功能前后端开发（页面）","slug":"uni-app搜索功能前后端开发（页面）","date":"2020-09-10T09:41:13.000Z","updated":"2020-09-10T09:41:13.000Z","comments":true,"path":"2020/09/10/uni-app搜索功能前后端开发（页面）/","link":"","permalink":"https://tangleia.github.io/2020/09/10/uni-app%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E5%89%8D%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%EF%BC%88%E9%A1%B5%E9%9D%A2%EF%BC%89/","excerpt":"uni-app搜索功能前后端开发（页面）","text":"uni-app搜索功能前后端开发（页面） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 借助的插件地址插件地址 展示前端是使用vue，后端使用Java的springBoot开发 监控搜索框uni-app注意根据自己的需求来改 123456789101112131415161718192021222324252627async getSearch(keyword) &#123; let [err, res] = await this.$http.post('/shop/search',&#123; name:keyword &#125;); // 请求失败处理 this.$http.errorCheck(err, res); this.keywordList = []; this.keywordList = this.drawCorrelativeKeyword(res.data.data, keyword);&#125;,//高亮关键字drawCorrelativeKeyword(keywords, keyword) &#123; var len = keywords.length, keywordArr = []; for (var i = 0; i &lt; len; i++) &#123; var row = keywords[i]; //定义高亮#9f9f9f var html = row.name.replace(keyword, \"&lt;span style='color: #9f9f9f;'&gt;\" + keyword + \"&lt;/span&gt;\"); html = '&lt;div&gt;' + html + '&lt;/div&gt;'; var tmpObj = &#123; keyword: row.name, htmlStr: html, id:row.id &#125;; keywordArr.push(tmpObj) &#125; return keywordArr;&#125;, 后端接口开发123456789101112/** * 根据传递过来的值查询商家 * @param name * @return */@ApiOperation(value = \"搜索商家\", notes = \"首页搜索商家\")@ApiImplicitParam(name=\"name\", value=\"商家名字\", required = true, dataType = \"String\")@RequestMapping(value = \"/search\", method = &#123;RequestMethod.POST&#125;)public Object search(@RequestParam(defaultValue = \"\") String name) &#123; List&lt;Shop&gt; shops = shopService.list(new QueryWrapper&lt;Shop&gt;().select(\"id\",\"name\").eq(\"flag\", 1).like(\"name\",name)); return Result.success(shops);&#125; 效果根据自己的需求改一下vue绑定的值 热门搜索列表uni-app123456789//加载热门搜索async loadHotKeyword() &#123; let [err, res] = await this.$http.get('/shop/searchList'); console.log(res); // 请求失败处理 this.$http.errorCheck(err, res); //定义热门搜索关键字，可以自己实现ajax请求数据再赋值 this.hotKeywordList = res.data.data;&#125;, 后端12345678910/** * 查询热门搜索商家 * @return */@ApiOperation(value = \"搜索热门列表\", notes = \"搜索热门列表\")@GetMapping(\"/searchList\")public Object searchList() &#123; List&lt;ShopSearch&gt; shopSearchs = shopSearchService.list(new QueryWrapper&lt;ShopSearch&gt;().orderByDesc(\"number\")); return Result.success(shopSearchs);&#125; 其他的功能是用了插件里面的 感谢 uni-app 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–删除链表的节点","slug":"LeetCode–删除链表的节点","date":"2020-09-10T03:47:41.000Z","updated":"2020-09-10T03:47:41.000Z","comments":true,"path":"2020/09/10/LeetCode–删除链表的节点/","link":"","permalink":"https://tangleia.github.io/2020/09/10/LeetCode%E2%80%93%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"LeetCode–删除链表的节点","text":"LeetCode–删除链表的节点 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 18. 删除链表的节点 题目给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 示例 1:123输入: head &#x3D; [4,5,1,9], val &#x3D; 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 示例 2:123输入: head &#x3D; [4,5,1,9], val &#x3D; 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明：12题目保证链表中节点的值互不相同若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 思路 特例处理： 当应删除头节点 head 时，直接返回 head.next 即可。 初始化： pre = head , cur = head.next 。 定位节点： 当 cur 为空 或 cur 节点值等于 val 时跳出。 保存当前节点索引，即 pre = cur 。 遍历下一节点，即 cur = cur.next 。 删除节点： 若 cur 指向某节点，则执行 pre.next = cur.next 。（若 cur 指向 nullnull ，代表链表中不包含值为 val 的节点。 返回值： 返回链表头部节点 head 即可。 代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode deleteNode(ListNode head, int val) &#123; if(head.val == val)&#123; return head.next; &#125; ListNode pre = head, cur = head.next; while(cur != null &amp;&amp; cur.val != val)&#123; pre = cur; cur = cur.next; &#125; if(cur != null)&#123; pre.next = cur.next; &#125; return head; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–打印从1到最大的n位数","slug":"LeetCode–打印从1到最大的n位数","date":"2020-09-10T02:08:57.000Z","updated":"2020-09-10T02:08:57.000Z","comments":true,"path":"2020/09/10/LeetCode–打印从1到最大的n位数/","link":"","permalink":"https://tangleia.github.io/2020/09/10/LeetCode%E2%80%93%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/","excerpt":"LeetCode–打印从1到最大的n位数","text":"LeetCode–打印从1到最大的n位数 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 17. 打印从1到最大的n位数 题目输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1:12输入: n &#x3D; 1输出: [1,2,3,4,5,6,7,8,9] 说明：12用返回一个整数列表来代替打印n 为正整数 代码12345678910class Solution &#123; public int[] printNumbers(int n) &#123; int num = (int)Math.pow(10,n) - 1; int[] res = new int[num]; for(int i = 0; i &lt; num; i++)&#123; res[i] = i+1; &#125; return res; &#125;&#125; 大数打印 123456789101112131415161718192021222324252627class Solution &#123; int[] res; int nine = 0, count = 0, start, n; char[] num, loop = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'&#125;; public int[] printNumbers(int n) &#123; this.n = n; res = new int[(int)Math.pow(10, n) - 1]; num = new char[n]; start = n - 1; dfs(0); return res; &#125; void dfs(int x) &#123; if(x == n) &#123; String s = String.valueOf(num).substring(start); if(!s.equals(\"0\")) res[count++] = Integer.parseInt(s); if(n - start == nine) start--; return; &#125; for(char i : loop) &#123; if(i == '9') nine++; num[x] = i; dfs(x + 1); &#125; nine--; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（十）— 踏棋盘算法","slug":"常用十大算法（十）— 踏棋盘算法","date":"2020-09-09T06:35:19.000Z","updated":"2020-09-09T06:35:19.000Z","comments":true,"path":"2020/09/09/常用十大算法（十）— 踏棋盘算法/","link":"","permalink":"https://tangleia.github.io/2020/09/09/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%81%EF%BC%89%E2%80%94%20%E8%B8%8F%E6%A3%8B%E7%9B%98%E7%AE%97%E6%B3%95/","excerpt":"常用十大算法（十）— 踏棋盘算法","text":"常用十大算法（十）— 踏棋盘算法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍 马踏棋盘算法也被称为骑士周游问题 将马随机放在国际象棋的8×8棋盘Board0～7]的某个方格中，马按走棋规则(马走日字)进行移动。要求每个方格只进入一次，走遍棋盘上全部64个方格 思路 马踏棋盘问题(骑士周游问题)实际上是图的深度优先搜索(DFS)的应用。 如果使用回溯（就是深度优先搜索）来解决，假如马儿踏了53个点，如图：走到了第53个，坐标（1,0），发现已经走到尽头，没办法，那就只能回退了，查看其他的路径，就在棋盘上不停的回溯…… ， 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package com.atguigu.horse;import java.awt.Point;import java.util.ArrayList;import java.util.Comparator;public class HorseChessboard &#123; private static int X; // 列 private static int Y; // 行 private static boolean visited[]; private static boolean finished; public static void main(String[] args) &#123; X = 8; Y = 8; int row = 1; int column = 1; int[][] chessboard = new int[X][Y]; visited = new boolean[X * Y]; long start = System.currentTimeMillis(); traversalChessboard(chessboard, row - 1, column - 1, 1); long end = System.currentTimeMillis(); System.out.println(\"时间: \" + (end - start)); for(int[] rows : chessboard) &#123; for(int step: rows) &#123; System.out.print(step + \"\\t\"); &#125; System.out.println(); &#125; &#125; public static void traversalChessboard(int[][] chessboard, int row, int column, int step) &#123; chessboard[row][column] = step; visited[row * X + column] = true; ArrayList&lt;Point&gt; ps = next(new Point(column, row)); sort(ps); while(!ps.isEmpty()) &#123; Point p = ps.remove(0); if(!visited[p.y * X + p.x]) &#123; traversalChessboard(chessboard, p.y, p.x, step + 1); &#125; &#125; if(step &lt; X * Y &amp;&amp; !finished ) &#123; chessboard[row][column] = 0; visited[row * X + column] = false; &#125; else &#123; finished = true; &#125; &#125; public static ArrayList&lt;Point&gt; next(Point curPoint) &#123; ArrayList&lt;Point&gt; ps = new ArrayList&lt;Point&gt;(); Point p1 = new Point(); if((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y -1) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; if((p1.x = curPoint.x - 1) &gt;=0 &amp;&amp; (p1.y=curPoint.y-2)&gt;=0) &#123; ps.add(new Point(p1)); &#125; if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y - 2) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y - 1) &gt;= 0) &#123; ps.add(new Point(p1)); &#125; if ((p1.x = curPoint.x + 2) &lt; X &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123; ps.add(new Point(p1)); &#125; if ((p1.x = curPoint.x + 1) &lt; X &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123; ps.add(new Point(p1)); &#125; if ((p1.x = curPoint.x - 1) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 2) &lt; Y) &#123; ps.add(new Point(p1)); &#125; if ((p1.x = curPoint.x - 2) &gt;= 0 &amp;&amp; (p1.y = curPoint.y + 1) &lt; Y) &#123; ps.add(new Point(p1)); &#125; return ps; &#125; //排序 public static void sort(ArrayList&lt;Point&gt; ps) &#123; ps.sort(new Comparator&lt;Point&gt;() &#123; @Override public int compare(Point o1, Point o2) &#123; int count1 = next(o1).size(); int count2 = next(o2).size(); if(count1 &lt; count2) &#123; return -1; &#125; else if (count1 == count2) &#123; return 0; &#125; else &#123; return 1; &#125; &#125; &#125;); &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（九）— 弗洛伊德算法","slug":"常用十大算法（九）— 弗洛伊德算法","date":"2020-09-09T06:25:43.000Z","updated":"2020-09-09T06:25:43.000Z","comments":true,"path":"2020/09/09/常用十大算法（九）— 弗洛伊德算法/","link":"","permalink":"https://tangleia.github.io/2020/09/09/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E4%B9%9D%EF%BC%89%E2%80%94%20%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95/","excerpt":"常用十大算法（九）— 弗洛伊德算法","text":"常用十大算法（九）— 弗洛伊德算法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍 弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法 最短路径问题 胜利乡有7个村庄(A, B, C, D, E, F, G) 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里 问：如何计算出各村庄到 其它各村庄的最短距离? 思路 设置顶点vi到顶点vk的最短路径已知为Lik，顶点vk到vj的最短路径已知为Lkj，顶点vi到vj的路径为Lij，则vi到vj的最短路径为：min((Lik+Lkj),Lij)，vk的取值为图中所有顶点，则可获得vi到vj的最短路径 至于vi到vk的最短路径Lik或者vk到vj的最短路径Lkj，是以同样的方式获得 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.atguigu.floyd;import java.util.Arrays;public class FloydAlgorithm &#123; public static void main(String[] args) &#123; char[] vertex = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; int[][] matrix = new int[vertex.length][vertex.length]; final int N = 65535; matrix[0] = new int[] &#123; 0, 5, 7, N, N, N, 2 &#125;; matrix[1] = new int[] &#123; 5, 0, N, 9, N, N, 3 &#125;; matrix[2] = new int[] &#123; 7, N, 0, N, 8, N, N &#125;; matrix[3] = new int[] &#123; N, 9, N, 0, N, 4, N &#125;; matrix[4] = new int[] &#123; N, N, 8, N, 0, 5, 4 &#125;; matrix[5] = new int[] &#123; N, N, N, 4, 5, 0, 6 &#125;; matrix[6] = new int[] &#123; 2, 3, N, N, 4, 6, 0 &#125;; Graph graph = new Graph(vertex.length, matrix, vertex); graph.floyd(); graph.show(); &#125;&#125;class Graph &#123; private char[] vertex; private int[][] dis; private int[][] pre; public Graph(int length, int[][] matrix, char[] vertex) &#123; this.vertex = vertex; this.dis = matrix; this.pre = new int[length][length]; for (int i = 0; i &lt; length; i++) &#123; Arrays.fill(pre[i], i); &#125; &#125; public void show() &#123; char[] vertex = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; for (int k = 0; k &lt; dis.length; k++) &#123; for (int i = 0; i &lt; dis.length; i++) &#123; System.out.print(vertex[pre[k][i]] + \" \"); &#125; System.out.println(); for (int i = 0; i &lt; dis.length; i++) &#123; System.out.print(\"(\"+vertex[k]+\"µ½\"+vertex[i]+\"µÄ×î¶ÌÂ·¾¶ÊÇ\" + dis[k][i] + \") \"); &#125; System.out.println(); System.out.println(); &#125; &#125; public void floyd() &#123; int len = 0; for(int k = 0; k &lt; dis.length; k++) &#123; for(int i = 0; i &lt; dis.length; i++) &#123; for(int j = 0; j &lt; dis.length; j++) &#123; len = dis[i][k] + dis[k][j]; if(len &lt; dis[i][j]) &#123; dis[i][j] = len; pre[i][j] = pre[k][j]; &#125; &#125; &#125; &#125; &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（八）— 迪杰斯特拉算法","slug":"常用十大算法（八）— 迪杰斯特拉算法","date":"2020-09-09T06:10:25.000Z","updated":"2020-09-09T06:10:25.000Z","comments":true,"path":"2020/09/09/常用十大算法（八）— 迪杰斯特拉算法/","link":"","permalink":"https://tangleia.github.io/2020/09/09/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AB%EF%BC%89%E2%80%94%20%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/","excerpt":"常用十大算法（八）— 迪杰斯特拉算法","text":"常用十大算法（八）— 迪杰斯特拉算法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍 迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。 它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止 最短路径问题 战争时期，胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G点出发，需要分别把邮件分别送到 A, B, C , D, E, F 六个村庄 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里 问：如何计算出G村庄到 其它各个村庄的最短距离? 如果从其它点出发到各个点的最短距离又是多少? 思路 设置出发顶点为v，顶点集合V{v1,v2,vi…}，v到V中各顶点的距离构成距离集合Dis，Dis{d1,d2,di…}，Dis集合记录着v到图中各顶点的距离(到自身可以看作0，v到vi距离对应为di) 从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi，此时的v到vi即为最短路径 更新Dis集合，更新规则为： 比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个(同时也应该更新顶点的前驱节点为vi，表明是通过vi到达的) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package com.atguigu.dijkstra;import java.util.Arrays;public class DijkstraAlgorithm &#123; public static void main(String[] args) &#123; char[] vertex = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; int[][] matrix = new int[vertex.length][vertex.length]; final int N = 65535; matrix[0]=new int[]&#123;N,5,7,N,N,N,2&#125;; matrix[1]=new int[]&#123;5,N,N,9,N,N,3&#125;; matrix[2]=new int[]&#123;7,N,N,N,8,N,N&#125;; matrix[3]=new int[]&#123;N,9,N,N,N,4,N&#125;; matrix[4]=new int[]&#123;N,N,8,N,N,5,4&#125;; matrix[5]=new int[]&#123;N,N,N,4,5,N,6&#125;; matrix[6]=new int[]&#123;2,3,N,N,4,6,N&#125;; Graph graph = new Graph(vertex, matrix); graph.showGraph(); graph.dsj(2); graph.showDijkstra(); &#125;&#125;class Graph &#123; private char[] vertex; private int[][] matrix; private VisitedVertex vv; public Graph(char[] vertex, int[][] matrix) &#123; this.vertex = vertex; this.matrix = matrix; &#125; public void showDijkstra() &#123; vv.show(); &#125; public void showGraph() &#123; for (int[] link : matrix) &#123; System.out.println(Arrays.toString(link)); &#125; &#125; public void dsj(int index) &#123; vv = new VisitedVertex(vertex.length, index); update(index); for(int j = 1; j &lt;vertex.length; j++) &#123; index = vv.updateArr(); update(index); &#125; &#125; private void update(int index) &#123; int len = 0; for(int j = 0; j &lt; matrix[index].length; j++) &#123; len = vv.getDis(index) + matrix[index][j]; if(!vv.in(j) &amp;&amp; len &lt; vv.getDis(j)) &#123; vv.updatePre(j, index); vv.updateDis(j, len); &#125; &#125; &#125;&#125;class VisitedVertex &#123; public int[] already_arr; public int[] pre_visited; public int[] dis; public VisitedVertex(int length, int index) &#123; this.already_arr = new int[length]; this.pre_visited = new int[length]; this.dis = new int[length]; Arrays.fill(dis, 65535); this.already_arr[index] = 1; this.dis[index] = 0; &#125; public boolean in(int index) &#123; return already_arr[index] == 1; &#125; public void updateDis(int index, int len) &#123; dis[index] = len; &#125; public void updatePre(int pre, int index) &#123; pre_visited[pre] = index; &#125; public int getDis(int index) &#123; return dis[index]; &#125; public int updateArr() &#123; int min = 65535, index = 0; for(int i = 0; i &lt; already_arr.length; i++) &#123; if(already_arr[i] == 0 &amp;&amp; dis[i] &lt; min ) &#123; min = dis[i]; index = i; &#125; &#125; already_arr[index] = 1; return index; &#125; public void show() &#123; System.out.println(\"==========================\"); for(int i : already_arr) &#123; System.out.print(i + \" \"); &#125; System.out.println(); for(int i : pre_visited) &#123; System.out.print(i + \" \"); &#125; System.out.println(); for(int i : dis) &#123; System.out.print(i + \" \"); &#125; System.out.println(); char[] vertex = &#123; 'A', 'B', 'C', 'D', 'E', 'F', 'G' &#125;; int count = 0; for (int i : dis) &#123; if (i != 65535) &#123; System.out.print(vertex[count] + \"(\"+i+\") \"); &#125; else &#123; System.out.println(\"N \"); &#125; count++; &#125; System.out.println(); &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–组合","slug":"LeetCode–组合","date":"2020-09-09T05:25:56.000Z","updated":"2020-09-09T05:25:56.000Z","comments":true,"path":"2020/09/09/LeetCode–组合/","link":"","permalink":"https://tangleia.github.io/2020/09/09/LeetCode%E2%80%93%E7%BB%84%E5%90%88/","excerpt":"LeetCode–组合","text":"LeetCode–组合 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍77. 组合 题目给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例:12345678910输入: n &#x3D; 4, k &#x3D; 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 代码12345678910111213141516171819202122232425262728class Solution &#123; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; dfs(1, n, k); return ans; &#125; public void dfs(int cur, int n, int k) &#123; // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp if (temp.size() + (n - cur + 1) &lt; k) &#123; return; &#125; // 记录合法的答案 if (temp.size() == k) &#123; ans.add(new ArrayList&lt;Integer&gt;(temp)); return; &#125; // 考虑选择当前位置 temp.add(cur); dfs(cur + 1, n, k); temp.remove(temp.size() - 1); // 考虑不选择当前位置 dfs(cur + 1, n, k); &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–组合总和","slug":"LeetCode–组合总和","date":"2020-09-09T01:02:25.000Z","updated":"2020-09-09T01:02:25.000Z","comments":true,"path":"2020/09/09/LeetCode–组合总和/","link":"","permalink":"https://tangleia.github.io/2020/09/09/LeetCode%E2%80%93%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/","excerpt":"LeetCode–组合总和","text":"LeetCode–组合总和 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍39. 组合总和 题目给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明：12所有数字（包括 target）都是正整数。解集不能包含重复的组合。 示例 1：123456输入：candidates &#x3D; [2,3,6,7], target &#x3D; 7,所求解集为：[ [7], [2,2,3]] 示例 2：1234567输入：candidates &#x3D; [2,3,5], target &#x3D; 8,所求解集为：[ [2,2,2,2], [2,3,3], [3,5]] 提示：12341 &lt;&#x3D; candidates.length &lt;&#x3D; 301 &lt;&#x3D; candidates[i] &lt;&#x3D; 200candidate 中的每个元素都是独一无二的。1 &lt;&#x3D; target &lt;&#x3D; 500 思路回溯算法 + 剪枝 输入: candidates = [2, 3, 6, 7]，target = 7。 候选数组里有 2，如果找到了组合总和为 7 - 2 = 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合； 同理考虑 3，如果找到了组合总和为 7 - 3 = 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去。 代码1234567891011121314151617181920212223242526class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; int len = candidates.length; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(len == 0)&#123; return res; &#125; Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;(); dfs(candidates,0,len,target,path,res); return res; &#125; public void dfs(int[] candidates,int begin,int len,int target,Deque&lt;Integer&gt; path,List&lt;List&lt;Integer&gt;&gt; res)&#123; if(target &lt; 0)&#123; return; &#125; if(target == 0)&#123; res.add(new ArrayList&lt;&gt;(path)); &#125; for(int i = begin; i &lt; len; i++)&#123; path.addLast(candidates[i]); dfs(candidates,i,len,target-candidates[i],path,res); path.removeLast(); &#125; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（七）— 克鲁斯卡尔算法","slug":"常用十大算法（七）— 克鲁斯卡尔算法","date":"2020-09-06T11:28:49.000Z","updated":"2020-09-06T11:28:49.000Z","comments":true,"path":"2020/09/06/常用十大算法（七）— 克鲁斯卡尔算法/","link":"","permalink":"https://tangleia.github.io/2020/09/06/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%20%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/","excerpt":"常用十大算法（七）— 克鲁斯卡尔算法","text":"常用十大算法（七）— 克鲁斯卡尔算法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 最小生成树 最小生成树(Minimum Cost Spanning Tree)，简称MST。 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 N个顶点，一定有N-1条边 包含全部顶点 N-1条边都在图中 求最小生成树的算法主要是普里姆 算法和克鲁斯卡尔算法 修路问题 有北京有新增7个站点(A, B, C, D, E, F, G) ，现在需要修路把7个站点连通 各个站点的距离用边线表示(权) ，比如 A – B 距离 12公里 问：如何修路保证各个站点都能连通，并且总的修建公路总里程最短? 思路 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止 问题一排序 问题二判断回路 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package com.atguigu.kruskal;import java.util.Arrays;public class KruskalCase &#123; private int edgeNum; //边的个数 private char[] vertexs; //顶点数组 private int[][] matrix; //邻接矩阵 //表示不联通 private static final int INF = Integer.MAX_VALUE; public static void main(String[] args) &#123; char[] vertexs = &#123;'A', 'B', 'C', 'D', 'E', 'F', 'G'&#125;; int matrix[][] = &#123; /*A*//*B*//*C*//*D*//*E*//*F*//*G*/ /*A*/ &#123; 0, 12, INF, INF, INF, 16, 14&#125;, /*B*/ &#123; 12, 0, 10, INF, INF, 7, INF&#125;, /*C*/ &#123; INF, 10, 0, 3, 5, 6, INF&#125;, /*D*/ &#123; INF, INF, 3, 0, 4, INF, INF&#125;, /*E*/ &#123; INF, INF, 5, 4, 0, 2, 8&#125;, /*F*/ &#123; 16, 7, 6, INF, 2, 0, 9&#125;, /*G*/ &#123; 14, INF, INF, INF, 8, 9, 0&#125; &#125;; KruskalCase kruskalCase = new KruskalCase(vertexs, matrix); kruskalCase.print(); kruskalCase.kruskal(); &#125; //构造器 public KruskalCase(char[] vertexs, int[][] matrix) &#123; int vlen = vertexs.length; //复制拷贝 this.vertexs = new char[vlen]; for(int i = 0; i &lt; vertexs.length; i++) &#123; this.vertexs[i] = vertexs[i]; &#125; //初始化表 this.matrix = new int[vlen][vlen]; for(int i = 0; i &lt; vlen; i++) &#123; for(int j= 0; j &lt; vlen; j++) &#123; this.matrix[i][j] = matrix[i][j]; &#125; &#125; for(int i =0; i &lt; vlen; i++) &#123; for(int j = i+1; j &lt; vlen; j++) &#123; if(this.matrix[i][j] != INF) &#123; edgeNum++; &#125; &#125; &#125; &#125; //克鲁斯卡尔算法 public void kruskal() &#123; int index = 0; int[] ends = new int[edgeNum]; EData[] rets = new EData[edgeNum]; EData[] edges = getEdges(); System.out.println(\"图的边的集合=\" + Arrays.toString(edges) + \"共\"+ edges.length); //12 //排序 sortEdges(edges); //遍历数组 for(int i=0; i &lt; edgeNum; i++) &#123; int p1 = getPosition(edges[i].start); int p2 = getPosition(edges[i].end); int m = getEnd(ends, p1); int n = getEnd(ends, p2); if(m != n) &#123; ends[m] = n; rets[index++] = edges[i]; &#125; &#125; System.out.println(\"×îÐ¡Éú³ÉÊ÷Îª\"); for(int i = 0; i &lt; index; i++) &#123; System.out.println(rets[i]); &#125; &#125; public void print() &#123; System.out.println(\"邻接矩阵: \\n\"); for(int i = 0; i &lt; vertexs.length; i++) &#123; for(int j=0; j &lt; vertexs.length; j++) &#123; System.out.printf(\"%12d\", matrix[i][j]); &#125; System.out.println(); &#125; &#125; //对边排序 private void sortEdges(EData[] edges) &#123; for(int i = 0; i &lt; edges.length - 1; i++) &#123; for(int j = 0; j &lt; edges.length - 1 - i; j++) &#123; if(edges[j].weight &gt; edges[j+1].weight) &#123;//½»»» EData tmp = edges[j]; edges[j] = edges[j+1]; edges[j+1] = tmp; &#125; &#125; &#125; &#125; //顶点的值 private int getPosition(char ch) &#123; for(int i = 0; i &lt; vertexs.length; i++) &#123; if(vertexs[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; //获取图中的边 private EData[] getEdges() &#123; int index = 0; EData[] edges = new EData[edgeNum]; for(int i = 0; i &lt; vertexs.length; i++) &#123; for(int j=i+1; j &lt;vertexs.length; j++) &#123; if(matrix[i][j] != INF) &#123; edges[index++] = new EData(vertexs[i], vertexs[j], matrix[i][j]); &#125; &#125; &#125; return edges; &#125; //获取终点 private int getEnd(int[] ends, int i) &#123; ] while(ends[i] != 0) &#123; i = ends[i]; &#125; return i; &#125; &#125;//边class EData &#123; char start; //起点 char end; //终点 int weight; //权值 //构造器 public EData(char start, char end, int weight) &#123; this.start = start; this.end = end; this.weight = weight; &#125; @Override public String toString() &#123; return \"EData [&lt;\" + start + \", \" + end + \"&gt;= \" + weight + \"]\"; &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（六）— 普里姆算法","slug":"常用十大算法（六）— 普里姆算法","date":"2020-09-06T04:15:47.000Z","updated":"2020-09-06T04:15:47.000Z","comments":true,"path":"2020/09/06/常用十大算法（六）— 普里姆算法/","link":"","permalink":"https://tangleia.github.io/2020/09/06/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%20%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95/","excerpt":"常用十大算法（六）— 普里姆算法","text":"常用十大算法（六）— 普里姆算法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图 最小生成树 最小生成树(Minimum Cost Spanning Tree)，简称MST。 给定一个带权的无向连通图,如何选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树 N个顶点，一定有N-1条边 包含全部顶点 N-1条边都在图中 求最小生成树的算法主要是普里姆 算法和克鲁斯卡尔算法 修路问题 有胜利乡有7个村庄(A, B, C, D, E, F, G) ，现在需要修路把7个村庄连通 各个村庄的距离用边线表示(权) ，比如 A – B 距离 5公里 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短? 思路: 将10条边，连接即可，但是总的里程数不是最小. 正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少. 思路 设G=(V,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合 若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1 若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，标记visited[vj]=1 重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.atguigu.prim;import java.util.Arrays;public class PrimAlgorithm &#123; public static void main(String[] args) &#123; char[] data = new char[]&#123;'A','B','C','D','E','F','G'&#125;; int verxs = data.length; int [][]weight=new int[][]&#123; &#123;10000,5,7,10000,10000,10000,2&#125;, &#123;5,10000,10000,9,10000,10000,3&#125;, &#123;7,10000,10000,10000,8,10000,10000&#125;, &#123;10000,9,10000,10000,10000,4,10000&#125;, &#123;10000,10000,8,10000,10000,5,4&#125;, &#123;10000,10000,10000,4,5,10000,6&#125;, &#123;2,3,10000,10000,4,6,10000&#125;,&#125;; MGraph graph = new MGraph(verxs); MinTree minTree = new MinTree(); minTree.createGraph(graph, verxs, data, weight); minTree.showGraph(graph); minTree.prim(graph, 1); &#125;&#125;//最小生成树class MinTree &#123; //创建 public void createGraph(MGraph graph, int verxs, char data[], int[][] weight) &#123; int i, j; for(i = 0; i &lt; verxs; i++) &#123; graph.data[i] = data[i]; for(j = 0; j &lt; verxs; j++) &#123; graph.weight[i][j] = weight[i][j]; &#125; &#125; &#125; //显示 public void showGraph(MGraph graph) &#123; for(int[] link: graph.weight) &#123; System.out.println(Arrays.toString(link)); &#125; &#125; //prim算法 public void prim(MGraph graph, int v) &#123; int visited[] = new int[graph.verxs]; //标记已访问 visited[v] = 1; int h1 = -1; int h2 = -1; int minWeight = 10000; for(int k = 1; k &lt; graph.verxs; k++) &#123; for(int i = 0; i &lt; graph.verxs; i++) &#123; for(int j = 0; j&lt; graph.verxs;j++) &#123; if(visited[i] == 1 &amp;&amp; visited[j] == 0 &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123; minWeight = graph.weight[i][j]; h1 = i; h2 = j; &#125; &#125; &#125; System.out.println(\"边&lt;\" + graph.data[h1] + \",\" + graph.data[h2] + \"&gt; 权值:\" + minWeight); visited[h2] = 1; minWeight = 10000; &#125; &#125;&#125;class MGraph &#123; int verxs; char[] data; int[][] weight; public MGraph(int verxs) &#123; this.verxs = verxs; data = new char[verxs]; weight = new int[verxs][verxs]; &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–数值的整数次方","slug":"LeetCode–数值的整数次方","date":"2020-09-06T03:27:31.000Z","updated":"2020-09-06T03:27:31.000Z","comments":true,"path":"2020/09/06/LeetCode–数值的整数次方/","link":"","permalink":"https://tangleia.github.io/2020/09/06/LeetCode%E2%80%93%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","excerpt":"LeetCode–数值的整数次方","text":"LeetCode–数值的整数次方 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 16. 数值的整数次方 主站 50 题 题目实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例 1:12输入: 2.00000, 10输出: 1024.00000 示例 2:12输入: 2.10000, 3输出: 9.26100 示例 3:123输入: 2.00000, -2输出: 0.25000解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 思路 n&amp;1 （与操作）： 判断 n 二进制最右一位是否为 1 ； n&gt;&gt;1 （移位操作）： n 右移一位（可理解为删除最后一位） 流程： 当 x=0 时：直接返回 0 （避免后续 x = 1 / x 操作报错）。 初始化 res = 1 ； 当 n &lt; 0 时：把问题转化至 n≥0 的范围内，即执行 x = 1/x ，n = - n ； 循环计算：当 n = 0 时跳出； 当 n &amp; 1 = 1 时：将当前 x乘入 res （即 res *= x）； 执行 x = x^2（即 x *= x）； 执行 n右移一位（即 n&gt;&gt;=1）。 返回 res 代码12345678910111213141516171819202122class Solution &#123; public double myPow(double x, int n) &#123; if(x == 0)&#123; return 0; &#125; long b = n; double res = 1.0; //处理负数 if(b &lt; 0)&#123; x = 1/x; b = -b; &#125; while(b &gt; 0)&#123; if((b &amp; 1) == 1)&#123; res *= x; &#125; x *= x; b &gt;&gt;= 1; &#125; return res; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–二叉树的层次遍历 II","slug":"LeetCode–二叉树的层次遍历 II","date":"2020-09-06T02:48:30.000Z","updated":"2020-09-06T02:48:30.000Z","comments":true,"path":"2020/09/06/LeetCode–二叉树的层次遍历 II/","link":"","permalink":"https://tangleia.github.io/2020/09/06/LeetCode%E2%80%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%20II/","excerpt":"LeetCode–二叉树的层次遍历 II","text":"LeetCode–二叉树的层次遍历 II 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍107. 二叉树的层次遍历 II 题目给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 例如：给定二叉树 [3,9,20,null,null,15,7] 123453 &#x2F; \\9 20 &#x2F; \\ 15 7 返回其自底向上的层次遍历为： 12345[ [15,7], [9,20], [3]] 思路广度优先搜索 树的层次遍历可以使用广度优先搜索实现。从根节点开始搜索，每次遍历同一层的全部节点，使用一个列表存储该层的节点值 如果要求从上到下输出每一层的节点值，做法是很直观的，在遍历完一层节点之后，将存储该层节点值的列表添加到结果列表的尾部。这道题要求从下到上输出每一层的节点值，只要对上述操作稍作修改即可：在遍历完一层节点之后，将存储该层节点值的列表添加到结果列表的头部 代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123; //结果 List&lt;List&lt;Integer&gt;&gt; levelOrder = new LinkedList&lt;List&lt;Integer&gt;&gt;(); if(root == null)&#123; return levelOrder; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); //广度搜索 while(!queue.isEmpty())&#123; List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;(); int size = queue.size(); for(int i = 0; i &lt; size; i++)&#123; TreeNode node = queue.poll(); level.add(node.val); if(node.left != null)&#123; queue.offer(node.left); &#125; if(node.right != null)&#123; queue.offer(node.right); &#125; &#125; //每次都插入到第一个位置 levelOrder.add(0,level); &#125; return levelOrder; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（五）— 贪心算法","slug":"常用十大算法（五）— 贪心算法","date":"2020-09-05T10:08:48.000Z","updated":"2020-09-05T10:08:48.000Z","comments":true,"path":"2020/09/05/常用十大算法（五）— 贪心算法/","link":"","permalink":"https://tangleia.github.io/2020/09/05/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","excerpt":"常用十大算法（五）— 贪心算法","text":"常用十大算法（五）— 贪心算法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍贪婪算法(贪心算法)是指在对问题进行求解时，在每一步选择中都采取最好或者最优(即最有利)的选择，从而希望能够导致结果是最好或者最优的算法 贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果 集合覆盖问题假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有的地区都可以接收到信号 广播台 覆盖地区 K1 “北京”, “上海”, “天津” K2 “广州”, “北京”, “深圳” K3 “成都”, “上海”, “杭州” K4 “上海”, “天津” K5 “杭州”, “大连” 思路 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台(此电台可能包含一些已覆盖的地区，但没有关系） 将这个电台加入到一个集合中(比如ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。 重复第1步直到覆盖了全部的地区 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.atguigu.greedy;import java.util.ArrayList;import java.util.HashMap;import java.util.HashSet;public class GreedyAlgorithm &#123; public static void main(String[] args) &#123; HashMap&lt;String,HashSet&lt;String&gt;&gt; broadcasts = new HashMap&lt;String, HashSet&lt;String&gt;&gt;(); HashSet&lt;String&gt; hashSet1 = new HashSet&lt;String&gt;(); hashSet1.add(\"北京\"); hashSet1.add(\"上海\"); hashSet1.add(\"天津\"); HashSet&lt;String&gt; hashSet2 = new HashSet&lt;String&gt;(); hashSet2.add(\"广州\"); hashSet2.add(\"北京\"); hashSet2.add(\"深圳\"); HashSet&lt;String&gt; hashSet3 = new HashSet&lt;String&gt;(); hashSet3.add(\"成都\"); hashSet3.add(\"上海\"); hashSet3.add(\"杭州\"); HashSet&lt;String&gt; hashSet4 = new HashSet&lt;String&gt;(); hashSet4.add(\"上海\"); hashSet4.add(\"天津\"); HashSet&lt;String&gt; hashSet5 = new HashSet&lt;String&gt;(); hashSet5.add(\"杭州\"); hashSet5.add(\"大连\"); broadcasts.put(\"K1\", hashSet1); broadcasts.put(\"K2\", hashSet2); broadcasts.put(\"K3\", hashSet3); broadcasts.put(\"K4\", hashSet4); broadcasts.put(\"K5\", hashSet5); //所有地区 HashSet&lt;String&gt; allAreas = new HashSet&lt;String&gt;(); allAreas.add(\"北京\"); allAreas.add(\"上海\"); allAreas.add(\"天津\"); allAreas.add(\"天津\"); allAreas.add(\"深圳\"); allAreas.add(\"成都\"); allAreas.add(\"杭州\"); allAreas.add(\"大连\"); //电台集合 ArrayList&lt;String&gt; selects = new ArrayList&lt;String&gt;(); //临时集合 HashSet&lt;String&gt; tempSet = new HashSet&lt;String&gt;(); String maxKey = null; while(allAreas.size() != 0) &#123; maxKey = null; for(String key : broadcasts.keySet()) &#123; tempSet.clear(); HashSet&lt;String&gt; areas = broadcasts.get(key); tempSet.addAll(areas); tempSet.retainAll(allAreas); if(tempSet.size() &gt; 0 &amp;&amp; (maxKey == null || tempSet.size() &gt;broadcasts.get(maxKey).size()))&#123; maxKey = key; &#125; &#125; if(maxKey != null) &#123; selects.add(maxKey); allAreas.removeAll(broadcasts.get(maxKey)); &#125; &#125; System.out.println(\"贪心算法得到集合：\" + selects); &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–二进制中1的个数","slug":"LeetCode–二进制中1的个数","date":"2020-09-05T08:59:23.000Z","updated":"2020-09-05T08:59:23.000Z","comments":true,"path":"2020/09/05/LeetCode–二进制中1的个数/","link":"","permalink":"https://tangleia.github.io/2020/09/05/LeetCode%E2%80%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"LeetCode–二进制中1的个数","text":"LeetCode–二进制中1的个数 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 15. 二进制中1的个数 主站 191 题目请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1：123输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。 示例 2：123输入：00000000000000000000000010000000输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。 示例 3：123输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。 思路作者：jyd 逐位判断 根据 与运算 定义，设二进制数字 nn ，则有： 若 n &amp; 1 = 0n&amp;1=0 ，则 nn 二进制 最右一位 为 00 ； 若 n &amp; 1 = 1n&amp;1=1 ，则 nn 二进制 最右一位 为 11 。 根据以上特点，考虑以下 循环判断 ： 判断 nn 最右一位是否为 11 ，根据结果计数。 将 nn 右移一位（本题要求把数字 nn 看作无符号数，因此使用 无符号右移 操作） 步骤 初始化数量统计变量 res =0 。 循环逐位判断： 当 n =0 时跳出。 res += n &amp; 1 ： 若 n &amp; 1 = 1n&amp;1=1 ，则统计数 resres 加一。 n &gt;&gt;= 1 ： 将二进制数字 nn 无符号右移一位（ Java 中无符号右移为 “&gt;&gt;&gt;” ） 。 返回统计数量 res 皮一下123456public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; return Integer.bitCount(n); &#125;&#125; 代码1234567891011public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int res = 0; while(n != 0)&#123; res += n &amp;1; n &gt;&gt;&gt;= 1; &#125; return res; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–第k个排列","slug":"LeetCode–第k个排列","date":"2020-09-05T08:33:27.000Z","updated":"2020-09-05T08:33:27.000Z","comments":true,"path":"2020/09/05/LeetCode–第k个排列/","link":"","permalink":"https://tangleia.github.io/2020/09/05/LeetCode%E2%80%93%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97/","excerpt":"LeetCode–第k个排列","text":"LeetCode–第k个排列 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍60. 第k个排列 题目给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： 123456&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot; 给定 n 和 k，返回第 k 个排列。 说明：12给定 n 的范围是 [1, 9]。给定 k 的范围是[1, n!]。 示例 1:12输入: n &#x3D; 3, k &#x3D; 3输出: &quot;213&quot; 示例 2:12输入: n &#x3D; 4, k &#x3D; 9输出: &quot;2314&quot; 思路深度优先搜索（DFS）+ 剪枝 深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。 剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。 步骤如果 kk 大于这一个分支将要产生的叶子结点数，直接跳过这个分支，这个操作叫「剪枝」 如果 kk 小于等于这一个分支将要产生的叶子结点数，那说明所求的全排列一定在这一个分支将要产生的叶子结点里，需要递归求解 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public String getPermutation(int n, int k) &#123; //初始化阶乘数组 int[] factorial = new int[n+1]; calculateFactorial(factorial,n); //查找全排列的布尔数组 boolean[] temp = new boolean[n+1]; Arrays.fill(temp,false); //动态字符串 StringBuilder path = new StringBuilder(); dfs(temp,factorial,0,path,k,n); return path.toString(); &#125; private void dfs(boolean[] temp,int factorial[],int index,StringBuilder path,int k,int n)&#123; if(index == n)&#123; return; &#125; //全排列个数 int cnt = factorial[n-1-index]; for(int i = 1; i &lt;= n; i++)&#123; if(temp[i])&#123; continue; &#125; //当时全排列个数 if(cnt &lt; k)&#123; k -= cnt; continue; &#125; path.append(i); temp[i] = true; dfs(temp,factorial,index+1,path,k,n); return; &#125; &#125; //计算阶乘数组 private void calculateFactorial(int[] factorial, int n)&#123; factorial[0] = 1; for(int i = 1; i &lt;= n; i++)&#123; factorial[i] = factorial[i-1]*i; &#125; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"uni-app出现SassError Undefined variable","slug":"uni-app出现SassError Undefined variable","date":"2020-09-05T08:27:06.000Z","updated":"2020-09-05T08:27:06.000Z","comments":true,"path":"2020/09/05/uni-app出现SassError Undefined variable/","link":"","permalink":"https://tangleia.github.io/2020/09/05/uni-app%E5%87%BA%E7%8E%B0SassError%20Undefined%20variable/","excerpt":"uni-app出现SassError: Undefined variable","text":"uni-app出现SassError: Undefined variable 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题截图 问题说明在引入全局样式的时候Sass加载不到 问题解决在项目中打开 12npm initnpm install sass-resources-loader --save-dev 感谢 uni-app 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（四）— KMP算法","slug":"常用十大算法（四）— KMP算法","date":"2020-09-04T09:52:26.000Z","updated":"2020-09-04T09:52:26.000Z","comments":true,"path":"2020/09/04/常用十大算法（四）— KMP算法/","link":"","permalink":"https://tangleia.github.io/2020/09/04/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%20KMP%E7%AE%97%E6%B3%95/","excerpt":"常用十大算法（四）— KMP算法","text":"常用十大算法（四）— KMP算法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍KMP是一个解决模式串在文本串是否出现过，如果出现过，最早出现的位置的经典算法 Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法. KMP方法算法就利用之前判断过信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过next数组找到，前面匹配过的位置，省去了大量的计算时间 字符串匹配问题 有一个字符串 str1= “BBC ABCDAB ABCDABCDABDE”，和一个子串 str2=”ABCDABD” 现在要判断 str1 是否含有 str2, 如果存在，就返回第一次出现的位置, 如果没有，则返回-1 要求：使用KMP算法完成判断，不能使用简单的暴力匹配算法 暴力匹配算法如果当前字符匹配成功（即str1[i] == str2[j]），则i++，j++，继续匹配下一个字符 如果失配（即str1[i]! = str2[j]），令i = i - (j - 1)，j = 0。相当于每次匹配失败时，i 回溯，j 被置为0。 代码实现12345678910111213141516171819202122232425262728293031323334353637package com.guizimo;public class ViolenceMatch &#123; public static void main(String[] args) &#123; String str1 = \"BBC ABCDAB ABCDABCDABDE\"; String str2 = \"ABCDABD\"; int index = violenceMatch(str1, str2); System.out.println(\"index=\" + index); &#125; public static int violenceMatch(String str1, String str2) &#123; char[] s1 = str1.toCharArray(); char[] s2 = str2.toCharArray(); int s1Len = s1.length; int s2Len = s2.length; int i = 0; int j = 0; while (i &lt; s1Len &amp;&amp; j &lt; s2Len) &#123; if(s1[i] == s2[j]) &#123; i++; j++; &#125; else &#123; i = i - (j - 1); j = 0; &#125; &#125; if(j == s2Len) &#123; return i - j; &#125; else &#123; return -1; &#125; &#125;&#125; KMP算法 得到子串的部分匹配表 使用部分匹配表完成KMP匹配 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.guizimo;import java.util.Arrays;public class KMPAlgorithm &#123; public static void main(String[] args) &#123; String str1 = \"BBC ABCDAB ABCDABCDABDE\"; String str2 = \"ABCDABD\"; int[] next = kmpNext(\"ABCDABD\"); System.out.println(\"next=\" + Arrays.toString(next)); int index = kmpSearch(str1, str2, next); System.out.println(\"index=\" + index); &#125; //KMP搜索 public static int kmpSearch(String str1, String str2, int[] next) &#123; for(int i = 0, j = 0; i &lt; str1.length(); i++) &#123; while( j &gt; 0 &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123; j = next[j-1]; &#125; if(str1.charAt(i) == str2.charAt(j)) &#123; j++; &#125; if(j == str2.length()) &#123; return i - j + 1; &#125; &#125; return -1; &#125; //获取部分匹配表 public static int[] kmpNext(String dest) &#123; int[] next = new int[dest.length()]; next[0] = 0; for(int i = 1, j = 0; i &lt; dest.length(); i++) &#123; while(j &gt; 0 &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123; j = next[j-1]; &#125; if(dest.charAt(i) == dest.charAt(j)) &#123; j++; &#125; next[i] = j; &#125; return next; &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（三）— 动态规划算法","slug":"常用十大算法（三）— 动态规划算法","date":"2020-09-04T09:15:13.000Z","updated":"2020-09-04T09:15:13.000Z","comments":true,"path":"2020/09/04/常用十大算法（三）— 动态规划算法/","link":"","permalink":"https://tangleia.github.io/2020/09/04/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/","excerpt":"常用十大算法（三）— 动态规划算法","text":"常用十大算法（三）— 动态规划算法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 ) 动态规划可以通过填表的方式来逐步推进，得到最优解 背包问题 思路背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用) 这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。 算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设v[i]、w[i]分别为第i个物品的价值和重量，C为背包的容量。再令v[i][j]表示在前i个物品中能够装入容量为j的背包中的最大价值。 123456(1) v[i][0]&#x3D;v[0][j]&#x3D;0; &#x2F;&#x2F;表示 填入表 第一行和第一列是0(2) 当w[i]&gt; j 时：v[i][j]&#x3D;v[i-1][j] &#x2F;&#x2F; 当准备加入新增的商品的容量大于 当前背包的容量时，就直接使用上一个单元格的装入策略(3) 当j&gt;&#x3D;w[i]时： v[i][j]&#x3D;max&#123;v[i-1][j], v[i]+v[i-1][j-w[i]]&#125; &#x2F;&#x2F; 当 准备加入的新增的商品的容量小于等于当前背包的容量, 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.guizimo;public class KnapsackProblem &#123; public static void main(String[] args) &#123; int[] w = &#123;1, 4, 3&#125;;//物品的重量 int[] val = &#123;1500, 3000, 2000&#125;; //物品的价格 int m = 4; //总重量 int n = val.length; //价格的种类 //创建二维数组 //v[i][j] 表示在的i个物品中能够装入容量为j的背包中的最大价值 int[][] v = new int[n+1][m+1]; //辅助二维数组 int[][] path = new int[n+1][m+1]; //初始化第一行和第一列 for(int i = 0; i &lt; v.length; i++) &#123; v[i][0] = 0; &#125; for(int i=0; i &lt; v[0].length; i++) &#123; v[0][i] = 0; &#125; for(int i = 1; i &lt; v.length; i++) &#123; for(int j = 1; j &lt; v[0].length; j++) &#123; if(w[i-1] &gt; j) &#123; v[i][j] = v[i-1][j]; &#125; else &#123; if(v[i - 1][j] &lt; val[i - 1] + v[i - 1][j - w[i - 1]]) &#123; v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]]; path[i][j] = 1; &#125; else &#123; v[i][j] = v[i - 1][j]; &#125; &#125; &#125; &#125; //价格表 for(int i =0; i &lt; v.length;i++) &#123; for(int j = 0; j &lt; v[i].length;j++) &#123; System.out.print(v[i][j] + \" \"); &#125; System.out.println(); &#125; System.out.println(\"============================\"); int i = path.length - 1; int j = path[0].length - 1; while(i &gt; 0 &amp;&amp; j &gt; 0 ) &#123; if(path[i][j] == 1) &#123; System.out.printf(\"第%d个商品放入背包\\n\", i); j -= w[i-1]; &#125; i--; &#125; &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（二）— 分治算法","slug":"常用十大算法（二）— 分治算法","date":"2020-09-04T08:33:31.000Z","updated":"2020-09-04T08:33:31.000Z","comments":true,"path":"2020/09/04/常用十大算法（二）— 分治算法/","link":"","permalink":"https://tangleia.github.io/2020/09/04/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%20%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","excerpt":"常用十大算法（二）— 分治算法","text":"常用十大算法（二）— 分治算法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换) 分治算法实践 二分搜索 大整数乘法 棋盘覆盖 合并排序 快速排序 线性时间选择 最接近点对问题 循环赛日程表 汉诺塔 分治算法的步骤分治法在每一层递归上都有三个步骤： 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题 合并：将各个子问题的解合并为原问题的解。 分治(Divide-and-Conquer(P))算法设计模式1234567if |P|≤n0 then return(ADHOC(P)) &#x2F;&#x2F;将P分解为较小的子问题 P1 ,P2 ,…,Pkfor i←1 to kdo yi ← Divide-and-Conquer(Pi) 递归解决PiT ← MERGE(y1,y2,…,yk) 合并子问题return(T) 其中|P|表示问题P的规模； n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。 ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。 算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。 汉诺塔代码实现12345678910111213141516171819202122package com.guizimo;public class Hanoitower &#123; public static void main(String[] args) &#123; hanoiTower(10, 'A', 'B', 'C'); &#125; public static void hanoiTower(int num, char a, char b, char c) &#123; //只有一个盘 if(num == 1) &#123; System.out.println(\"第1个盘从\" + a + \"-&gt;\" + c); &#125; else &#123; //1. 把上面的A-&gt;B hanoiTower(num - 1, a, c, b); //2. 把下面的A-&gt;C System.out.println(\"第\" + num + \"个盘从\" + a + \"-&gt;\" + c); //3. 把B-&gt;C hanoiTower(num - 1, b, a, c); &#125; &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"常用十大算法（一）—二分查找（非递归）","slug":"常用十大算法（一）—二分查找（非递归）","date":"2020-09-04T08:00:58.000Z","updated":"2020-09-04T08:00:58.000Z","comments":true,"path":"2020/09/04/常用十大算法（一）—二分查找（非递归）/","link":"","permalink":"https://tangleia.github.io/2020/09/04/%E5%B8%B8%E7%94%A8%E5%8D%81%E5%A4%A7%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89/","excerpt":"常用十大算法（一）—二分查找（非递归）","text":"常用十大算法（一）—二分查找（非递归） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍二分查找法只适用于从有序的数列中进行查找(比如数字和字母等)，将数列排序后再进行查找 二分查找法的运行时间为对数时间O(㏒₂n) ，即查找到需要的目标位置最多只需要㏒₂n步，假设从[0,99]的队列(100个数，即n=100)中寻到目标数30，则需要查找步数为㏒₂100 , 即最多需要查找7次( 2^6 &lt; 100 &lt; 2^7) 代码123456789101112131415161718192021222324252627package com.guizimo;public class BinarySearchNoRecur &#123; public static void main(String[] args) &#123; int[] arr = &#123;1,3, 8, 10, 11, 67, 100&#125;; int index = binarySearch(arr, 100); System.out.println(\"index=\" + index); &#125; public static int binarySearch(int[] arr, int target) &#123; int left = 0; int right = arr.length - 1; while(left &lt;= right) &#123; int mid = (left + right) / 2; if(arr[mid] == target) &#123; return mid; &#125; else if ( arr[mid] &gt; target) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return -1; &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–剪绳子","slug":"LeetCode–剪绳子","date":"2020-09-04T07:49:55.000Z","updated":"2020-09-04T07:49:55.000Z","comments":true,"path":"2020/09/04/LeetCode–剪绳子/","link":"","permalink":"https://tangleia.github.io/2020/09/04/LeetCode%E2%80%93%E5%89%AA%E7%BB%B3%E5%AD%90/","excerpt":"LeetCode–剪绳子","text":"LeetCode–剪绳子 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 14- I. 剪绳子 主站 343 题目给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1：123输入: 2输出: 1解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1 示例 2:123输入: 10输出: 36解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36 提示：12 &lt;&#x3D; n &lt;&#x3D; 58 思路 代码123456789101112131415class Solution &#123; public int cuttingRope(int n) &#123; if(n &lt;= 3)&#123; return n-1; &#125; int a = n/3, b = n%3; if(b == 0)&#123; return (int)Math.pow(3,a); &#125;else if(b == 1)&#123; return (int)Math.pow(3,a-1)*4; &#125;else&#123; return (int)Math.pow(3,a)*2; &#125; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–二叉树的所有路径","slug":"LeetCode–二叉树的所有路径","date":"2020-09-04T07:46:19.000Z","updated":"2020-09-04T07:46:19.000Z","comments":true,"path":"2020/09/04/LeetCode–二叉树的所有路径/","link":"","permalink":"https://tangleia.github.io/2020/09/04/LeetCode%E2%80%93%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/","excerpt":"LeetCode–二叉树的所有路径","text":"LeetCode–二叉树的所有路径 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍257. 二叉树的所有路径 题目给定一个二叉树，返回所有从根节点到叶子节点的路径。 说明: 叶子节点是指没有子节点的节点。 示例:1234567891011输入: 1 &#x2F; \\2 3 \\ 5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3 思路深度优先遍历 DFS 代码123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; paths = new ArrayList&lt;String&gt;(); dfs(root,\"\",paths); return paths; &#125; public void dfs(TreeNode root,String path,List&lt;String&gt; paths)&#123; if(root != null)&#123; StringBuffer pathSB = new StringBuffer(path); pathSB.append(Integer.toString(root.val)); if(root.left == null &amp;&amp; root.right == null)&#123; paths.add(pathSB.toString()); &#125;else&#123; pathSB.append(\"-&gt;\"); dfs(root.left,pathSB.toString(),paths); dfs(root.right,pathSB.toString(),paths); &#125; &#125; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"数据结构–图（深度优先遍历和广度优先遍历）（Java）","slug":"数据结构–图（深度优先遍历和广度优先遍历）（Java）","date":"2020-09-04T05:28:03.000Z","updated":"2020-09-04T05:28:03.000Z","comments":true,"path":"2020/09/04/数据结构–图（深度优先遍历和广度优先遍历）（Java）/","link":"","permalink":"https://tangleia.github.io/2020/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%93%E5%9B%BE%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%89%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构–图（深度优先遍历和广度优先遍历）（Java）","text":"数据结构–图（深度优先遍历和广度优先遍历）（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 图的常用概念图是一种数据结构，其中结点可以具有零个或多个相邻元素。两个结点之间的连接称为边。 结点也可以称为顶点。 顶点(vertex) 边(edge) 路径 无向图 有向图 带权图 图的表示方式图的表示方式有两种：二维数组表示（邻接矩阵）；链表表示（邻接表）。 邻接矩阵邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是的row和col表示的是1….n个点。 邻接表邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在,会造成空间的一定损失 邻接表的实现只关心存在的边，不关心不存在的边。因此没有空间浪费，邻接表由数组+链表组成 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package com.guizimo;import java.util.ArrayList;import java.util.Arrays;import java.util.LinkedList;public class Graph &#123; private ArrayList&lt;String&gt; vertexList; private int[][] edges; private int numOfEdges; private boolean[] isVisited; public static void main(String[] args) &#123; int n = 8; String Vertexs[] = &#123;\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\"&#125;; Graph graph = new Graph(n); for(String vertex: Vertexs) &#123; graph.insertVertex(vertex); &#125; //插入图的节点 graph.insertEdge(0, 1, 1); graph.insertEdge(0, 2, 1); graph.insertEdge(1, 3, 1); graph.insertEdge(1, 4, 1); graph.insertEdge(3, 7, 1); graph.insertEdge(4, 7, 1); graph.insertEdge(2, 5, 1); graph.insertEdge(2, 6, 1); graph.insertEdge(5, 6, 1); //遍历图 graph.showGraph(); System.out.println(\"广度优先遍历 graph.dfs(); System.out.println(\"深度优先遍历 graph.bfs(); &#125; public Graph(int n) &#123; edges = new int[n][n]; vertexList = new ArrayList&lt;String&gt;(n); numOfEdges = 0; &#125; public int getFirstNeighbor(int index) &#123; for(int j = 0; j &lt; vertexList.size(); j++) &#123; if(edges[index][j] &gt; 0) &#123; return j; &#125; &#125; return -1; &#125; public int getNextNeighbor(int v1, int v2) &#123; for(int j = v2 + 1; j &lt; vertexList.size(); j++) &#123; if(edges[v1][j] &gt; 0) &#123; return j; &#125; &#125; return -1; &#125; //深度优先遍历 private void dfs(boolean[] isVisited, int i) &#123; System.out.print(getValueByIndex(i) + \"-&gt;\"); isVisited[i] = true; int w = getFirstNeighbor(i); while(w != -1) &#123; if(!isVisited[w]) &#123; dfs(isVisited, w); &#125; w = getNextNeighbor(i, w); &#125; &#125; public void dfs() &#123; isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) &#123; if(!isVisited[i]) &#123; dfs(isVisited, i); &#125; &#125; &#125; //广度优先遍历 private void bfs(boolean[] isVisited, int i) &#123; int u ; int w ; LinkedList queue = new LinkedList(); System.out.print(getValueByIndex(i) + \"=&gt;\"); isVisited[i] = true; queue.addLast(i); while( !queue.isEmpty()) &#123; u = (Integer)queue.removeFirst(); w = getFirstNeighbor(u); while(w != -1) &#123; if(!isVisited[w]) &#123; System.out.print(getValueByIndex(w) + \"=&gt;\"); isVisited[w] = true; queue.addLast(w); &#125; w = getNextNeighbor(u, w); &#125; &#125; &#125; public void bfs() &#123; isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) &#123; if(!isVisited[i]) &#123; bfs(isVisited, i); &#125; &#125; &#125; public int getNumOfVertex() &#123; return vertexList.size(); &#125; //遍历 public void showGraph() &#123; for(int[] link : edges) &#123; System.err.println(Arrays.toString(link)); &#125; &#125; public int getNumOfEdges() &#123; return numOfEdges; &#125; public String getValueByIndex(int i) &#123; return vertexList.get(i); &#125; public int getWeight(int v1, int v2) &#123; return edges[v1][v2]; &#125; //添加邻接矩阵 public void insertVertex(String vertex) &#123; vertexList.add(vertex); &#125; //插入权值 public void insertEdge(int v1, int v2, int weight) &#123; edges[v1][v2] = weight; edges[v2][v1] = weight; numOfEdges++; &#125;&#125; 图的深度优先搜索(Depth First Search)深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点， 可以这样理解：每次都在访问完当前结点后首先访问当前结点的第一个邻接结点 算法 访问初始结点v，并标记结点v为已访问。 查找结点v的第一个邻接结点w。 若w存在，则继续执行4，如果w不存在，则回到第1步，将从v的下一个结点继续。 若w未被访问，对w进行深度优先遍历递归（即把w当做另一个v，然后进行步骤123）。 查找结点v的w邻接结点的下一个邻接结点，转到步骤3 代码12345678910111213141516171819202122//深度优先遍历private void dfs(boolean[] isVisited, int i) &#123; System.out.print(getValueByIndex(i) + \"-&gt;\"); isVisited[i] = true; int w = getFirstNeighbor(i); while(w != -1) &#123; if(!isVisited[w]) &#123; dfs(isVisited, w); &#125; w = getNextNeighbor(i, w); &#125;&#125;public void dfs() &#123; isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) &#123; if(!isVisited[i]) &#123; dfs(isVisited, i); &#125; &#125;&#125; 图的广度优先搜索(Broad First Search)类似于一个分层搜索的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来访问这些结点的邻接结点 算法 访问初始结点v并标记结点v为已访问。 结点v入队列 当队列非空时，继续执行，否则算法结束。 出队列，取得队头结点u。 查找结点u的第一个邻接结点w。 若结点u的邻接结点w不存在，则转到步骤3；否则循环执行以下三个步骤： 若结点w尚未被访问，则访问结点w并标记为已访问。 结点w入队列 查找结点u的继w邻接结点后的下一个邻接结点w，转到步骤6 代码1234567891011121314151617181920212223242526272829303132//广度优先遍历private void bfs(boolean[] isVisited, int i) &#123; int u ; int w ; LinkedList queue = new LinkedList(); System.out.print(getValueByIndex(i) + \"=&gt;\"); isVisited[i] = true; queue.addLast(i); while( !queue.isEmpty()) &#123; u = (Integer)queue.removeFirst(); w = getFirstNeighbor(u); while(w != -1) &#123; if(!isVisited[w]) &#123; System.out.print(getValueByIndex(w) + \"=&gt;\"); isVisited[w] = true; queue.addLast(w); &#125; w = getNextNeighbor(u, w); &#125; &#125;&#125; public void bfs() &#123; isVisited = new boolean[vertexList.size()]; for(int i = 0; i &lt; getNumOfVertex(); i++) &#123; if(!isVisited[i]) &#123; bfs(isVisited, i); &#125; &#125;&#125; 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–机器人的运动范围","slug":"LeetCode–机器人的运动范围","date":"2020-09-03T06:27:21.000Z","updated":"2020-09-03T06:27:21.000Z","comments":true,"path":"2020/09/03/LeetCode–机器人的运动范围/","link":"","permalink":"https://tangleia.github.io/2020/09/03/LeetCode%E2%80%93%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","excerpt":"LeetCode–机器人的运动范围","text":"LeetCode–机器人的运动范围 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 13. 机器人的运动范围 题目地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1：12输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1输出：3 示例 2：12输入：m &#x3D; 3, n &#x3D; 1, k &#x3D; 0输出：1 提示：121 &lt;&#x3D; n,m &lt;&#x3D; 1000 &lt;&#x3D; k &lt;&#x3D; 20 思路作者：jyd 深度优先遍历 DFS 深度优先搜索： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。 剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 算法递归参数： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。 终止条件： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 00 ，代表不计入可达解。 递推工作： 标记当前单元格 ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。 搜索下一单元格： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。 回溯返回值： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数。 代码12345678910111213class Solution &#123; public int movingCount(int m, int n, int k) &#123; boolean[][] visited = new boolean[m][n]; return dfs(0,0,0,0,m,n,k,visited); &#125; public int dfs(int i,int j,int si,int sj,int m, int n, int k,boolean[][] visited)&#123; if(i &gt;= m || j &gt;= n || k &lt; si + sj || visited[i][j])&#123; return 0; &#125; visited[i][j] = true; return 1 + dfs(i + 1,j,(i+1)%10 != 0 ? si + 1 : si - 8,sj,m,n,k,visited) + dfs(i,j+1,si,(j+1)%10 != 0 ? sj + 1 : sj - 8,m,n,k,visited); &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–N 皇后","slug":"LeetCode–N 皇后","date":"2020-09-03T05:50:51.000Z","updated":"2020-09-03T05:50:51.000Z","comments":true,"path":"2020/09/03/LeetCode–N 皇后/","link":"","permalink":"https://tangleia.github.io/2020/09/03/LeetCode%E2%80%93N%20%E7%9A%87%E5%90%8E/","excerpt":"LeetCode–N 皇后","text":"LeetCode–N 皇后 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍51. N 皇后 题目n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例：12345678910111213输入：4输出：[ [&quot;.Q..&quot;, &#x2F;&#x2F; 解法 1 &quot;...Q&quot;, &quot;Q...&quot;, &quot;..Q.&quot;], [&quot;..Q.&quot;, &#x2F;&#x2F; 解法 2 &quot;Q...&quot;, &quot;...Q&quot;, &quot;.Q..&quot;]]解释: 4 皇后问题存在两个不同的解法。 提示：皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。 思路使用回溯法 使用一个数组记录每行放置的皇后的列下标，依次在每一行放置一个皇后。每次新放置的皇后都不能和已经放置的皇后之间有攻击：即新放置的皇后不能和任何一个已经放置的皇后在同一列以及同一条斜线上，并更新数组中的当前行的皇后列下标。当 NN 个皇后都放置完毕，则找到一个可能的解。当找到一个可能的解之后，将数组转换成表示棋盘状态的列表，并将该棋盘状态的列表加入返回列表 代码12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; int[] queens = new int[n]; Arrays.fill(queens, -1); List&lt;List&lt;String&gt;&gt; solutions = new ArrayList&lt;List&lt;String&gt;&gt;(); solve(solutions, queens, n, 0, 0, 0, 0); return solutions; &#125; public void solve(List&lt;List&lt;String&gt;&gt; solutions, int[] queens, int n, int row, int columns, int diagonals1, int diagonals2) &#123; if (row == n) &#123; List&lt;String&gt; board = generateBoard(queens, n); solutions.add(board); &#125; else &#123; int availablePositions = ((1 &lt;&lt; n) - 1) &amp; (~(columns | diagonals1 | diagonals2)); while (availablePositions != 0) &#123; int position = availablePositions &amp; (-availablePositions); availablePositions = availablePositions &amp; (availablePositions - 1); int column = Integer.bitCount(position - 1); queens[row] = column; solve(solutions, queens, n, row + 1, columns | position, (diagonals1 | position) &lt;&lt; 1, (diagonals2 | position) &gt;&gt; 1); queens[row] = -1; &#125; &#125; &#125; public List&lt;String&gt; generateBoard(int[] queens, int n) &#123; List&lt;String&gt; board = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; n; i++) &#123; char[] row = new char[n]; Arrays.fill(row, '.'); row[queens[i]] = 'Q'; board.add(new String(row)); &#125; return board; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–矩阵中的路径","slug":"LeetCode–矩阵中的路径","date":"2020-09-02T03:57:29.000Z","updated":"2020-09-02T03:58:12.000Z","comments":true,"path":"2020/09/02/LeetCode–矩阵中的路径/","link":"","permalink":"https://tangleia.github.io/2020/09/02/LeetCode%E2%80%93%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","excerpt":"LeetCode–矩阵中的路径","text":"LeetCode–矩阵中的路径 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 12. 矩阵中的路径 主站 79 题目请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[“a”,”b”,”c”,”e”],[“s”,”f”,”c”,”s”],[“a”,”d”,”e”,”e”]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例 1：12输入：board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;输出：true 示例 2：12输入：board &#x3D; [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word &#x3D; &quot;abcd&quot;输出：false 提示：121 &lt;&#x3D; board.length &lt;&#x3D; 2001 &lt;&#x3D; board[i].length &lt;&#x3D; 200 思路作者：jyd 深度优先搜索（DFS）+ 剪枝 深度优先搜索： 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。 剪枝： 在搜索中，遇到 这条路不可能和目标字符串匹配成功 的情况（例如：此矩阵元素和目标字符不同、此元素已被访问），则应立即返回，称之为 可行性剪枝 。 步骤递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。 终止条件： 返回 falsefalse ： ① 行或列索引越界 或 ② 当前矩阵元素与目标字符不同 或 ③ 当前矩阵元素已访问过 （③ 可合并至 ② ） 。 返回 truetrue ： 字符串 word 已全部匹配，即 k = len(word) - 1 。 递推工作： 标记当前矩阵元素： 将 board[i][j] 值暂存于变量 tmp ，并修改为字符 ‘/‘ ，代表此元素已访问过，防止之后搜索时重复访问。 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需一条可行路径） ，并记录结果至 res 。 还原当前矩阵元素： 将 tmp 暂存值还原至 board[i][j] 元素。 回溯返回值： 返回 res ，代表是否搜索到目标字符串。 代码123456789101112131415161718192021222324252627class Solution &#123; public boolean exist(char[][] board, String word) &#123; char[] words = word.toCharArray(); for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(dfs(board,words,i,j,0))&#123; return true; &#125; &#125; &#125; return false; &#125; boolean dfs(char[][] board, char[] word, int i, int j, int k)&#123; if(i &gt;= board.length || i &lt; 0 || j &gt;= board[0].length || j &lt; 0 || board[i][j] != word[k])&#123; return false; &#125; if(k == word.length - 1)&#123; return true; &#125; char tmp = board[i][j]; board[i][j] = '/'; boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1); board[i][j] = tmp; return res; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–表示数值的字符串","slug":"LeetCode–表示数值的字符串","date":"2020-09-02T03:51:01.000Z","updated":"2020-09-02T03:51:01.000Z","comments":true,"path":"2020/09/02/LeetCode–表示数值的字符串/","link":"","permalink":"https://tangleia.github.io/2020/09/02/LeetCode%E2%80%93%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"LeetCode–表示数值的字符串","text":"LeetCode–表示数值的字符串 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 20. 表示数值的字符串 题目请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”、”5e2”、”-123”、”3.1416”、”-1E-16”、”0123”都表示数值，但”12e”、”1a3.14”、”1.2.3”、”+-5”及”12e+5.4”都不是。 思路思路来自jyd 使用有限状态自动机 根据字符类型和合法数值的特点，先定义状态，再画出状态转移图，最后编写代码即可。 字符类型： 空格 「 」、数字「 0—90—9 」 、正负号 「 +-+− 」 、小数点 「 .. 」 、幂符号 「 eEeE 」 。 状态定义： 按照字符串从左到右的顺序，定义以下 9 种状态。 开始的空格 幂符号前的正负号 小数点前的数字 小数点、小数点后的数字 当小数点前为空格时，小数点、小数点后的数字 幂符号 幂符号后的正负号 幂符号后的数字 结尾的空格 结束状态： 合法的结束状态有 2, 3, 7, 8 。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean isNumber(String s) &#123; //状态转移表 Map[] states = &#123; new HashMap&lt;&gt;() &#123;&#123; put(' ', 0); put('s', 1); put('d', 2); put('.', 4); &#125;&#125;, // 0. new HashMap&lt;&gt;() &#123;&#123; put('d', 2); put('.', 4); &#125;&#125;, // 1. new HashMap&lt;&gt;() &#123;&#123; put('d', 2); put('.', 3); put('e', 5); put(' ', 8); &#125;&#125;, // 2. new HashMap&lt;&gt;() &#123;&#123; put('d', 3); put('e', 5); put(' ', 8); &#125;&#125;, // 3. new HashMap&lt;&gt;() &#123;&#123; put('d', 3); &#125;&#125;, // 4. new HashMap&lt;&gt;() &#123;&#123; put('s', 6); put('d', 7); &#125;&#125;, // 5. new HashMap&lt;&gt;() &#123;&#123; put('d', 7); &#125;&#125;, // 6. new HashMap&lt;&gt;() &#123;&#123; put('d', 7); put(' ', 8); &#125;&#125;, // 7. new HashMap&lt;&gt;() &#123;&#123; put(' ', 8); &#125;&#125; // 8. &#125;; int p = 0; char t; for(char c : s.toCharArray())&#123; if(c &gt;= '0' &amp;&amp; c &lt;= '9')&#123; t = 'd'; &#125;else if(c == '+' || c == '-')&#123; t = 's'; &#125;else if(c == 'e' || c == 'E')&#123; t = 'e'; &#125;else if(c == '.' || c == ' ')&#123; t = c; &#125;else&#123; t = '?'; &#125; if(!states[p].containsKey(t))&#123; return false; &#125; p = (int)states[p].get(t); &#125; return p == 2 || p == 3 || p == 7 || p == 8; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"数据结构—B树、B+树、B树","slug":"数据结构—B树、B+树、B树","date":"2020-09-01T08:44:58.000Z","updated":"2020-09-01T08:44:58.000Z","comments":true,"path":"2020/09/01/数据结构—B树、B+树、B树/","link":"","permalink":"https://tangleia.github.io/2020/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94B%E6%A0%91%E3%80%81B+%E6%A0%91%E3%80%81B%E6%A0%91/","excerpt":"数据结构—B树、B+树、B*树","text":"数据结构—B树、B+树、B*树 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 多叉树多叉树（multiway tree）允许每个节点可以有更多的数据项和更多的子节点 多叉树通过重新组织节点，减少树的高度，能对二叉树进行优化 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页(页得大小通常为4k)，这样每个节点只需要一次I/O就可以完全载入 2-3树 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点. 2-3树是由二节点和三节点构成的树 插入规则: 2-3树的所有叶子节点都在同一层.(只要是B树都满足这个条件) 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点. 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点 当按照规则插入一个数到某个节点时，不能满足上面三个要求，就需要拆，先向上拆，如果上层满，则拆本层，拆后仍然需要满足上面3个条件。 对于三节点的子树的值大小仍然遵守(BST 二叉排序树)的规则 B树 B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4 B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询 关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点 关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据. 搜索有可能在非叶子结点结束 其搜索性能等价于在关键字全集内做一次二分查找 B+树B+树是B树的变体，也是一种多路搜索树 B+树的搜索与B树也基本相同，区别是B+树只有达到叶子结点才命中（B树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找 所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据)恰好是有序的。 不可能在非叶子结点命中 非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层更适合文件索引系统 B*树B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针 B树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3，而B+树的块的最低使用率为B+树的1/2。 从第1个特点我们可以看出，B*树分配新结点的概率比B+树要低，空间使用率更高 感谢 尚硅谷 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–旋转数组的最小数字","slug":"LeetCode–旋转数组的最小数字","date":"2020-09-01T06:25:11.000Z","updated":"2020-09-01T06:25:11.000Z","comments":true,"path":"2020/09/01/LeetCode–旋转数组的最小数字/","link":"","permalink":"https://tangleia.github.io/2020/09/01/LeetCode%E2%80%93%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","excerpt":"LeetCode–旋转数组的最小数字","text":"LeetCode–旋转数组的最小数字 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 11. 旋转数组的最小数字 主站154题，153的延伸 题目把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1：12输入：[3,4,5,1,2]输出：1 示例 2：12输入：[2,2,2,0,1]输出：0 代码12345678910111213141516171819class Solution &#123; public int minArray(int[] numbers) &#123; //第一个元素 int low = 0; int high = numbers.length - 1; while(low &lt; high)&#123; //中间辅助 int pivot = low + (high - low)/2; if(numbers[pivot] &lt; numbers[high])&#123; high = pivot; &#125;else if(numbers[pivot] &gt; numbers[high])&#123; low = pivot +1; &#125;else&#123; high --; &#125; &#125; return numbers[low]; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–青蛙跳台阶问题","slug":"LeetCode–青蛙跳台阶问题","date":"2020-09-01T05:59:58.000Z","updated":"2020-09-01T06:25:25.000Z","comments":true,"path":"2020/09/01/LeetCode–青蛙跳台阶问题/","link":"","permalink":"https://tangleia.github.io/2020/09/01/LeetCode%E2%80%93%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/","excerpt":"LeetCode–青蛙跳台阶问题","text":"LeetCode–青蛙跳台阶问题 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 10- II. 青蛙跳台阶问题 主站70题 题目一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1：12输入：n &#x3D; 2输出：2 示例 2：12输入：n &#x3D; 7输出：21 示例 3：12输入：n &#x3D; 0输出：1 提示：10 &lt;&#x3D; n &lt;&#x3D; 100 代码1234567891011class Solution &#123; public int numWays(int n) &#123; int a = 1, b = 1 ,sum; for(int i = 0; i &lt; n; i++)&#123; sum = (a + b) % 1000000007; a = b; b = sum; &#125; return a; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–预测玩家","slug":"LeetCode–预测玩家","date":"2020-09-01T05:45:03.000Z","updated":"2020-09-01T05:45:03.000Z","comments":true,"path":"2020/09/01/LeetCode–预测玩家/","link":"","permalink":"https://tangleia.github.io/2020/09/01/LeetCode%E2%80%93%E9%A2%84%E6%B5%8B%E7%8E%A9%E5%AE%B6/","excerpt":"LeetCode–预测玩家","text":"LeetCode–预测玩家 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍486. 预测赢家 题目给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。 给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。 示例 1：123456输入：[1, 5, 2]输出：False解释：一开始，玩家1可以从1和2中进行选择。如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。所以，玩家 1 的最终分数为 1 + 2 &#x3D; 3，而玩家 2 为 5 。因此，玩家 1 永远不会成为赢家，返回 False 。 示例 2：1234输入：[1, 5, 233, 7]输出：True解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。 最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。 提示：1231 &lt;&#x3D; 给定的数组长度 &lt;&#x3D; 20.数组里所有分数都为非负数且不会大于 10000000 。如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。 代码1234567891011121314151617class Solution &#123; public boolean PredictTheWinner(int[] nums) &#123; int length = nums.length; int[] dp = new int[length]; for(int i = 0;i &lt; length; i++)&#123; dp[i] = nums[i]; &#125; for(int i = length - 2; i &gt;= 0; i--)&#123; for(int j = i + 1; j &lt; length; j++)&#123; //记录当前玩家与其他玩家的差值 dp[j] = Math.max(nums[i] - dp[j],nums[j] - dp[j-1]); &#125; &#125; //返回最后的结果 return dp[length - 1] &gt;= 0; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–反转字符串中的单词 III","slug":"LeetCode–反转字符串中的单词 III","date":"2020-08-30T08:11:24.000Z","updated":"2020-08-31T02:19:38.000Z","comments":true,"path":"2020/08/30/LeetCode–反转字符串中的单词 III/","link":"","permalink":"https://tangleia.github.io/2020/08/30/LeetCode%E2%80%93%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%20III/","excerpt":"LeetCode–反转字符串中的单词 III","text":"LeetCode–反转字符串中的单词 III 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍557. 反转字符串中的单词 III 题目给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例：12输入：&quot;Let&#39;s take LeetCode contest&quot;输出：&quot;s&#39;teL ekat edoCteeL tsetnoc&quot; 提示：1在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 代码12345678910111213141516171819202122232425class CQueue &#123; Deque&lt;Integer&gt; stack1; Deque&lt;Integer&gt; stack2; public CQueue() &#123; stack1 = new LinkedList&lt;Integer&gt;(); stack2 = new LinkedList&lt;Integer&gt;(); &#125; public void appendTail(int value) &#123; stack1.push(value); &#125; public int deleteHead() &#123; // 如果第二个栈为空 if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; return stack2.isEmpty() ? -1 : stack2.pop(); &#125;else &#123; return stack2.pop(); &#125; &#125;&#125; 感谢 Leetcode 以及勤劳的自己，个人博客，GitHub","categories":[],"tags":[]},{"title":"LeetCode–用两个栈实现队列","slug":"LeetCode–用两个栈实现队列","date":"2020-08-29T02:43:31.000Z","updated":"2020-08-29T02:43:31.000Z","comments":true,"path":"2020/08/29/LeetCode–用两个栈实现队列/","link":"","permalink":"https://tangleia.github.io/2020/08/29/LeetCode%E2%80%93%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","excerpt":"LeetCode–用两个栈实现队列","text":"LeetCode–用两个栈实现队列 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 09. 用两个栈实现队列 题目用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1：1234输入：[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[3],[],[]]输出：[null,null,3,-1] 示例 2：1234输入：[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2] 提示：121 &lt;&#x3D; values &lt;&#x3D; 10000最多会对 appendTail、deleteHead 进行 10000 次调用 思路 根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可 代码12345678910111213141516171819202122232425class CQueue &#123; Deque&lt;Integer&gt; stack1; Deque&lt;Integer&gt; stack2; public CQueue() &#123; stack1 = new LinkedList&lt;Integer&gt;(); stack2 = new LinkedList&lt;Integer&gt;(); &#125; public void appendTail(int value) &#123; stack1.push(value); &#125; public int deleteHead() &#123; // 如果第二个栈为空 if (stack2.isEmpty()) &#123; while (!stack1.isEmpty()) &#123; stack2.push(stack1.pop()); &#125; return stack2.isEmpty() ? -1 : stack2.pop(); &#125;else &#123; return stack2.pop(); &#125; &#125;&#125; 感谢 Leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–重建二叉树","slug":"LeetCode–重建二叉树","date":"2020-08-29T01:59:38.000Z","updated":"2020-08-29T02:44:00.000Z","comments":true,"path":"2020/08/29/LeetCode–重建二叉树/","link":"","permalink":"https://tangleia.github.io/2020/08/29/LeetCode%E2%80%93%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"LeetCode–重建二叉树","text":"LeetCode–重建二叉树 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍剑指 Offer 07. 重建二叉树 主站 105 题 题目输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出 12前序遍历 preorder &#x3D; [3,9,20,15,7]中序遍历 inorder &#x3D; [9,3,15,20,7] 返回如下的二叉树： 123453 &#x2F; \\9 20 &#x2F; \\ 15 7 思路 使用前序遍历的第一个元素创建根节点。 创建一个栈，将根节点压入栈内。 初始化中序遍历下标为 0。 遍历前序遍历的每个元素，判断其上一个元素（即栈顶元素）是否等于中序遍历下标指向的元素。 若上一个元素不等于中序遍历下标指向的元素，则将当前元素作为其上一个元素的左子节点，并将当前元素压入栈内。 若上一个元素等于中序遍历下标指向的元素，则从栈内弹出一个元素，同时令中序遍历下标指向下一个元素，之后继续判断栈顶元素是否等于中序遍历下标指向的元素，若相等则重复该操作，直至栈为空或者元素不相等。然后令当前元素为最后一个想等元素的右节点。 遍历结束，返回根节点 代码12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder == null || preorder.length == 0)&#123; return null; &#125; //前序遍历第一个为根节点 TreeNode root = new TreeNode(preorder[0]); int length = preorder.length; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); //将根节点压入栈 stack.push(root); int index = 0; for(int i = 1;i&lt;length;i++)&#123; int preorderVal = preorder[i]; //查看栈顶的对象 TreeNode node = stack.peek(); if(node.val != inorder[index])&#123; //判断中序遍历的对象是否为当前栈顶元素 node.left = new TreeNode(preorderVal); stack.push(node.left); &#125;else&#123; while(!stack.isEmpty() &amp;&amp; stack.peek().val == inorder[index])&#123; node = stack.pop(); index++; &#125; node.right = new TreeNode(preorderVal); stack.push(node.right); &#125; &#125; return root; &#125;&#125; 感谢 Leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"数据结构—平衡二叉树（Java）","slug":"数据结构—平衡二叉树（Java）","date":"2020-08-28T14:57:44.000Z","updated":"2020-08-29T01:53:11.000Z","comments":true,"path":"2020/08/28/数据结构—平衡二叉树（Java）/","link":"","permalink":"https://tangleia.github.io/2020/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构—平衡二叉树（Java）","text":"数据结构—平衡二叉树（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树， 可以保证查询效率较高。具有以下特点：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270package cn.guizimo.avl;public class AVLTree &#123; public static void main(String[] args) &#123; int[] arr = &#123; 10, 11, 7, 6, 8, 9 &#125;; AVLTreeDemo avlTree = new AVLTreeDemo(); for(int i=0; i &lt; arr.length; i++) &#123; avlTree.add(new Node(arr[i])); &#125; System.out.println(\"中序遍历\"); avlTree.infixOrder(); System.out.println(\"平衡\"); System.out.println(\"树的高度：\" + avlTree.getRoot().height()); //3 System.out.println(\"左子树高度：\" + avlTree.getRoot().leftHeight()); // 2 System.out.println(\"右子树高度\" + avlTree.getRoot().rightHeight()); // 2 System.out.println(\"根节点：\" + avlTree.getRoot());//8 &#125;&#125;class AVLTreeDemo&#123; private Node root; public Node getRoot() &#123; return root; &#125; //查找当前节点 public Node search(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.search(value); &#125; &#125; //找到最小值 public int delRightTreeMin(Node node) &#123; Node target = node; while(target.left != null) &#123; target = target.left; &#125; delNode(target.value); return target.value; &#125; //删除节点 public void delNode(int value) &#123; if (root == null) &#123; return; &#125; else &#123; //删除叶子节点 Node targetNode = search(value); if (targetNode == null) &#123; return; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; Node parent = searchParent(value); if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123; if (parent.left != null &amp;&amp; parent.left.value == value) &#123; parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123; parent.right = null; &#125; //删除两颗子树的节点 &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123; int i = delRightTreeMin(targetNode.right); targetNode.value = i; //删除一颗子树的节点 &#125; else &#123; if (targetNode.left != null) &#123; if (parent != null) &#123; if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.left; &#125; &#125; else &#123; if (parent != null) &#123; if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else if (parent.right.value == value) &#123; parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.right; &#125; &#125; &#125; &#125; &#125; //查询当前节点的父节点 public Node searchParent(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.searchParent(value); &#125; &#125; //添加节点 public void add(Node node) &#123; if (root == null) &#123; root = node; &#125; else &#123; root.add(node); &#125; &#125; //中序遍历 public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println(\"\"); &#125; &#125;&#125;class Node &#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; //左子树的高度 public int leftHeight() &#123; if (left == null) &#123; return 0; &#125; return left.height(); &#125; // 右子树的高度 public int rightHeight() &#123; if (right == null) &#123; return 0; &#125; return right.height(); &#125; // 当前节点的高度 public int height() &#123; return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"value=\" + value + '&#125;'; &#125; //查找节点 public Node search(int value) &#123; if (value == this.value) &#123; return this; &#125; else if (value &lt; this.value) &#123; if (this.left == null) &#123; return null; &#125; return this.left.search(value); &#125; else &#123; if (this.right == null) &#123; return null; &#125; return this.right.search(value); &#125; &#125; //查询父节点 public Node searchParent(int value) &#123; if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) &#123; return this; &#125; else &#123; if (value &lt; this.value &amp;&amp; this.left != null) &#123; return this.left.searchParent(value); &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123; return this.right.searchParent(value); &#125; else &#123; return null; &#125; &#125; &#125; //添加节点 public void add(Node node) &#123; if (node == null) &#123; return; &#125; if (node.value &lt; this.value) &#123; if (this.left == null) &#123; this.left = node; &#125; else &#123; this.left.add(node); &#125; &#125; else &#123; if (this.right == null) &#123; this.right = node; &#125; else &#123; this.right.add(node); &#125; &#125; //左旋转 if(rightHeight() - leftHeight() &gt; 1) &#123; if(right != null &amp;&amp; right.leftHeight() &gt; right.rightHeight()) &#123; right.rightRotate(); leftRotate(); &#125; else &#123; leftRotate(); &#125; return ; &#125; //右旋转 if(leftHeight() - rightHeight() &gt; 1) &#123; if(left != null &amp;&amp; left.rightHeight() &gt; left.leftHeight()) &#123; left.leftRotate(); rightRotate(); &#125; else &#123; rightRotate(); &#125; &#125; &#125; //中序遍历 public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; //左旋转 private void leftRotate() &#123; Node newNode = new Node(value); newNode.left = left; newNode.right = right.left; value = right.value; right = right.right; left = newNode; &#125; //右旋转 private void rightRotate() &#123; Node newNode = new Node(value); newNode.right = right; newNode.left = left.right; value = left.value; left = left.left; right = newNode; &#125;&#125; 测试 感谢 尚硅谷 以及勤劳的自己","categories":[],"tags":[]},{"title":"数据结构—二叉排序树（Java）","slug":"数据结构—二叉排序树（Java）","date":"2020-08-28T12:30:43.000Z","updated":"2020-08-28T12:30:43.000Z","comments":true,"path":"2020/08/28/数据结构—二叉排序树（Java）/","link":"","permalink":"https://tangleia.github.io/2020/08/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构—二叉排序树（Java）","text":"数据结构—二叉排序树（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208package cn.guizimo.binarysorttree;public class BinarySortTree &#123; public static void main(String[] args) &#123; int[] arr = &#123;7, 3, 10, 12, 5, 1, 9, 2&#125;; BinarySortTreeDemo binarySortTree = new BinarySortTreeDemo(); for(int i = 0; i&lt; arr.length; i++) &#123; binarySortTree.add(new Node(arr[i])); &#125; System.out.println(\"中序遍历\"); binarySortTree.infixOrder(); // 1, 3, 5, 7, 9, 10, 12 binarySortTree.delNode(12); System.out.println(\"当前根节点root=\" + binarySortTree.getRoot()); System.out.println(\"删除后中序遍历\"); binarySortTree.infixOrder(); &#125; &#125;class BinarySortTreeDemo &#123; private Node root; public Node getRoot() &#123; return root; &#125; //查找当前节点 public Node search(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.search(value); &#125; &#125; //找到最小值 public int delRightTreeMin(Node node) &#123; Node target = node; while(target.left != null) &#123; target = target.left; &#125; delNode(target.value); return target.value; &#125; //删除节点 public void delNode(int value) &#123; if (root == null) &#123; return; &#125; else &#123; //删除叶子节点 Node targetNode = search(value); if (targetNode == null) &#123; return; &#125; if (root.left == null &amp;&amp; root.right == null) &#123; root = null; return; &#125; Node parent = searchParent(value); if (targetNode.left == null &amp;&amp; targetNode.right == null) &#123; if (parent.left != null &amp;&amp; parent.left.value == value) &#123; parent.left = null; &#125; else if (parent.right != null &amp;&amp; parent.right.value == value) &#123; parent.right = null; &#125; //删除两颗子树的节点 &#125; else if (targetNode.left != null &amp;&amp; targetNode.right != null) &#123; int i = delRightTreeMin(targetNode.right); targetNode.value = i; //删除一颗子树的节点 &#125; else &#123; if (targetNode.left != null) &#123; if (parent != null) &#123; if (parent.left.value == value) &#123; parent.left = targetNode.left; &#125; else &#123; parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.left; &#125; &#125; else &#123; if (parent != null) &#123; if (parent.left.value == value) &#123; parent.left = targetNode.right; &#125; else if (parent.right.value == value) &#123; parent.right = targetNode.right; &#125; &#125; else &#123; root = targetNode.right; &#125; &#125; &#125; &#125; &#125; //查询当前节点的父节点 public Node searchParent(int value) &#123; if (root == null) &#123; return null; &#125; else &#123; return root.searchParent(value); &#125; &#125; //添加节点 public void add(Node node) &#123; if (root == null) &#123; root = node; &#125; else &#123; root.add(node); &#125; &#125; //中序遍历 public void infixOrder() &#123; if (root != null) &#123; root.infixOrder(); &#125; else &#123; System.out.println(\"\"); &#125; &#125;&#125;class Node &#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"value=\" + value + '&#125;'; &#125; //查找节点 public Node search(int value) &#123; if (value == this.value) &#123; return this; &#125; else if (value &lt; this.value) &#123; if (this.left == null) &#123; return null; &#125; return this.left.search(value); &#125; else &#123; if (this.right == null) &#123; return null; &#125; return this.right.search(value); &#125; &#125; //查询父节点 public Node searchParent(int value) &#123; if ((this.left != null &amp;&amp; this.left.value == value) || (this.right != null &amp;&amp; this.right.value == value)) &#123; return this; &#125; else &#123; if (value &lt; this.value &amp;&amp; this.left != null) &#123; return this.left.searchParent(value); &#125; else if (value &gt;= this.value &amp;&amp; this.right != null) &#123; return this.right.searchParent(value); &#125; else &#123; return null; &#125; &#125; &#125; //添加节点 public void add(Node node) &#123; if (node == null) &#123; return; &#125; if (node.value &lt; this.value) &#123; if (this.left == null) &#123; this.left = node; &#125; else &#123; this.left.add(node); &#125; &#125; else &#123; if (this.right == null) &#123; this.right = node; &#125; else &#123; this.right.add(node); &#125; &#125; &#125; //中序遍历 public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125;&#125; 测试 感谢 尚硅谷 以及勤劳的自己","categories":[],"tags":[]},{"title":"uni-app获取腾讯地图计算两经纬度的实际距离（可批量）","slug":"uni-app获取腾讯地图计算两经纬度的实际距离（可批量）","date":"2020-08-22T15:16:50.000Z","updated":"2020-08-22T15:16:50.000Z","comments":true,"path":"2020/08/22/uni-app获取腾讯地图计算两经纬度的实际距离（可批量）/","link":"","permalink":"https://tangleia.github.io/2020/08/22/uni-app%E8%8E%B7%E5%8F%96%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE%E8%AE%A1%E7%AE%97%E4%B8%A4%E7%BB%8F%E7%BA%AC%E5%BA%A6%E7%9A%84%E5%AE%9E%E9%99%85%E8%B7%9D%E7%A6%BB%EF%BC%88%E5%8F%AF%E6%89%B9%E9%87%8F%EF%BC%89/","excerpt":"uni-app获取腾讯地图计算两经纬度的实际距离（可批量）","text":"uni-app获取腾讯地图计算两经纬度的实际距离（可批量） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 地址https://lbs.qq.com/service/webService/webServiceGuide/webServiceDistance 代码12345678910111213141516171819202122232425262728getDistance() &#123; uni.request(&#123; url: 'https://apis.map.qq.com/ws/distance/v1/matrix', //仅为示例，并非真实接口地址。 method: 'GET', data: &#123; mode: 'walking', from: '39.071510,117.190091', to: '39.108951,117.279396', key: '.....' //获取key &#125;, success: (res) =&gt; &#123; console.log(res); let hw = res.data.result.rows[0].elements[0].distance; //拿到距离(米) if (hw &amp;&amp; hw !== -1) &#123; if (hw &lt; 1000) &#123; hw = hw + 'm'; &#125; //转换成公里 else &#123; hw = (hw / 2 / 500).toFixed(2) + 'km' &#125; &#125; else &#123; hw = \"距离太近或请刷新重试\" &#125; console.log(hw); &#125; &#125;);&#125; 测试 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"SpringBoot项目中在实体类中引入非数据库字段","slug":"SpringBoot项目中在实体类中引入非数据库字段","date":"2020-08-22T15:15:16.000Z","updated":"2020-08-22T15:15:16.000Z","comments":true,"path":"2020/08/22/SpringBoot项目中在实体类中引入非数据库字段/","link":"","permalink":"https://tangleia.github.io/2020/08/22/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%9C%A8%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E5%BC%95%E5%85%A5%E9%9D%9E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5/","excerpt":"SpringBoot项目中在实体类中引入非数据库字段","text":"SpringBoot项目中在实体类中引入非数据库字段 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 当使用jpa的时候导入依赖在pom.xml中导入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt; 在实体类中加入注解 注意导入的依赖 当使用Mybait-Plus作为数据层使用注解@TableField(exist = false) 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"SpringBoot搭建API文档插件Swagger并美化","slug":"SpringBoot搭建API文档插件Swagger并美化","date":"2020-08-19T16:46:58.000Z","updated":"2020-08-19T16:46:58.000Z","comments":true,"path":"2020/08/20/SpringBoot搭建API文档插件Swagger并美化/","link":"","permalink":"https://tangleia.github.io/2020/08/20/SpringBoot%E6%90%AD%E5%BB%BAAPI%E6%96%87%E6%A1%A3%E6%8F%92%E4%BB%B6Swagger%E5%B9%B6%E7%BE%8E%E5%8C%96/","excerpt":"SpringBoot搭建API文档插件Swagger并美化","text":"SpringBoot搭建API文档插件Swagger并美化 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 地址swagger-bootstrap-ui官网 导入依赖1234567891011121314151617181920&lt;!-- swagger用于定义API文档 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!--美化swagger--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.3&lt;/version&gt;&lt;/dependency&gt; 创建配置文件 SwaggerConfig1234567891011121314151617181920212223242526272829303132333435363738package com.guizimo.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.guizimo.controller\")) //此次每次使用须换成自己的web接口的全限定类名 //.paths(AppUtility.isProd() ? PathSelectors.none() : PathSelectors.any()) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title(\"测试swagger\") .description(\"展示swagger界面\") .termsOfServiceUrl(\"http://localhost:8081/swagger-ui.html\") .contact(new Contact(\"guizimo\", \"http://localhost:8081/swagger-ui.html\", \"2500568424@qq.com\")) .version(\"1.0\") .build(); &#125;&#125; WebMvcConfig1234567891011121314151617181920212223242526package com.guizimo.config;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;@Configurationpublic class WebMvcConfig extends WebMvcConfigurationSupport &#123; @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) &#123; //排除静态文件 registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"doc.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); super.addResourceHandlers(registry); &#125;&#125; 注意导入包的时候别导入错了 配置一个接口在controller中选择我们的一个接口 123456789101112131415161718192021222324252627282930313233343536package com.guizimo.controller;import com.guizimo.common.Result;import com.guizimo.entity.Banner;import com.guizimo.service.BannerService;import io.swagger.annotations.Api;import io.swagger.annotations.ApiOperation;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * &lt;p&gt; * banner子项表 前端控制器 * &lt;/p&gt; * * @author guizimo * @since 2020-08-19 */@RestController@RequestMapping(\"/banner\")@Api(value=\"轮播图\",tags = \"轮播图\",description = \"首页轮播图\")public class BannerController &#123; @Autowired BannerService bannerService; // 根据Id查询用户的信息 @ApiOperation(value = \"获取轮播图\",notes =\"获取当前的轮播图\") @GetMapping(\"/index\") public Object index()&#123; Banner banner = bannerService.getById(1L); return Result.success(banner); &#125;&#125; 运行mvn install 运行SpringBoot项目，运行成功之后 原版swagger-ui http://localhost:8081/swagger-ui.html 新版swagger-bootstrap-ui http://localhost:8081/doc.html 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"微信服务商分账功能开发（PHP）","slug":"微信服务商分账功能开发（PHP）","date":"2020-08-09T10:08:02.000Z","updated":"2020-08-09T10:08:02.000Z","comments":true,"path":"2020/08/09/微信服务商分账功能开发（PHP）/","link":"","permalink":"https://tangleia.github.io/2020/08/09/%E5%BE%AE%E4%BF%A1%E6%9C%8D%E5%8A%A1%E5%95%86%E5%88%86%E8%B4%A6%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91%EF%BC%88PHP%EF%BC%89/","excerpt":"微信服务商分账功能开发（PHP）","text":"微信服务商分账功能开发（PHP） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 设置分账参数在调用支付的时候设置参数 添加分账参数 在JDK中添加get，set方法 123456789101112131415//分账 public function SetProfit_sharing($value) &#123; $this-&gt;values['profit_sharing'] = $value; &#125; public function GetProfit_sharing() &#123; return $this-&gt;values['profit_sharing']; &#125; public function IsProfit_sharingSet() &#123; return array_key_exists('profit_sharing', $this-&gt;values); &#125; 添加分账接收方核心代码 部分参数写在SDK的config文件中 12345678910111213141516171819202122232425262728293031&lt;?php/** * @name ProfitSharing.php * @author tanglei * @date 2020/8/9 */namespace app\\api\\service;use think\\facade\\Env;require_once Env::get('root_path'). \"extend/WxPay/WxPay.Api.php\";class ProfitSharing&#123; public static function addPro() &#123; $receiver = [ \"type\" =&gt; \"MERCHANT_ID\", \"account\" =&gt; \"11111\", \"name\" =&gt; \"有限公司\", \"relation_type\" =&gt; \"SERVICE_PROVIDER\" ]; $WxOrderData = new \\WxPayProfitSharing(); //子商户号 $WxOrderData-&gt;SetSub_Mch_id('11111'); $WxOrderData-&gt;SetSubAppid(config('base.app_id')); $WxOrderData-&gt;SetReceiver(json_encode($receiver)); $wxOrder = \\WxPayApi::profitsharingAddReceiver($WxOrderData); return $wxOrder; &#125;&#125; 要改一下SDK文件 在Data的签名里面必须使用HMAC-SHA256 12345678910111213public function MakeSignH() &#123; //签名步骤一：按字典序排序参数 ksort($this-&gt;values); $string = $this-&gt;ToUrlParams(); //签名步骤二：在string后加入KEY $string = $string . \"&amp;key=\".WxPayConfig::KEY; //签名 $string = hash_hmac(\"sha256\",$string,WxPayConfig::KEY); //签名步骤四：所有字符转为大写 $result = strtoupper($string); return $result; &#125; 在Api文件中添加一个方法 12345678910111213141516171819public static function profitsharingAddReceiver($inputObj, $timeOut = 6)&#123; $url = \"https://api.mch.weixin.qq.com/pay/profitsharingaddreceiver\"; $inputObj-&gt;SetAppid(WxPayConfig::APPID);//公众账号ID $inputObj-&gt;SetMch_id(WxPayConfig::MCHID);//商户号 $inputObj-&gt;SetNonce_str(self::getNonceStr());//随机字符串 //签名 $inputObj-&gt;SetSignHash(); $xml = $inputObj-&gt;ToXml(); $startTimeStamp = self::getMillisecond();//请求开始时间 $response = self::postXmlCurl($xml, $url, false, $timeOut); return $response; $result = WxPayResults::Init($response); self::reportCostTime($url, $startTimeStamp, $result);//上报请求花费时间 return $result;&#125; 测试 分账 核心代码 123456789101112131415161718public static function profitSharing() &#123; $receivers = [ \"type\" =&gt; \"MERCHANT_ID\", \"account\" =&gt; \"111111\", \"amount\" =&gt; 2, \"description\" =&gt; \"分到服务商\" ]; $orderNo = self::makeOrderNo(); $WxOrderData = new \\WxPayProfitSharing(); $WxOrderData-&gt;SetSub_Mch_id('11111'); $WxOrderData-&gt;SetTransaction_id('42789709008202008098970721631'); $WxOrderData-&gt;SetOut_order_no($orderNo); $WxOrderData-&gt;SetSubAppid(config('base.app_id')); $WxOrderData-&gt;SetReceivers(json_encode($receivers)); $wxOrder = \\WxPayApi::profitsharing($WxOrderData); return json($wxOrder); &#125; 在Api文件中添加一个方法 12345678910111213141516171819public static function profitsharing($inputObj, $timeOut = 6) &#123; $url = \"https://api.mch.weixin.qq.com/secapi/pay/profitsharing\"; $inputObj-&gt;SetAppid(WxPayConfig::APPID);//公众账号ID $inputObj-&gt;SetMch_id(WxPayConfig::MCHID);//商户号 $inputObj-&gt;SetNonce_str(self::getNonceStr());//随机字符串 //签名 $inputObj-&gt;SetSignHash(); $xml = $inputObj-&gt;ToXml(); $startTimeStamp = self::getMillisecond();//请求开始时间 $response = self::postXmlCurl($xml, $url, true, $timeOut); //return $response; $result = WxPayResults::Init($response); self::reportCostTime($url, $startTimeStamp, $result);//上报请求花费时间 return $result; &#125; 测试 感谢 微信开放平台 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"哈夫曼编码—文件的压缩与解压（Java）","slug":"哈夫曼编码—文件的压缩与解压（Java）","date":"2020-08-08T07:31:54.000Z","updated":"2020-08-08T07:31:54.000Z","comments":true,"path":"2020/08/08/哈夫曼编码—文件的压缩与解压（Java）/","link":"","permalink":"https://tangleia.github.io/2020/08/08/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E2%80%94%E6%96%87%E4%BB%B6%E7%9A%84%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%EF%BC%88Java%EF%BC%89/","excerpt":"哈夫曼编码—文件的压缩与解压（Java）","text":"哈夫曼编码—文件的压缩与解压（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 压缩代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278package cn.guizimo.huffmancode;import java.io.*;import java.util.*;/** * @author guizimo * @date 2020/8/8 11:55 上午 */public class HuffmanCode &#123; public static void main(String[] args) &#123; String zipFile = \"d://123.png\"; String dstFile = \"d://123.zip\"; zipFile(zipFile, dstFile);; System.out.println(\"压缩成功!\"); &#125; public static void unZipFile(String zipFile, String dstFile) &#123; InputStream is = null; ObjectInputStream ois = null; OutputStream os = null; try &#123; is = new FileInputStream(zipFile); ois = new ObjectInputStream(is); byte[] huffmanBytes = (byte[]) ois.readObject(); Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); byte[] bytes = huffmanUnzip(huffmanCodes, huffmanBytes); os = new FileOutputStream(dstFile); os.write(bytes); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; try &#123; os.close(); ois.close(); is.close(); &#125; catch (Exception e2) &#123; System.out.println(e2.getMessage()); &#125; &#125; &#125; public static void zipFile(String srcFile, String dstFile) &#123; OutputStream os = null; ObjectOutputStream oos = null; FileInputStream is = null; try &#123; is = new FileInputStream(srcFile); byte[] b = new byte[is.available()]; is.read(b); byte[] huffmanBytes = huffmanZip(b); os = new FileOutputStream(dstFile); oos = new ObjectOutputStream(os); oos.writeObject(huffmanBytes); oos.writeObject(huffmanCodes); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; try &#123; is.close(); oos.close(); os.close(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125; &#125; //哈夫曼解压 private static byte[] huffmanUnzip(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; huffmanBytes.length; i++) &#123; byte b = huffmanBytes[i]; boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBitString(!flag, b)); &#125; //解码,反向编码表 HashMap&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123; map.put(entry.getValue(), entry.getKey()); &#125; //根据编码扫描到对应的ASCLL码对应的字符 List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; stringBuilder.length(); ) &#123; int count = 1; boolean flag = true; Byte b = null; while (flag) &#123; String key = stringBuilder.substring(i, i + count); b = map.get(key); if (b == null) &#123; count++; &#125; else &#123; flag = false; &#125; &#125; list.add(b); i += count; &#125; byte b[] = new byte[list.size()]; for (int i = 0; i &lt; b.length; i++) &#123; b[i] = list.get(i); &#125; return b; &#125; //转化二进制 private static String byteToBitString(boolean flag, byte b) &#123; int temp = b; if (flag) &#123; temp |= 256; &#125; String str = Integer.toBinaryString(temp); if (flag) &#123; return str.substring(str.length() - 8); &#125; else &#123; return str; &#125; &#125; //哈夫曼编码压缩 private static byte[] huffmanZip(byte[] bytes) &#123; List&lt;Node&gt; nodes = getNodes(bytes); //哈夫曼树 Node huffmanTree = createHuffmanTree(nodes); //哈夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree); //哈夫曼编码 byte[] zip = zip(bytes, huffmanCodes); return zip; &#125; //压缩 private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123; StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) &#123; stringBuilder.append(huffmanCodes.get(b)); &#125; int len; if (stringBuilder.length() % 8 == 0) &#123; len = stringBuilder.length() / 8; &#125; else &#123; len = stringBuilder.length() / 8 + 1; &#125; byte[] by = new byte[len]; int index = 0; for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123; String strByte; if (i + 8 &gt; stringBuilder.length()) &#123; strByte = stringBuilder.substring(i); by[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; else &#123; strByte = stringBuilder.substring(i, i + 8); by[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; &#125; return by; &#125; static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;(); static StringBuilder stringBuilder = new StringBuilder(); //重载 private static Map&lt;Byte, String&gt; getCodes(Node root) &#123; if (root == null) &#123; return null; &#125; getCodes(root.left, \"0\", stringBuilder); getCodes(root.right, \"1\", stringBuilder); return huffmanCodes; &#125; //获取哈夫曼编码 private static void getCodes(Node node, String code, StringBuilder stringBuilder) &#123; StringBuilder builder = new StringBuilder(stringBuilder); builder.append(code); if (node != null) &#123; if (node.data == null) &#123; //递归 getCodes(node.left, \"0\", builder); getCodes(node.right, \"1\", builder); &#125; else &#123; huffmanCodes.put(node.data, builder.toString()); &#125; &#125; &#125; //前序遍历 private static void preOrder(Node root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println(\"哈夫曼树为空\"); &#125; &#125; //生成哈夫曼树 private static Node createHuffmanTree(List&lt;Node&gt; nodes) &#123; while (nodes.size() &gt; 1) &#123; Collections.sort(nodes); Node leftNode = nodes.get(0); Node rightNode = nodes.get(1); Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); &#125; return nodes.get(0); &#125; //接收字节数组 private static List&lt;Node&gt; getNodes(byte[] bytes) &#123; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; Integer count = counts.get(b); if (count == null) &#123; counts.put(b, 1); &#125; else &#123; counts.put(b, count + 1); &#125; &#125; //遍历map for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new Node(entry.getKey(), entry.getValue())); &#125; return nodes; &#125;&#125;class Node implements Comparable&lt;Node&gt; &#123; Byte data; int weight; //字符出现的次数 Node left; Node right; //前序遍历 public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; public Node(Byte data, int weight) &#123; this.data = data; this.weight = weight; &#125; @Override public int compareTo(Node o) &#123; //从小到大排序 return this.weight - o.weight; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"data=\" + data + \", weight=\" + weight + '&#125;'; &#125;&#125; 解压代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278package cn.guizimo.huffmancode;import java.io.*;import java.util.*;/** * @author guizimo * @date 2020/8/8 11:55 上午 */public class HuffmanCode &#123; public static void main(String[] args) &#123; String zipFile = \"d://Uninstall.zip\"; String dstFile = \"d://Uninstall2.xml\"; unZipFile(zipFile, dstFile); System.out.println(\"解压成功!\"); &#125; public static void unZipFile(String zipFile, String dstFile) &#123; InputStream is = null; ObjectInputStream ois = null; OutputStream os = null; try &#123; is = new FileInputStream(zipFile); ois = new ObjectInputStream(is); byte[] huffmanBytes = (byte[]) ois.readObject(); Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject(); byte[] bytes = huffmanUnzip(huffmanCodes, huffmanBytes); os = new FileOutputStream(dstFile); os.write(bytes); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; try &#123; os.close(); ois.close(); is.close(); &#125; catch (Exception e2) &#123; System.out.println(e2.getMessage()); &#125; &#125; &#125; public static void zipFile(String srcFile, String dstFile) &#123; OutputStream os = null; ObjectOutputStream oos = null; FileInputStream is = null; try &#123; is = new FileInputStream(srcFile); byte[] b = new byte[is.available()]; is.read(b); byte[] huffmanBytes = huffmanZip(b); os = new FileOutputStream(dstFile); oos = new ObjectOutputStream(os); oos.writeObject(huffmanBytes); oos.writeObject(huffmanCodes); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; finally &#123; try &#123; is.close(); oos.close(); os.close(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125; &#125; //哈夫曼解压 private static byte[] huffmanUnzip(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; huffmanBytes.length; i++) &#123; byte b = huffmanBytes[i]; boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBitString(!flag, b)); &#125; //解码,反向编码表 HashMap&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123; map.put(entry.getValue(), entry.getKey()); &#125; //根据编码扫描到对应的ASCLL码对应的字符 List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; stringBuilder.length(); ) &#123; int count = 1; boolean flag = true; Byte b = null; while (flag) &#123; String key = stringBuilder.substring(i, i + count); b = map.get(key); if (b == null) &#123; count++; &#125; else &#123; flag = false; &#125; &#125; list.add(b); i += count; &#125; byte b[] = new byte[list.size()]; for (int i = 0; i &lt; b.length; i++) &#123; b[i] = list.get(i); &#125; return b; &#125; //转化二进制 private static String byteToBitString(boolean flag, byte b) &#123; int temp = b; if (flag) &#123; temp |= 256; &#125; String str = Integer.toBinaryString(temp); if (flag) &#123; return str.substring(str.length() - 8); &#125; else &#123; return str; &#125; &#125; //哈夫曼编码压缩 private static byte[] huffmanZip(byte[] bytes) &#123; List&lt;Node&gt; nodes = getNodes(bytes); //哈夫曼树 Node huffmanTree = createHuffmanTree(nodes); //哈夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree); //哈夫曼编码 byte[] zip = zip(bytes, huffmanCodes); return zip; &#125; //压缩 private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123; StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) &#123; stringBuilder.append(huffmanCodes.get(b)); &#125; int len; if (stringBuilder.length() % 8 == 0) &#123; len = stringBuilder.length() / 8; &#125; else &#123; len = stringBuilder.length() / 8 + 1; &#125; byte[] by = new byte[len]; int index = 0; for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123; String strByte; if (i + 8 &gt; stringBuilder.length()) &#123; strByte = stringBuilder.substring(i); by[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; else &#123; strByte = stringBuilder.substring(i, i + 8); by[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; &#125; return by; &#125; static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;(); static StringBuilder stringBuilder = new StringBuilder(); //重载 private static Map&lt;Byte, String&gt; getCodes(Node root) &#123; if (root == null) &#123; return null; &#125; getCodes(root.left, \"0\", stringBuilder); getCodes(root.right, \"1\", stringBuilder); return huffmanCodes; &#125; //获取哈夫曼编码 private static void getCodes(Node node, String code, StringBuilder stringBuilder) &#123; StringBuilder builder = new StringBuilder(stringBuilder); builder.append(code); if (node != null) &#123; if (node.data == null) &#123; //递归 getCodes(node.left, \"0\", builder); getCodes(node.right, \"1\", builder); &#125; else &#123; huffmanCodes.put(node.data, builder.toString()); &#125; &#125; &#125; //前序遍历 private static void preOrder(Node root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println(\"哈夫曼树为空\"); &#125; &#125; //生成哈夫曼树 private static Node createHuffmanTree(List&lt;Node&gt; nodes) &#123; while (nodes.size() &gt; 1) &#123; Collections.sort(nodes); Node leftNode = nodes.get(0); Node rightNode = nodes.get(1); Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); &#125; return nodes.get(0); &#125; //接收字节数组 private static List&lt;Node&gt; getNodes(byte[] bytes) &#123; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; Integer count = counts.get(b); if (count == null) &#123; counts.put(b, 1); &#125; else &#123; counts.put(b, count + 1); &#125; &#125; //遍历map for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new Node(entry.getKey(), entry.getValue())); &#125; return nodes; &#125;&#125;class Node implements Comparable&lt;Node&gt; &#123; Byte data; int weight; //字符出现的次数 Node left; Node right; //前序遍历 public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; public Node(Byte data, int weight) &#123; this.data = data; this.weight = weight; &#125; @Override public int compareTo(Node o) &#123; //从小到大排序 return this.weight - o.weight; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"data=\" + data + \", weight=\" + weight + '&#125;'; &#125;&#125; 感谢 尚硅谷 以及勤劳的自己","categories":[],"tags":[]},{"title":"哈夫曼编码—数据压缩与解压（Java）","slug":"哈夫曼编码—数据压缩与解压（Java）","date":"2020-08-08T07:12:44.000Z","updated":"2020-08-08T07:30:40.000Z","comments":true,"path":"2020/08/08/哈夫曼编码—数据压缩与解压（Java）/","link":"","permalink":"https://tangleia.github.io/2020/08/08/%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E2%80%94%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B%EF%BC%88Java%EF%BC%89/","excerpt":"哈夫曼编码—数据压缩与解压（Java）","text":"哈夫曼编码—数据压缩与解压（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍 赫夫曼编码也翻译为 哈夫曼编码(Huffman Coding)，又称霍夫曼编码，是一种编码方式, 属于一种程序算法 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%～90%之间 赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码 通信领域中信息的处理方式定长编码数据传输太长 12345i like like like java do you like a java &#x2F;&#x2F; 共40个字符(包括空格) 105 32 108 105 107 101 32 108 105 107 101 32 108 105 107 101 32 106 97 118 97 32 100 111 32 121 111 117 32 108 105 107 101 32 97 32 106 97 118 97 &#x2F;&#x2F;对应Ascii码01101001 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101100 01101001 01101011 01100101 00100000 01101010 01100001 01110110 01100001 00100000 01100100 01101111 00100000 01111001 01101111 01110101 00100000 01101100 01101001 01101011 01100101 00100000 01100001 00100000 01101010 01100001 01110110 01100001 &#x2F;&#x2F;对应的二进制 变长编码存在多义性 1234567i like like like java do you like a java &#x2F;&#x2F; 共40个字符(包括空格)d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 &#x2F;&#x2F; 各个字符对应的个数0&#x3D; , 1&#x3D;a, 10&#x3D;i, 11&#x3D;e, 100&#x3D;k, 101&#x3D;l, 110&#x3D;o, 111&#x3D;v, 1000&#x3D;j, 1001&#x3D;u, 1010&#x3D;y, 1011&#x3D;d说明：按照各个字符出现的次数进行编码，原则是出现次数越多的，则编码越小，比如 空格出现了9 次， 编码为0 ,其它依次类推.按照上面给各个字符规定的编码，则我们在传输 &quot;i like like like java do you like a java&quot; 数据时，编码就是 10010110100... 哈夫曼编码（前缀编码）1234567891011121314151617181920212223i like like like java do you like a java &#x2F;&#x2F; 共40个字符(包括空格)d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5 :9 &#x2F;&#x2F; 各个字符对应的个数按照上面字符出现的次数构建一颗赫夫曼树, 次数作为权值&#x2F;&#x2F;根据赫夫曼树，给各个字符&#x2F;&#x2F;规定编码 ， 向左的路径为0&#x2F;&#x2F;向右的路径为1 ， 编码如下:o: 1000 u: 10010 d: 100110 y: 100111 i: 101a : 110 k: 1110 e: 1111 j: 0000 v: 0001l: 001 : 01按照上面的赫夫曼编码，我们的&quot;i like like like java do you like a java&quot; 字符串对应的编码为 (注意这里我们使用的无损压缩)1010100110111101111010011011110111101001101111011110100001100001110011001111000011001111000100100100110111101111011100100001100001110长度为 ： 133 说明:原来长度是 359 , 压缩了 (359-133) &#x2F; 359 &#x3D; 62.9%此编码满足前缀编码, 即字符的编码都不能是其他字符编码的前缀。不会造成匹配的多义性 注意这个哈夫曼树根据排序方法不同，也可能不太一样，这样对应的赫夫曼编码也不完全一样，但是wpl 是一样的，都是最小的 压缩思路 首先将字符串转化为字节数组 创建哈夫曼树，将值和权重写入 根据叶子结点的权重来计算哈夫曼编码表 根据哈夫曼编码表来计算哈夫曼编码 最后再转化为字节数组 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169package cn.guizimo.huffmancode;import java.util.*;/** * @author guizimo * @date 2020/8/8 11:55 上午 */public class HuffmanCode &#123; public static void main(String[] args) &#123; String content = \"i like like like java do you like a java\"; byte[] contentBytes = content.getBytes(); //哈夫曼编码 byte[] zip = huffmanZip(contentBytes); System.out.println(\"哈夫曼编码：\" + Arrays.toString(zip)); &#125; private static byte[] huffmanZip(byte[] bytes)&#123; List&lt;Node&gt; nodes = getNodes(bytes); //哈夫曼树 Node huffmanTree = createHuffmanTree(nodes); //哈夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree); //哈夫曼编码 byte[] zip = zip(bytes, huffmanCodes); return zip; &#125; //压缩 private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123; StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) &#123; stringBuilder.append(huffmanCodes.get(b)); &#125; int len; if (stringBuilder.length() % 8 == 0) &#123; len = stringBuilder.length() / 8; &#125; else &#123; len = stringBuilder.length() / 8 + 1; &#125; byte[] by = new byte[len]; int index = 0; for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123; String strByte; if (i + 8 &gt; stringBuilder.length()) &#123; strByte = stringBuilder.substring(i); by[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; else &#123; strByte = stringBuilder.substring(i, i + 8); by[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; &#125; return by; &#125; static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;(); static StringBuilder stringBuilder = new StringBuilder(); //重载 private static Map&lt;Byte, String&gt; getCodes(Node root) &#123; if (root == null) &#123; return null; &#125; getCodes(root.left, \"0\", stringBuilder); getCodes(root.right, \"1\", stringBuilder); return huffmanCodes; &#125; //获取哈夫曼编码 private static void getCodes(Node node, String code, StringBuilder stringBuilder) &#123; StringBuilder builder = new StringBuilder(stringBuilder); builder.append(code); if (node != null) &#123; if (node.data == null) &#123; //递归 getCodes(node.left, \"0\", builder); getCodes(node.right, \"1\", builder); &#125; else &#123; huffmanCodes.put(node.data, builder.toString()); &#125; &#125; &#125; //前序遍历 private static void preOrder(Node root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println(\"哈夫曼树为空\"); &#125; &#125; //生成哈夫曼树 private static Node createHuffmanTree(List&lt;Node&gt; nodes) &#123; while (nodes.size() &gt; 1) &#123; Collections.sort(nodes); Node leftNode = nodes.get(0); Node rightNode = nodes.get(1); Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); &#125; return nodes.get(0); &#125; //接收字节数组 private static List&lt;Node&gt; getNodes(byte[] bytes) &#123; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; Integer count = counts.get(b); if (count == null) &#123; counts.put(b, 1); &#125; else &#123; counts.put(b, count + 1); &#125; &#125; //遍历map for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new Node(entry.getKey(), entry.getValue())); &#125; return nodes; &#125;&#125;class Node implements Comparable&lt;Node&gt; &#123; Byte data; int weight; //字符出现的次数 Node left; Node right; //前序遍历 public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; public Node(Byte data, int weight) &#123; this.data = data; this.weight = weight; &#125; @Override public int compareTo(Node o) &#123; //从小到大排序 return this.weight - o.weight; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"data=\" + data + \", weight=\" + weight + '&#125;'; &#125;&#125; 解压思路 将字节数组转化为二进制 根据反转的哈夫曼编码表生成ASCLL集合 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231package cn.guizimo.huffmancode;import java.util.*;/** * @author guizimo * @date 2020/8/8 11:55 上午 */public class HuffmanCode &#123; public static void main(String[] args) &#123; String content = \"i like like like java do you like a java\"; byte[] contentBytes = content.getBytes(); //哈夫曼压缩 byte[] zip = huffmanZip(contentBytes); System.out.println(\"哈夫曼压缩：\" + Arrays.toString(zip)); //哈夫曼解压 byte[] unzip = huffmanUnzip(huffmanCodes, zip); System.out.println(\"哈夫曼解压：\" + new String(unzip)); &#125; //哈夫曼解压 private static byte[] huffmanUnzip(Map&lt;Byte, String&gt; huffmanCodes, byte[] huffmanBytes) &#123; StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; huffmanBytes.length; i++) &#123; byte b = huffmanBytes[i]; boolean flag = (i == huffmanBytes.length - 1); stringBuilder.append(byteToBitString(!flag, b)); &#125; //解码,反向编码表 HashMap&lt;String, Byte&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123; map.put(entry.getValue(), entry.getKey()); &#125; //根据编码扫描到对应的ASCLL码对应的字符 List&lt;Byte&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; stringBuilder.length(); ) &#123; int count = 1; boolean flag = true; Byte b = null; while (flag) &#123; String key = stringBuilder.substring(i, i + count); b = map.get(key); if (b == null) &#123; count++; &#125; else &#123; flag = false; &#125; &#125; list.add(b); i += count; &#125; byte b[] = new byte[list.size()]; for (int i = 0; i &lt; b.length; i++) &#123; b[i] = list.get(i); &#125; return b; &#125; //转化二进制 private static String byteToBitString(boolean flag, byte b) &#123; int temp = b; if (flag) &#123; temp |= 256; &#125; String str = Integer.toBinaryString(temp); if (flag) &#123; return str.substring(str.length() - 8); &#125; else &#123; return str; &#125; &#125; //哈夫曼编码压缩 private static byte[] huffmanZip(byte[] bytes) &#123; List&lt;Node&gt; nodes = getNodes(bytes); //哈夫曼树 Node huffmanTree = createHuffmanTree(nodes); //哈夫曼编码表 Map&lt;Byte, String&gt; huffmanCodes = getCodes(huffmanTree); //哈夫曼编码 byte[] zip = zip(bytes, huffmanCodes); return zip; &#125; //压缩 private static byte[] zip(byte[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123; StringBuilder stringBuilder = new StringBuilder(); for (byte b : bytes) &#123; stringBuilder.append(huffmanCodes.get(b)); &#125; int len; if (stringBuilder.length() % 8 == 0) &#123; len = stringBuilder.length() / 8; &#125; else &#123; len = stringBuilder.length() / 8 + 1; &#125; byte[] by = new byte[len]; int index = 0; for (int i = 0; i &lt; stringBuilder.length(); i += 8) &#123; String strByte; if (i + 8 &gt; stringBuilder.length()) &#123; strByte = stringBuilder.substring(i); by[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; else &#123; strByte = stringBuilder.substring(i, i + 8); by[index] = (byte) Integer.parseInt(strByte, 2); index++; &#125; &#125; return by; &#125; static Map&lt;Byte, String&gt; huffmanCodes = new HashMap&lt;Byte, String&gt;(); static StringBuilder stringBuilder = new StringBuilder(); //重载 private static Map&lt;Byte, String&gt; getCodes(Node root) &#123; if (root == null) &#123; return null; &#125; getCodes(root.left, \"0\", stringBuilder); getCodes(root.right, \"1\", stringBuilder); return huffmanCodes; &#125; //获取哈夫曼编码 private static void getCodes(Node node, String code, StringBuilder stringBuilder) &#123; StringBuilder builder = new StringBuilder(stringBuilder); builder.append(code); if (node != null) &#123; if (node.data == null) &#123; //递归 getCodes(node.left, \"0\", builder); getCodes(node.right, \"1\", builder); &#125; else &#123; huffmanCodes.put(node.data, builder.toString()); &#125; &#125; &#125; //前序遍历 private static void preOrder(Node root) &#123; if (root != null) &#123; root.preOrder(); &#125; else &#123; System.out.println(\"哈夫曼树为空\"); &#125; &#125; //生成哈夫曼树 private static Node createHuffmanTree(List&lt;Node&gt; nodes) &#123; while (nodes.size() &gt; 1) &#123; Collections.sort(nodes); Node leftNode = nodes.get(0); Node rightNode = nodes.get(1); Node parent = new Node(null, leftNode.weight + rightNode.weight); parent.left = leftNode; parent.right = rightNode; nodes.remove(leftNode); nodes.remove(rightNode); nodes.add(parent); &#125; return nodes.get(0); &#125; //接收字节数组 private static List&lt;Node&gt; getNodes(byte[] bytes) &#123; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); Map&lt;Byte, Integer&gt; counts = new HashMap&lt;&gt;(); for (byte b : bytes) &#123; Integer count = counts.get(b); if (count == null) &#123; counts.put(b, 1); &#125; else &#123; counts.put(b, count + 1); &#125; &#125; //遍历map for (Map.Entry&lt;Byte, Integer&gt; entry : counts.entrySet()) &#123; nodes.add(new Node(entry.getKey(), entry.getValue())); &#125; return nodes; &#125;&#125;class Node implements Comparable&lt;Node&gt; &#123; Byte data; int weight; //字符出现的次数 Node left; Node right; //前序遍历 public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; public Node(Byte data, int weight) &#123; this.data = data; this.weight = weight; &#125; @Override public int compareTo(Node o) &#123; //从小到大排序 return this.weight - o.weight; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"data=\" + data + \", weight=\" + weight + '&#125;'; &#125;&#125; 测试 感谢 尚硅谷 以及勤劳的自己","categories":[],"tags":[]},{"title":"数据结构—哈夫曼树（Java）","slug":"数据结构—哈夫曼树（Java）","date":"2020-08-08T03:28:35.000Z","updated":"2020-08-08T03:28:35.000Z","comments":true,"path":"2020/08/08/数据结构—哈夫曼树（Java）/","link":"","permalink":"https://tangleia.github.io/2020/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构—哈夫曼树（Java）","text":"数据结构—哈夫曼树（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明 给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree) 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。 树的带权路径长度：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL(weighted path length) ,权值越大的结点离根结点越近的二叉树才是最优二叉树。 WPL最小的就是赫夫曼树 思路 从小到大进行排序, 将每一个数据，每个数据都是一个节点 ， 每个节点可以看成是一颗最简单的二叉树取出根节点权值最小的两颗二叉树 组成一颗新的二叉树, 该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和 再将这颗新的二叉树，以根节点的权值大小 再次排序 不断重复 1-2-3-4 的步骤，直到数列中，所有的数据都被处理，就得到一颗赫夫曼树 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192package cn.guizimo.huffmantree;import java.util.ArrayList;import java.util.Collections;import java.util.List;/** * @author guizimo * @date 2020/8/8 11:01 上午 */public class HuffmanTree &#123; public static void main(String[] args) &#123; int arr[] = &#123;13, 7, 8, 3, 29, 6, 1&#125;; Node root = createHuffmanTree(arr); System.out.println(\"哈夫曼树前序遍历：\"); preOrder(root); &#125; //前序遍历 public static void preOrder(Node root)&#123; if(root != null)&#123; root.preOrder(); &#125;else &#123; System.out.println(\"空树\"); &#125; &#125; public static Node createHuffmanTree(int[] arr) &#123; List&lt;Node&gt; nodes = new ArrayList&lt;&gt;(); for (int value : arr) &#123; nodes.add(new Node(value)); &#125; while (nodes.size() &gt; 1) &#123; //使用集合排序 Collections.sort(nodes); //获取左右子节点 Node leftNode = nodes.get(0); Node rightNode = nodes.get(1); //构建子树 Node parent = new Node(leftNode.value + rightNode.value); parent.left = leftNode; parent.right = rightNode; //删除已使用的子节点 nodes.remove(leftNode); nodes.remove(rightNode); //将新的子树的根节点放入集合 nodes.add(parent); &#125; //返回根节点 return nodes.get(0); &#125;&#125;//节点class Node implements Comparable&lt;Node&gt; &#123; int value; Node left; Node right; //前序遍历 public void preOrder()&#123; System.out.println(this); if(this.left != null)&#123; this.left.preOrder(); &#125; if(this.right != null)&#123; this.right.preOrder(); &#125; &#125; public Node(int value) &#123; this.value = value; &#125; @Override public String toString() &#123; return \"Node&#123;\" + \"value=\" + value + '&#125;'; &#125; @Override public int compareTo(Node o) &#123; //从小到大排序 return this.value - o.value; &#125;&#125; 测试 感谢 尚硅谷 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–替换空格","slug":"LeetCode–替换空格","date":"2020-08-08T02:45:51.000Z","updated":"2020-08-08T02:48:58.000Z","comments":true,"path":"2020/08/08/LeetCode–替换空格/","link":"","permalink":"https://tangleia.github.io/2020/08/08/LeetCode%E2%80%93%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","excerpt":"LeetCode–替换空格","text":"LeetCode–替换空格 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明剑指 Offer 05. 替换空格 题目请实现一个函数，把字符串 s 中的每个空格替换成”%20”。 示例 1： 12输入：s &#x3D; &quot;We are happy.&quot;输出：&quot;We%20are%20happy.&quot; 限制： 10 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000 Java思路字符串是不可以改变的，只能新建一个字符串，由空格变为%20，是从一个字符到了三个字符，在初始化数组的时候需要把长度加大 代码12345678910111213141516171819class Solution &#123; public String replaceSpace(String s) &#123; int length = s.length(); char[] array = new char[length*3]; int len = 0; for(int i = 0; i &lt; length; i++)&#123; char c = s.charAt(i); if(c == ' ')&#123; array[len++] = '%'; array[len++] = '2'; array[len++] = '0'; &#125;else&#123; array[len++] = c; &#125; &#125; String res = new String(array,0,len); return res; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–绘制直线","slug":"LeetCode–绘制直线","date":"2020-08-08T02:21:07.000Z","updated":"2020-08-08T02:21:07.000Z","comments":true,"path":"2020/08/08/LeetCode–绘制直线/","link":"","permalink":"https://tangleia.github.io/2020/08/08/LeetCode%E2%80%93%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF/","excerpt":"LeetCode–绘制直线","text":"LeetCode–绘制直线 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明面试题 05.08. 绘制直线 题目绘制直线。有个单色屏幕存储在一个一维数组中，使得32个连续像素可以存放在一个 int 里。屏幕宽度为w，且w可被32整除（即一个 int 不会分布在两行上），屏幕高度可由数组长度及屏幕宽度推算得出。请实现一个函数，绘制从点(x1, y)到点(x2, y)的水平线。 给出数组的长度 length，宽度 w（以比特为单位）、直线开始位置 x1（比特为单位）、直线结束位置 x2（比特为单位）、直线所在行数 y。返回绘制过后的数组。 示例1: 123输入：length &#x3D; 1, w &#x3D; 32, x1 &#x3D; 30, x2 &#x3D; 31, y &#x3D; 0输出：[3]说明：在第0行的第30位到第31为画一条直线，屏幕表示为[0b000000000000000000000000000000011] 示例2: 12输入：length &#x3D; 3, w &#x3D; 96, x1 &#x3D; 0, x2 &#x3D; 95, y &#x3D; 0输出：[-1, -1, -1] Java思路使用位运算 代码1234567891011121314class Solution &#123; public int[] drawLine(int length, int w, int x1, int x2, int y) &#123; int[] res = new int[length]; int temp = y * w / 32; int head = x1 / 32 + temp; int rear = x2 / 32 + temp; for(int i = head; i &lt;= rear; i++)&#123; res[i] = -1; &#125; res[head] = res[head] &amp; -1 &gt;&gt;&gt; x1 % 32; res[rear] = res[rear] &amp; Integer.MIN_VALUE &gt;&gt; x2 % 32; return res; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–T9键盘","slug":"LeetCode–T9键盘","date":"2020-08-08T01:37:08.000Z","updated":"2020-08-08T01:37:08.000Z","comments":true,"path":"2020/08/08/LeetCode–T9键盘/","link":"","permalink":"https://tangleia.github.io/2020/08/08/LeetCode%E2%80%93T9%E9%94%AE%E7%9B%98/","excerpt":"LeetCode–T9键盘","text":"LeetCode–T9键盘 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明面试题 16.20. T9键盘 题目在老式手机上，用户通过数字键盘输入，手机将提供与这些数字相匹配的单词列表。每个数字映射到0至4个字母。给定一个数字序列，实现一个算法来返回匹配单词的列表。你会得到一张含有有效单词的列表。映射如下图所示： 示例 1: 12输入: num &#x3D; &quot;8733&quot;, words &#x3D; [&quot;tree&quot;, &quot;used&quot;]输出: [&quot;tree&quot;, &quot;used&quot;] 示例 2: 12输入: num &#x3D; &quot;2&quot;, words &#x3D; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]输出: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 提示： 1234num.length &lt;&#x3D; 1000words.length &lt;&#x3D; 500words[i].length &#x3D;&#x3D; num.lengthnum中不会出现 0, 1 这两个数字 Java思路将26个字母按顺序将对应的数字存入数组，再比对输入的数字是否符合 代码123456789101112131415161718192021class Solution &#123; public List&lt;String&gt; getValidT9Words(String num, String[] words) &#123; List&lt;String&gt; res = new ArrayList&lt;&gt;(); char[] map = &#123;'2','2','2','3','3','3','4','4','4','5','5','5','6','6','6','7','7','7','7','8','8','8','9','9','9','9'&#125;; for(String word : words)&#123; int index = 0; boolean flag = true; for(char c : word.toCharArray())&#123; char n = map[c-'a']; if(n != num.charAt(index++))&#123; flag = false; break; &#125; &#125; if(flag)&#123; res.add(word); &#125; &#125; return res; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–0～n-1中缺失的数字","slug":"LeetCode–0～n-1中缺失的数字","date":"2020-08-07T12:37:54.000Z","updated":"2020-08-07T12:37:54.000Z","comments":true,"path":"2020/08/07/LeetCode–0～n-1中缺失的数字/","link":"","permalink":"https://tangleia.github.io/2020/08/07/LeetCode%E2%80%930%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"LeetCode–0～n-1中缺失的数字","text":"LeetCode–0～n-1中缺失的数字 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明剑指offer，53-II 0～n-1中缺失的数字 题目一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 1： 12输入: [0,1,3]输出: 2 示例 2： 12输入: [0,1,2,3,4,5,6,7,9]输出: 8 Java思路判断下标是否为当前的数，不是直接返回 代码12345678910class Solution &#123; public int missingNumber(int[] nums) &#123; for(int i = 0;i&lt;nums.length;i++)&#123; if(nums[i] != i)&#123; return i; &#125; &#125; return nums.length; &#125;&#125; 思路使用二分法 代码123456789101112131415class Solution &#123; public int missingNumber(int[] nums) &#123; int i = 0; int j = nums.length - 1; while(i &lt;= j)&#123; int m = (i+j)/2; if(nums[m] == m)&#123; i = m + 1; &#125;else&#123; j = m - 1; &#125; &#125; return i; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–井字游戏","slug":"LeetCode–井字游戏","date":"2020-08-07T12:05:09.000Z","updated":"2020-08-07T12:36:44.000Z","comments":true,"path":"2020/08/07/LeetCode–井字游戏/","link":"","permalink":"https://tangleia.github.io/2020/08/07/LeetCode%E2%80%93%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F/","excerpt":"LeetCode–井字游戏","text":"LeetCode–井字游戏 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明剑指offer，面试16.04 井字游戏 题目设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符” “，”X”和”O”组成，其中字符” “代表一个空位。 以下是井字游戏的规则： 玩家轮流将字符放入空位（” “）中。 第一个玩家总是放字符”O”，且第二个玩家总是放字符”X”。 “X”和”O”只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（”X”或”O”）；如果游戏以平局结束，则返回 “Draw”；如果仍会有行动（游戏未结束），则返回 “Pending”。 示例 1： 12输入： board &#x3D; [&quot;O X&quot;,&quot; XO&quot;,&quot;X O&quot;]输出： &quot;X&quot; 示例 2： 123输入： board &#x3D; [&quot;OOX&quot;,&quot;XXO&quot;,&quot;OXO&quot;]输出： &quot;Draw&quot;解释： 没有玩家获胜且不存在空位 示例 3： 123输入： board &#x3D; [&quot;OOX&quot;,&quot;XXO&quot;,&quot;OX &quot;]输出： &quot;Pending&quot;解释： 没有玩家获胜且仍存在空位 提示： 121 &lt;&#x3D; board.length &#x3D;&#x3D; board[i].length &lt;&#x3D; 100输入一定遵循井字棋规则 Java思路使用求和的方法，获取到横、纵、对角线的值，判断对应的值是否达成了全部一致 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public String tictactoe(String[] board) &#123; int length = board.length; int heng = 0; int zong = 0; int left = 0; int right = 0; //是否出现空格 boolean flag = false; for(int i = 0;i&lt;length;i++)&#123; heng = 0; zong = 0; for(int j = 0;j&lt;length;j++)&#123; //记录横纵的值 heng = heng + (int)board[i].charAt(j); zong = zong + (int)board[j].charAt(i); if(board[i].charAt(j) == ' ')&#123; flag = true; &#125; &#125; //检查横纵 if(heng == (int)'X' * length || zong == (int)'X' * length)&#123; return \"X\"; &#125; if(heng == (int)'O' * length || zong == (int)'O' * length)&#123; return \"O\"; &#125; //记录斜线的值 left = left + board[i].charAt(i); right = right + board[i].charAt(length-i-1); &#125; //检查对角线 if(left == (int)'X' * length || right == (int)'X' * length)&#123; return \"X\"; &#125; if(left == (int)'O' * length || right == (int)'O' * length)&#123; return \"O\"; &#125; if(flag)&#123; return \"Pending\"; &#125; return \"Draw\"; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"选择排序之堆排序（Java）","slug":"选择排序之堆排序（Java）","date":"2020-08-07T10:52:04.000Z","updated":"2020-08-07T10:52:04.000Z","comments":true,"path":"2020/08/07/选择排序之堆排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/08/07/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"选择排序之堆排序（Java）","text":"选择排序之堆排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。 堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆 大顶堆特点：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] i 对应第几个节点，i从0开始编号 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 小顶堆特点：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2] i 对应第几个节点，i从0开始编号 一般升序采用大顶堆，降序采用小顶堆 思路 将待排序序列构造成一个大顶堆 此时，整个序列的最大值就是堆顶的根节点。 将其与末尾元素进行交换，此时末尾就为最大值。 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.guizimo.tree;import java.util.Arrays;/** * @author guizimo * @date 2020/8/7 11:43 上午 */public class HeapSort &#123; public static void main(String[] args) &#123; int max = 8000000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); heapSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"堆排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void heapSort(int arr[]) &#123; int temp = 0; for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; adjustHeap(arr,i,arr.length); &#125; //交换 for (int j = arr.length-1;j&gt;0;j--)&#123; temp = arr[j]; arr[j] = arr[0]; arr[0] = temp; adjustHeap(arr,0,j); &#125; //System.out.println(Arrays.toString(arr)); &#125; //将数组变为大顶推 public static void adjustHeap(int arr[], int i, int length) &#123; int temp = arr[i]; for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) &#123; if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) &#123; k++; &#125; if (arr[k] &gt; temp) &#123; arr[i] = arr[k]; i = k; &#125; else &#123; break; &#125; &#125; arr[i] = temp; &#125;&#125; 测试 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"数据结构--线索化二叉树（Java）","slug":"数据结构--线索化二叉树（Java）","date":"2020-08-07T03:22:45.000Z","updated":"2020-08-07T03:22:45.000Z","comments":true,"path":"2020/08/07/数据结构--线索化二叉树（Java）/","link":"","permalink":"https://tangleia.github.io/2020/08/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E7%BA%BF%E7%B4%A2%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构–线索化二叉树（Java）","text":"数据结构–线索化二叉树（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明 n个结点的二叉链表中含有n+1 【公式 2n-(n-1)=n+1】 个空指针域。利用二叉链表中的空指针域，存放指向该结点在某种遍历次序下的前驱和后继结点的指针（这种附加的指针称为”线索”） 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种 一个结点的前一个结点，称为前驱结点 一个结点的后一个结点，称为后继结点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342package cn.guizimo.thread.tree;/** * @author guizimo * @date 2020/8/7 11:08 上午 */public class ThreadTree &#123; public static void main(String[] args) &#123; //设置节点 HeroNode root = new HeroNode(1, \"tom\"); HeroNode node2 = new HeroNode(3, \"jack\"); HeroNode node3 = new HeroNode(6, \"smith\"); HeroNode node4 = new HeroNode(8, \"mary\"); HeroNode node5 = new HeroNode(10, \"king\"); HeroNode node6 = new HeroNode(14, \"dim\"); //设置二叉树 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node2.setRight(node5); node3.setLeft(node6); //线索化 ThreadedBinaryTree threadedBinaryTree = new ThreadedBinaryTree(); threadedBinaryTree.setRoot(root); threadedBinaryTree.threadedNodes(); //遍历 threadedBinaryTree.threadedList(); &#125;&#125;/** * 二叉树 */class ThreadedBinaryTree &#123; //根节点 private HeroNode root; //辅助节点 private HeroNode pre = null; public void setRoot(HeroNode root) &#123; this.root = root; &#125; public void threadedNodes() &#123; this.threadedNodes(root); &#125; //中序遍历 public void threadedList() &#123; HeroNode node = root; while (node != null) &#123; while (node.getLeftType() == 0) &#123; node = node.getLeft(); &#125; System.out.println(node); while (node.getRightType() == 1) &#123; node = node.getRight(); System.out.println(node); &#125; node = node.getRight(); &#125; &#125; //线索化 public void threadedNodes(HeroNode node) &#123; if(node == null) &#123; return; &#125; threadedNodes(node.getLeft()); if(node.getLeft() == null) &#123; node.setLeft(pre); node.setLeftType(1); &#125; if (pre != null &amp;&amp; pre.getRight() == null) &#123; pre.setRight(node); pre.setRightType(1); &#125; pre = node; threadedNodes(node.getRight()); &#125; //删除二叉树的节点 public void delNode(int no) &#123; if (root != null) &#123; if (root.getNo() == no) &#123; root = null; &#125; else &#123; root.delNode(no); &#125; &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //前序 public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //中序 public void infixOrder() &#123; if (this.root != null) &#123; this.root.infixOrder(); &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //后序 public void postOrder() &#123; if (this.root != null) &#123; this.root.postOrder(); &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //前序查找 public HeroNode preOrderSearch(int no) &#123; if (root != null) &#123; return root.preOrderSearch(no); &#125; else &#123; return null; &#125; &#125; //中序查找 public HeroNode infixOrderSearch(int no) &#123; if (root != null) &#123; return root.infixOrderSearch(no); &#125; else &#123; return null; &#125; &#125; //后序查找 public HeroNode postOrderSearch(int no) &#123; if (root != null) &#123; return this.root.postOrderSearch(no); &#125; else &#123; return null; &#125; &#125;&#125;/** * 节点 */class HeroNode &#123; private int no; private String name; private HeroNode left; private HeroNode right; public int getLeftType() &#123; return leftType; &#125; public void setLeftType(int leftType) &#123; this.leftType = leftType; &#125; public int getRightType() &#123; return rightType; &#125; public void setRightType(int rightType) &#123; this.rightType = rightType; &#125; private int leftType; private int rightType; public HeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return \"HeroNode&#123;\" + \"no=\" + no + \", name='\" + name + '\\'' + '&#125;'; &#125; //删除节点 public void delNode(int no) &#123; //判读左节点是否为空，找到 if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; //判断右节点，找到 if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; //判断左节点，未找到，递归 if (this.left != null) &#123; this.left.delNode(no); &#125; //判断右节点，未找到，递归 if (this.right != null) &#123; this.right.delNode(no); &#125; &#125; //前序 public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; //中序 public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; //后序 public void postOrder() &#123; if (this.left != null) &#123; this.left.postOrder(); &#125; if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this); &#125; //前序遍历查找 public HeroNode preOrderSearch(int no) &#123; if (this.no == no) &#123; return this; &#125; HeroNode resNode = null; //判断左子树 if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; //判断右子树 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; //中序遍历查找 public HeroNode infixOrderSearch(int no) &#123; HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.no == no) &#123; return this; &#125; if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; //后序遍历查找 public HeroNode postOrderSearch(int no) &#123; HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.no == no) &#123; return this; &#125; return resNode; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"数据结构--数组存储二叉树（Java）","slug":"数据结构--数组存储二叉树（Java）","date":"2020-08-05T03:39:21.000Z","updated":"2020-08-05T03:39:21.000Z","comments":true,"path":"2020/08/05/数据结构--数组存储二叉树（Java）/","link":"","permalink":"https://tangleia.github.io/2020/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E6%95%B0%E7%BB%84%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构–数组存储二叉树（Java）","text":"数据结构–数组存储二叉树（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 顺序存储二叉树的特点 顺序二叉树通常只考虑完全二叉树 第n个元素的左子节点为 2 * n + 1 第n个元素的右子节点为 2 * n + 2 第n个元素的父节点为 (n-1) / 2 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package cn.guizimo.tree;/** * @author guizimo * @date 2020/8/5 11:09 上午 */public class ArrTree &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 2, 3, 4, 5, 6, 7&#125;; ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr); arrBinaryTree.preOrder(); &#125;&#125;class ArrBinaryTree &#123; private int[] arr; public ArrBinaryTree(int[] arr) &#123; this.arr = arr; &#125; public void preOrder()&#123; this.preOrder(0); &#125; //前序 public void preOrder(int index) &#123; if (arr == null || arr.length == 0) &#123; System.out.println(\"数组为空\"); &#125; System.out.println(arr[index]); //左递归 if ((index * 2 + 1) &lt; arr.length) &#123; preOrder(2 * index + 1); &#125; //右递归 if ((index * 2 + 2) &lt; arr.length) &#123; preOrder(2 * index + 2); &#125; &#125; //中序 public void preOrder(int index) &#123; if (arr == null || arr.length == 0) &#123; System.out.println(\"数组为空\"); &#125; //左递归 if ((index * 2 + 1) &lt; arr.length) &#123; preOrder(2 * index + 1); &#125; System.out.println(arr[index]); //右递归 if ((index * 2 + 2) &lt; arr.length) &#123; preOrder(2 * index + 2); &#125; &#125; //后序 public void preOrder(int index) &#123; if (arr == null || arr.length == 0) &#123; System.out.println(\"数组为空\"); &#125; //左递归 if ((index * 2 + 1) &lt; arr.length) &#123; preOrder(2 * index + 1); &#125; //右递归 if ((index * 2 + 2) &lt; arr.length) &#123; preOrder(2 * index + 2); &#125; System.out.println(arr[index]); &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"数据结构--二叉树（Java）","slug":"数据结构--二叉树（Java）","date":"2020-07-29T14:52:58.000Z","updated":"2020-07-29T14:57:44.000Z","comments":true,"path":"2020/07/29/数据结构--二叉树（Java）/","link":"","permalink":"https://tangleia.github.io/2020/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构–二叉树（Java）","text":"数据结构–二叉树（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 树的常用术语(结合示意图理解) 节点 根节点 父节点 子节点 叶子节点 (没有子节点的节点) 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数) 森林 :多颗子树构成森林 树存储方式优势能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度 二叉树的概念 每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树 遍历 前序遍历: 先输出父节点，再遍历左子树和右子树 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281package cn.guizimo.tree;/** * @author guizimo * @date 2020/7/29 8:03 下午 */public class TreeDemo &#123; public static void main(String[] args) &#123; BinaryTree binaryTree = new BinaryTree(); HeroNode root = new HeroNode(1, \"宋江\"); HeroNode node2 = new HeroNode(2, \"李逵\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"吴用\"); HeroNode node5 = new HeroNode(5, \"林冲\"); HeroNode node6 = new HeroNode(6, \"鲁智深\"); //创建二叉树 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node3.setLeft(node5); node3.setRight(node6); binaryTree.setRoot(root); //前序遍历// HeroNode heroNode = binaryTree.preOrderSearch(5);// System.out.println(heroNode); &#125;&#125;/** * 二叉树 */class BinaryTree &#123; //根节点 private HeroNode root; public void setRoot(HeroNode root) &#123; this.root = root; &#125; //删除二叉树的节点 public void delNode(int no) &#123; if (root != null) &#123; if (root.getNo() == no) &#123; root = null; &#125; else &#123; root.delNode(no); &#125; &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //前序 public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //中序 public void infixOrder() &#123; if (this.root != null) &#123; this.root.infixOrder(); &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //后序 public void postOrder() &#123; if (this.root != null) &#123; this.root.postOrder(); &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //前序查找 public HeroNode preOrderSearch(int no) &#123; if (root != null) &#123; return root.preOrderSearch(no); &#125; else &#123; return null; &#125; &#125; //中序查找 public HeroNode infixOrderSearch(int no) &#123; if (root != null) &#123; return root.infixOrderSearch(no); &#125; else &#123; return null; &#125; &#125; //后序查找 public HeroNode postOrderSearch(int no) &#123; if (root != null) &#123; return this.root.postOrderSearch(no); &#125; else &#123; return null; &#125; &#125;&#125;/** * 节点 */class HeroNode &#123; private int no; private String name; private HeroNode left; private HeroNode right; public HeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return \"HeroNode&#123;\" + \"no=\" + no + \", name='\" + name + '\\'' + '&#125;'; &#125; //删除节点 public void delNode(int no) &#123; //判读左节点是否为空，找到 if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; //判断右节点，找到 if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; //判断左节点，未找到，递归 if (this.left != null) &#123; this.left.delNode(no); &#125; //判断右节点，未找到，递归 if (this.right != null) &#123; this.right.delNode(no); &#125; &#125; //前序 public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; //中序 public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; //后序 public void postOrder() &#123; if (this.left != null) &#123; this.left.postOrder(); &#125; if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this); &#125; //前序遍历查找 public HeroNode preOrderSearch(int no) &#123; if (this.no == no) &#123; return this; &#125; HeroNode resNode = null; //判断左子树 if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; //判断右子树 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; //中序遍历查找 public HeroNode infixOrderSearch(int no) &#123; HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.no == no) &#123; return this; &#125; if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; //后序遍历查找 public HeroNode postOrderSearch(int no) &#123; HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.no == no) &#123; return this; &#125; return resNode; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"数据结构--哈希表（Java）","slug":"数据结构--哈希表（Java）","date":"2020-07-23T15:34:53.000Z","updated":"2020-07-29T15:09:44.000Z","comments":true,"path":"2020/07/23/数据结构--哈希表（Java）/","link":"","permalink":"https://tangleia.github.io/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构–哈希表（Java）","text":"数据结构–哈希表（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍哈希表底层是数组加链表或者是数组加二叉树，一个数组里面有多个链表，通过散列函数来提高效率 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package cn.guizimo.hashtab;import java.util.Scanner;/** * @author guizimo * @date 2020/7/23 10:29 下午 */public class HashTabDemo &#123; public static void main(String[] args) &#123; HashTab hashTab = new HashTab(7); String key = \"\"; Scanner scanner = new Scanner(System.in); while (true)&#123; System.out.println(\"add:添加\"); System.out.println(\"list:显示\"); System.out.println(\"find:显示\"); System.out.println(\"exit:退出\"); key = scanner.next(); switch (key)&#123; case \"add\": System.out.println(\"输入id\"); int id = scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); Emp emp = new Emp(id, name); hashTab.add(emp); break; case \"list\": hashTab.list(); break; case \"find\": System.out.println(\"请输入id\"); id = scanner.nextInt(); hashTab.find(id); break; case \"exit\": scanner.close(); System.exit(0); default: break; &#125; &#125; &#125;&#125;class Emp&#123; public int id; public String name; public Emp next; public Emp(int id, String name) &#123; super(); this.id = id; this.name = name; &#125;&#125;//哈希表class HashTab&#123; private EmpLinkedList[] empLinkedListArray; private int size; //构造器 public HashTab(int size)&#123; this.size = size; empLinkedListArray = new EmpLinkedList[size]; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i] = new EmpLinkedList(); &#125; &#125; //添加 public void add(Emp emp)&#123; int empLinkedListNo = hashFun(emp.id); empLinkedListArray[empLinkedListNo].add(emp); &#125; public void find(int id)&#123; int empLinkedListNo = hashFun(id); Emp emp = empLinkedListArray[empLinkedListNo].find(id); if (emp != null)&#123; System.out.printf(\"在第%d条链表中找到id=%d\\n\",(empLinkedListNo+1),id); &#125;else &#123; System.out.println(\"没有找到\"); &#125; &#125; //遍历 public void list()&#123; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i].list(i); &#125; &#125; //散列(取模) public int hashFun(int id)&#123; return id % size; &#125;&#125;class EmpLinkedList&#123; private Emp head; public void add(Emp emp)&#123; if(head == null)&#123; head = emp; return; &#125; Emp curEmp = head; while (true)&#123; if(curEmp.next == null)&#123; break; &#125; curEmp = curEmp.next; &#125; curEmp.next = emp; &#125; public void list(int no)&#123; if(head == null)&#123; System.out.println(\"第\"+(no+1)+\"条链表为空\"); return; &#125; System.out.print(\"第\"+(no+1)+\"条链表信息\"); Emp curemp = head; while (true)&#123; System.out.printf(\"id=%d,name=%s\\t\",curemp.id,curemp.name); if(curemp.next == null)&#123; break; &#125; curemp = curemp.next; &#125; System.out.println(); &#125; public Emp find(int id)&#123; if(head == null)&#123; System.out.println(\"链表为空\"); return null; &#125; Emp curEmp = head; while (true)&#123; if(curEmp.id == id)&#123; break; &#125; if(curEmp.next == null)&#123; curEmp = null; break; &#125; curEmp = curEmp.next; &#125; return curEmp; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"查找--斐波那契查找（Java）","slug":"查找--斐波那契查找（Java）","date":"2020-07-23T14:28:45.000Z","updated":"2020-07-29T15:25:31.000Z","comments":true,"path":"2020/07/23/查找--斐波那契查找（Java）/","link":"","permalink":"https://tangleia.github.io/2020/07/23/%E6%9F%A5%E6%89%BE--%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%EF%BC%88Java%EF%BC%89/","excerpt":"查找–斐波那契查找（Java）","text":"查找–斐波那契查找（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618 思路利用斐波那契数列的特性来查找mid 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.guizimo.search;import java.util.Arrays;/** * @author guizimo * @date 2020/7/23 10:06 下午 */public class FibonacciSearch &#123; public static int maxSize = 20; public static void main(String[] args) &#123; int[] arr = &#123;1, 8, 10, 89, 100, 1000&#125;; System.out.println(fibSearch(arr,8)); &#125; //斐波那契数列 public static int[] fib() &#123; int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; maxSize; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f; &#125; public static int fibSearch(int[] a, int key) &#123; int low = 0; int high = a.length - 1; int k = 0; int mid = 0; int f[] = fib(); while (high &gt; f[k] - 1) &#123; k++; &#125; int[] temp = Arrays.copyOf(a, f[k]); for (int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = a[high]; &#125; while (low &lt;= high) &#123; mid = low + f[k - 1] - 1; if (key &lt; temp[mid]) &#123; high = mid - 1; k--; &#125; else if (key &gt; temp[mid]) &#123; low = mid + 1; k -= 2; &#125; else &#123; if (mid &lt;= high) &#123; return mid; &#125; else &#123; return high; &#125; &#125; &#125; return -1; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"牛客网--字节跳动面试题--特征提取","slug":"牛客网--字节跳动面试题--特征提取","date":"2020-07-18T07:03:01.000Z","updated":"2020-07-29T15:08:02.000Z","comments":true,"path":"2020/07/18/牛客网--字节跳动面试题--特征提取/","link":"","permalink":"https://tangleia.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%E7%BD%91--%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98--%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/","excerpt":"牛客网–字节跳动面试题–特征提取","text":"牛客网–字节跳动面试题–特征提取 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 来源链接：特征提取 来源：牛客网 题目小明是一名算法工程师，同时也是一名铲屎官。某天，他突发奇想，想从猫咪的视频里挖掘一些猫咪的运动信息。为了提取运动信息，他需要从视频的每一帧提取“猫咪特征”。一个猫咪特征是一个两维的vector&lt;x, y&gt;。如果x_1=x_2 and y_1=y_2，那么这俩是同一个特征。 因此，如果喵咪特征连续一致，可以认为喵咪在运动。也就是说，如果特征&lt;a, b&gt;在持续帧里出现，那么它将构成特征运动。比如，特征&lt;a, b&gt;在第2/3/4/7/8帧出现，那么该特征将形成两个特征运动2-3-4 和7-8。 现在，给定每一帧的特征，特征的数量可能不一样。小明期望能找到最长的特征运动。 输入描述:123456789第一行包含一个正整数N，代表测试用例的个数。每个测试用例的第一行包含一个正整数M，代表视频的帧数。接下来的M行，每行代表一帧。其中，第一个数字是该帧的特征个数，接下来的数字是在特征的取值；比如样例输入第三行里，2代表该帧有两个猫咪特征，&lt;1，1&gt;和&lt;2，2&gt;所有用例的输入特征总数和&lt;100000N满足1≤N≤100000，M满足1≤M≤10000，一帧的特征个数满足 ≤ 10000。特征取值均为非负整数。 输出描述:1对每一个测试用例，输出特征运动的长度作为一行 输入例子1:12345678910182 1 1 2 22 1 1 1 42 1 1 2 22 2 2 1 4001 1 11 1 1 输出例子1:13 例子说明1:1特征&lt;1,1&gt;在连续的帧中连续出现3次，相比其他特征连续出现的次数大，所以输出3 思路1、使用map，将遍历的得到的第一个坐标作为key存入map集合，在辅助map里面记录次坐标的次数 2、遍历所有的帧，比较最大的次数 代码1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashMap;import java.util.Scanner;/** * @author guizimo * @date 2020/7/18 2:25 下午 */public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); for (int i = 0; i &lt; n; i++) &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); HashMap&lt;String, Integer&gt; temp = new HashMap&lt;&gt;(); int m = scanner.nextInt(); int max = 1; //遍历帧 for (int j = 0; j &lt; m; j++) &#123; //清空辅助map temp.clear(); int number = scanner.nextInt(); //遍历帧内的坐标 for (int k = 0; k &lt; number; k++) &#123; int x = scanner.nextInt(); int y = scanner.nextInt(); //拼接key String key = String.valueOf(x) + \" \" + String.valueOf(y); temp.put(key,map.getOrDefault(key,0)+1); max = Math.max(temp.get(key),max); &#125; map.clear(); map.putAll(temp); &#125; if (max &lt;= 1) &#123; System.out.println(1); &#125;else &#123; System.out.println(max); &#125; &#125; &#125;&#125; 感谢 牛客网 字节跳动 以及勤劳的自己","categories":[],"tags":[]},{"title":"牛客网--字节跳动面试题--万万没想到之聪明的编辑","slug":"牛客网--字节跳动面试题--万万没想到之聪明的编辑","date":"2020-07-18T06:17:56.000Z","updated":"2020-07-29T15:08:34.000Z","comments":true,"path":"2020/07/18/牛客网--字节跳动面试题--万万没想到之聪明的编辑/","link":"","permalink":"https://tangleia.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%E7%BD%91--%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98--%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E8%81%AA%E6%98%8E%E7%9A%84%E7%BC%96%E8%BE%91/","excerpt":"牛客网–字节跳动面试题–万万没想到之聪明的编辑","text":"牛客网–字节跳动面试题–万万没想到之聪明的编辑 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 来源链接：万万没想到之聪明的编辑 来源：牛客网 题目我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径： 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC 我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！ …… 万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的…… 请听题：请实现大锤的自动校对程序 输入描述:123第一行包括一个数字N，表示本次用例包括多少个待校验的字符串。后面跟随N行，每行为一个待校验的字符串。 输出描述:1N行，每行包括一个被修复后的字符串。 输入例子1:1232helloowooooooow 输出例子1:12hellowoow 思路使用Java的正则表达式 代码如果不是看到，绝对不会想到这样的解法（代码来自牛客Lunatic201904011812400） 12345678910111213141516import java.util.Scanner;/** * @author guizimo * @date 2020/7/17 9:48 下午 */public class zijie1 &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int line = scanner.nextInt(); scanner.nextLine(); for(int i = 0;i &lt; line;i++)&#123; System.out.println(scanner.nextLine().replaceAll(\"(.)\\\\1+\",\"$1$1\").replaceAll(\"(.)\\\\1(.)\\\\2\",\"$1$1$2\")); &#125; &#125;&#125; 感谢 牛客网 字节跳动 以及勤劳的自己","categories":[],"tags":[]},{"title":"牛客网--字节跳动面试题--万万没想到之抓捕孔连顺","slug":"牛客网--字节跳动面试题--万万没想到之抓捕孔连顺","date":"2020-07-18T06:17:50.000Z","updated":"2020-07-29T15:08:43.000Z","comments":true,"path":"2020/07/18/牛客网--字节跳动面试题--万万没想到之抓捕孔连顺/","link":"","permalink":"https://tangleia.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%E7%BD%91--%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98--%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E6%8A%93%E6%8D%95%E5%AD%94%E8%BF%9E%E9%A1%BA/","excerpt":"牛客网–字节跳动面试题–万万没想到之抓捕孔连顺","text":"牛客网–字节跳动面试题–万万没想到之抓捕孔连顺 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 来源链接：万万没想到之抓捕孔连顺 来源：牛客网 题目我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议 我们在字节跳动大街的N个建筑中选定3个埋伏地点。 为了相互照应，我们决定相距最远的两名特工间的距离不超过D。 我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！ …… 万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！ 请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。 注意： 两个特工不能埋伏在同一地点 三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用 输入描述:123第一行包含空格分隔的两个数字 N和D(1 ≤ N ≤ 1000000; 1 ≤ D ≤ 1000000)第二行包含N个建筑物的的位置，每个位置用一个整数（取值区间为[0, 1000000]）表示，从小到大排列（将字节跳动大街看做一条数轴） 输出描述:1一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 99997867 取模 输入例子1:124 31 2 3 4 输出例子1:14 例子说明1:1可选方案 (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4) 输入例子2:125 191 10 20 30 50 输出例子2:11 例子说明2:1可选方案 (1, 10, 20) 思路1、首先确定范围，计算排列组合，从第三个数开始判断，因为必须有三个数嘛，判断违法的次数，如果当前数字不合法，那么违法的次数加一，那么每次的次数为（当前第几个数-违法次数）x（当前第几个数-违法次数）/ 2 2、累加每次范围的次数，就可以得到全部的了 代码1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;/** * @author guizimo * @date 2020/7/17 10:04 下午 */public class zijie2 &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; int n = scanner.nextInt(); int d = scanner.nextInt(); int[] position = new int[n]; scanner.nextLine(); for (int i = 0; i &lt; n; i++) &#123; position[i] = scanner.nextInt(); &#125; run(n, d, position); &#125; &#125; public static void run(int n, int d, int[] position) &#123; long sum = 0L; long mod = 99997867; for (int i = 0, j = 0; i &lt; n; i++) &#123; //从第三个开始判断，判断是否违法，如果违法j++ while (i &gt;= 2 &amp;&amp; position[i] - position[j] &gt; d) &#123; j++; &#125; //计算合法的次数，n(n-i)/2 sum += (long) (i - j) * (long) (i - j - 1) / 2; &#125; System.out.println(sum % mod); &#125;&#125; 感谢 牛客网 字节跳动 以及勤劳的自己","categories":[],"tags":[]},{"title":"牛客网--字节跳动面试题--雀魂启动","slug":"牛客网--字节跳动面试题--雀魂启动","date":"2020-07-18T05:55:13.000Z","updated":"2020-07-29T15:07:52.000Z","comments":true,"path":"2020/07/18/牛客网--字节跳动面试题--雀魂启动/","link":"","permalink":"https://tangleia.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%E7%BD%91--%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98--%E9%9B%80%E9%AD%82%E5%90%AF%E5%8A%A8/","excerpt":"牛客网–字节跳动面试题–雀魂启动","text":"牛客网–字节跳动面试题–雀魂启动 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 来源链接：雀魂启动来源：牛客网 题目小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。 于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下： 总共有36张牌，每张牌是1~9。每个数字4张牌。 你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌 14张牌中有2张相同数字的牌，称为雀头。 除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777） 例如 1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌 1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌 1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。 要求 现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。 输入描述:1输入只有一行，包含13个数字，用空格分隔，每个数字在1~9之间，数据保证同种数字最多出现4次。 输出描述:1输出同样是一行，包含1个或以上的数字。代表他再取到哪些牌可以和牌。若满足条件的有多种牌，请按从小到大的顺序输出。若没有满足条件的牌，请输出一个数字0 示例1输入11 1 1 2 2 2 5 5 5 6 6 6 9 输出19 说明1可以组成1,2,6,7的4个刻子和9的雀头 示例2输入11 1 1 1 2 2 3 3 5 6 7 8 9 输出14 7 说明1用1做雀头，组123,123,567或456,789的四个顺子 示例3输入11 1 1 2 2 2 3 3 3 5 7 7 9 输出10 说明1来任何牌都无法和牌 思路1、统计所有数字出现的次数 2、循环补充一个数字，凑成14个数字 3、循环选取次数2以及以上的数字为雀头 4、排除雀头，递归判断剩下12个数字是否可以组成刻子或者顺子，如果能够符合规则，记录次数字 5、返回数据 代码代码整理自牛客大佬kakifuu 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.util.ArrayList;import java.util.Scanner;/** * @author guizimo * @date 2020/7/18 12:44 下午 */public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int[] state = new int[9], temp = new int[9]; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); //获取13个数字，统计每个数字出现的次数 for (int i = 0; i &lt; 13; i++) &#123; int num = scanner.nextInt(); state[num - 1]++; &#125; //依次添加数字进行测试 for (int i = 0; i &lt; 9; i++) &#123; if (state[i] &lt; 4) &#123; int num = i + 1; System.arraycopy(state, 0, temp, 0, 9); temp[i]++; //判断是否符合规则，若符合记录当前的数字 if (run(temp, 14, false)) &#123; res.add(num); &#125; &#125; &#125; if (res.isEmpty()) &#123; //如果为空 System.out.println(0); &#125; else &#123; //不为空 StringBuffer sbf = new StringBuffer(); sbf.append(res.get(0)); for (int i = 1; i &lt; res.size(); i++) &#123; sbf.append(\" \"); sbf.append(res.get(i)); &#125; System.out.println(sbf.toString()); &#125; &#125; public static boolean run(int[] temp, int count, boolean hasRun) &#123; if (count == 0) &#123; return true; &#125; if (!hasRun) &#123; for (int i = 0; i &lt; 9; i++) &#123; //遍历个数大于2的数字，让它作为雀头，判断后面的规则是否通过 if (temp[i] &gt;= 2) &#123; temp[i] -= 2; //递归 if (run(temp, count - 2, true)) &#123; return true; &#125; temp[i] += 2; &#125; &#125; return false; &#125; else &#123; for (int i = 0; i &lt; 9; i++) &#123; if (temp[i] &gt; 0) &#123; //判断刻子 if (temp[i] &gt;= 3) &#123; temp[i] -= 3; if (run(temp, count - 3, true)) &#123; return true; &#125; temp[i] += 3; &#125; //判断顺子 if (i + 2 &lt; 9 &amp;&amp; temp[i + 1] &gt; 0 &amp;&amp; temp[i + 2] &gt; 0) &#123; temp[i]--; temp[i+1]--; temp[i+2]--; if(run(temp,count-3,true))&#123; return true; &#125; temp[i]++; temp[i+1]++; temp[i+2]++; &#125; &#125; &#125; &#125; return false; &#125;&#125; 感谢 牛客网 字节跳动 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac安装svn（解决新系统Xcode不支持问题）","slug":"Mac安装svn（解决新系统Xcode不支持问题）","date":"2020-07-17T15:15:00.000Z","updated":"2020-07-29T16:04:10.000Z","comments":true,"path":"2020/07/17/Mac安装svn（解决新系统Xcode不支持问题）/","link":"","permalink":"https://tangleia.github.io/2020/07/17/Mac%E5%AE%89%E8%A3%85svn%EF%BC%88%E8%A7%A3%E5%86%B3%E6%96%B0%E7%B3%BB%E7%BB%9FXcode%E4%B8%8D%E6%94%AF%E6%8C%81%E9%97%AE%E9%A2%98%EF%BC%89/","excerpt":"Mac安装svn（解决新系统Xcode不支持问题）","text":"Mac安装svn（解决新系统Xcode不支持问题） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明在新版的系统里面xcode不再支持svn 所以我们要使用的话，请使用brew来安装 安装请使用国内中科大的源(解决报错问题) https://guizimo.blog.csdn.net/article/details/107419919 1brew install subversion 测试1svn --version 感谢 百度百科 以及勤劳的自己","categories":[],"tags":[]},{"title":"Brew发现自动更新homebrew时卡住","slug":"Brew发现自动更新homebrew时卡住","date":"2020-07-17T15:05:35.000Z","updated":"2020-07-29T15:11:22.000Z","comments":true,"path":"2020/07/17/Brew发现自动更新homebrew时卡住/","link":"","permalink":"https://tangleia.github.io/2020/07/17/Brew%E5%8F%91%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0homebrew%E6%97%B6%E5%8D%A1%E4%BD%8F/","excerpt":"Brew发现自动更新homebrew时卡住","text":"Brew发现自动更新homebrew时卡住 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 原因因为我之前换过源，换成了是阿里的源，然后阿里的源没有cask，所以出错在这里 解决换成中科大的源 1234567891011// 替换brew.git:cd \"$(brew --repo)\"git remote set-url origin https://mirrors.ustc.edu.cn/brew.git// 替换homebrew-core.git:cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\"git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git// 替换homebrew-cask.git:cd \"$(brew --repo)\"/Library/Taps/homebrew/homebrew-cask git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git 更新源 1brew update 之后再次安装就解决了问题 感谢 百度百科 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac安装oracle（使用Docker）","slug":"Mac安装oracle（使用Docker）","date":"2020-07-17T14:47:12.000Z","updated":"2020-07-29T16:03:56.000Z","comments":true,"path":"2020/07/17/Mac安装oracle（使用Docker）/","link":"","permalink":"https://tangleia.github.io/2020/07/17/Mac%E5%AE%89%E8%A3%85oracle%EF%BC%88%E4%BD%BF%E7%94%A8Docker%EF%BC%89/","excerpt":"Mac安装oracle（使用Docker）","text":"Mac安装oracle（使用Docker） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 安装拉取oracle 11g 镜像，这个版本可以自行选择 1docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g 安装oracle容器 1docker run -dp 9090:8080 -p 1521:1521 registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g 进入容器 1docker exec -it 容器id &#x2F;bin&#x2F;bash 容器id可以通过一下命令查询 1docker ps -a 使用navicat连接默认值服务名：helowin 用户名：system 密码：helowin 测试 停止/启动oracle服务： 12docker stop oracledocker start oracle 感谢 百度百科 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac安装Docker配置网易源","slug":"Mac安装Docker配置网易源","date":"2020-07-17T14:19:35.000Z","updated":"2020-07-29T16:03:46.000Z","comments":true,"path":"2020/07/17/Mac安装Docker配置网易源/","link":"","permalink":"https://tangleia.github.io/2020/07/17/Mac%E5%AE%89%E8%A3%85Docker%E9%85%8D%E7%BD%AE%E7%BD%91%E6%98%93%E6%BA%90/","excerpt":"Mac安装Docker配置网易源","text":"Mac安装Docker配置网易源 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 安装使用brew安装 1brew cask install docker 这个过程有一会儿 安装成功后打开Docker，需要验证一下 配置源 找到配置镜像的地方，新版的改成这里了 代码1234567&#123; \"registry-mirrors\": [ \"https://hub-mirror.c.163.com\" ], \"experimental\": false, \"debug\": true&#125; 测试1docker -v 感谢 百度百科 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac下安装配置Maven并在IDEA中配置","slug":"Mac下安装配置Maven并在IDEA中配置","date":"2020-07-16T06:08:49.000Z","updated":"2020-07-29T16:04:40.000Z","comments":true,"path":"2020/07/16/Mac下安装配置Maven并在IDEA中配置/","link":"","permalink":"https://tangleia.github.io/2020/07/16/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMaven%E5%B9%B6%E5%9C%A8IDEA%E4%B8%AD%E9%85%8D%E7%BD%AE/","excerpt":"Mac下安装配置Maven并在IDEA中配置","text":"Mac下安装配置Maven并在IDEA中配置 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 下载Maven下载地址 注意看自己系统，mac/linux下载tar.gz，windows下载zip 设置环境变量首先解压到usr/local下 打开终端，vim ~/.zshrc，在后面添加路径 12export MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.6.3export PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bin 注意自己的版本和路径，应用配置source ~/.zshrc 测试mvn -v，出现以下表示安装成功 配置阿里云源打开 /usr/local/apache-maven-3.6.3/conf/settings.xml 配置文件 1234567&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt; 测试，在终端输入mvn help:system，下载一些默认的jar包到本地仓库 在 idea 中配置 maven 把默认的修改成我们刚才下载好的 因为仓库我没有改，所以没变，如果改了仓库那么就在这里也要配置好 测试创建一个maven项目 选择maven版本 然后就会自动补充maven项目所需要的依赖 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Redis --Java客户端 Jedis","slug":"Redis --Java客户端 Jedis","date":"2020-07-15T09:05:29.000Z","updated":"2020-07-29T16:05:07.000Z","comments":true,"path":"2020/07/15/Redis --Java客户端 Jedis/","link":"","permalink":"https://tangleia.github.io/2020/07/15/Redis%20--Java%E5%AE%A2%E6%88%B7%E7%AB%AF%20Jedis/","excerpt":"Redis –Java客户端 Jedis","text":"Redis –Java客户端 Jedis 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 简介Jedis: 一款java操作redis数据库的工具. 菜鸟教程文档地址 使用步骤导入jedis包 使用1234567891011121314151617181920package com.jedis.test;import org.junit.Test;import redis.clients.jedis.Jedis;/** * @author guizimo * @date 2020/7/15 4:42 下午 */public class JedisTest &#123; @Test public void test()&#123; //1. 获取连接 Jedis jedis = new Jedis(\"127.0.0.1\",6379); //2. 操作 jedis.set(\"name\",\"zhangsan\"); //3. 关闭连接 jedis.close(); &#125;&#125; 测试 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"JSON的介绍","slug":"JSON的介绍","date":"2020-07-15T08:06:37.000Z","updated":"2020-07-29T16:01:21.000Z","comments":true,"path":"2020/07/15/JSON的介绍/","link":"","permalink":"https://tangleia.github.io/2020/07/15/JSON%E7%9A%84%E4%BB%8B%E7%BB%8D/","excerpt":"JSON的介绍","text":"JSON的介绍 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 简介JSON: JavaScript Object Notation(JavaScript 对象表示法) JSON 是存储和交换文本信息的语法。类似 XML。 JSON 比 XML 更小、更快，更易解析。 语法JSON 语法是 JavaScript 对象表示语法的子集。 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 JSON 与 XMLJSON 与 XML 的相同之处： JSON 和 XML 数据都是 “自我描述” ，都易于理解。 JSON 和 XML 数据都是有层次的结构 JSON 和 XML 数据可以被大多数编程语言使用 JSON 与 XML 的不同之处： JSON 不需要结束标签 JSON 更加简短 JSON 读写速度更快 JSON 可以使用数组 123[JSON.parse(): 将一个 JSON 字符串转换为 JavaScript 对象。[JSON.stringify(): 于将 JavaScript 值转换为 JSON 字符串。 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"AJAX介绍和使用","slug":"AJAX介绍和使用","date":"2020-07-15T07:53:44.000Z","updated":"2020-07-29T15:10:49.000Z","comments":true,"path":"2020/07/15/AJAX介绍和使用/","link":"","permalink":"https://tangleia.github.io/2020/07/15/AJAX%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"AJAX介绍和使用","text":"AJAX介绍和使用 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 菜鸟教程地址https://www.runoob.com/ajax/ajax-tutorial.html 简介AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 异步和同步客户端和服务器端相互通信的基础上 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 实现方式使用js1234567891011121314151617181920212223242526272829303132333435363738394041//1.创建核心对象var xmlhttp;if (window.XMLHttpRequest)&#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest();&#125;else&#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;//2. 建立连接/* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);//3.发送请求xmlhttp.send();//4.接受并处理来自服务器的响应结果//获取方式 ：xmlhttp.responseText//什么时候获取？当服务器响应成功后再获取//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。xmlhttp.onreadystatechange=function()&#123; //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125;&#125; 使用jquery$.ajax实现 1234567891011121314$.ajax(&#123; url:\"ajaxServlet1111\" , // 请求路径 type:\"POST\" , //请求方式 //data: \"username=jack&amp;age=23\",//请求参数 data:&#123;\"username\":\"jack\",\"age\":23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(\"出错啦...\") &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:\"text\"//设置接受到的响应数据的格式&#125;); $.get 发送get请求 语法：$.get(url, [data], [callback], [type]) 参数： url：请求路径 data：请求参数 callback：回调函数 type：响应结果的类型 $.post() 发送post请求 语法：$.post(url, [data], [callback], [type]) 参数： url：请求路径 data：请求参数 callback：回调函数 type：响应结果的类型 感谢 菜鸟教程 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery--高级","slug":"jQuery--高级","date":"2020-07-15T07:29:20.000Z","updated":"2020-07-29T16:00:30.000Z","comments":true,"path":"2020/07/15/jQuery--高级/","link":"","permalink":"https://tangleia.github.io/2020/07/15/jQuery--%E9%AB%98%E7%BA%A7/","excerpt":"jQuery–高级","text":"jQuery–高级 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 动画三种方式显示和隐藏元素 默认显示和隐藏方式 show([speed,[easing],[fn]])，参数： speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000) easing：用来指定切换效果，默认是”swing”，可用参数”linear” swing：动画执行时效果是 先慢，中间快，最后又慢 linear：动画执行时速度是匀速的 fn：在动画完成时执行的函数，每个元素执行一次。 hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动显示和隐藏方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出显示和隐藏方式 fadeIn([speed],[easing],[fn]) fadeOut([speed],[easing],[fn]) fadeToggle([speed,[easing],[fn]]) 遍历js的遍历方式 for(初始化值;循环结束条件;步长) jquery的遍历方式 jq对象.each(callback) 语法： 1234jquery对象.each(function(index,element)&#123;&#125;);index:就是元素在集合中的索引element：就是集合中的每一个元素对象this：集合中的每一个元素对象 回调函数返回值： true:如果当前function返回为false，则结束循环(break)。 false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) $.each(object, [callback]) for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 事件绑定 jquery标准的绑定方式 jq对象.事件方法(回调函数)； 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();//让表单提交 on绑定事件/off解除绑定 jq对象.on(“事件名称”,回调函数) jq对象.off(“事件名称”) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 事件切换：toggle jq对象.toggle(fn1,fn2…) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 1&lt;script src=\"../js/jquery-migrate-1.0.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; 插件增强JQuery的功能 实现方式： $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(“#id”) $.extend(object) 增强JQeury对象自身的功能 $/jQuery 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–二维数组中的查找","slug":"LeetCode–二维数组中的查找","date":"2020-07-14T05:56:57.000Z","updated":"2020-07-29T16:03:13.000Z","comments":true,"path":"2020/07/14/LeetCode–二维数组中的查找/","link":"","permalink":"https://tangleia.github.io/2020/07/14/LeetCode%E2%80%93%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"LeetCode–二维数组中的查找","text":"LeetCode–二维数组中的查找 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明剑指offer，4题，主站 240题 二维数组中的查找 题目在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 Java使用线性查找，从右上角开始查找，因为一行的最大值在右上角，如果比当前的值小，那么就向左查询，如果比当前的值大，那么就向右查 12345678910111213141516171819class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if(matrix.length == 0 || matrix[0].length == 0)&#123; return false; &#125; int x = 0, y = matrix[0].length - 1; while(x&lt;matrix.length &amp;&amp; y&gt;=0)&#123; int num = matrix[x][y]; if(num == target)&#123; return true; &#125;else if(num &gt; target)&#123; y--; &#125;else&#123; x++; &#125; &#125; return false; &#125;&#125; Go使用线性查找，从右上角开始查找，因为一行的最大值在右上角，如果比当前的值小，那么就向左查询，如果比当前的值大，那么就向右查 1234567891011121314func findNumberIn2DArray(matrix [][]int, target int) bool &#123; y := len(matrix[0])-1 x := 0 for x&lt;len(matrix) &amp;&amp; y&gt;=0&#123; if matrix[x][y] == target&#123; return true &#125;else if matrix[x][y] &gt; target&#123; y-- &#125;else&#123; x++ &#125; &#125; return false;&#125; C使用线性查找，从右上角开始查找，因为一行的最大值在右上角，如果比当前的值小，那么就向左查询，如果比当前的值大，那么就向右查 1234567891011121314bool findNumberIn2DArray(int** matrix, int matrixSize, int* matrixColSize, int target)&#123; int x = 0; int y = matrixSize - 1; while(x&lt;matrixSize &amp;&amp; y&gt;=0)&#123; if(matrix[x][y] == target)&#123; return true; &#125;else if(matrix[x][y] &gt; target)&#123; y--; &#125;else&#123; x++; &#125; &#125; return false;&#125; PHP暴力法 123456789101112131415161718192021class Solution &#123; /** * @param Integer[][] $matrix * @param Integer $target * @return Boolean */ function findNumberIn2DArray($matrix, $target) &#123; if(count($matrix)==0 || count($matrix[0])==0)&#123; return false; &#125; for($i = 0;$i&lt;count($matrix);$i++)&#123; for($j = 0; $j&lt;count($matrix[$i]);$j++)&#123; if($matrix[$i][$j] == $target)&#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 线性查找 12345678910111213141516class Solution &#123; /** * @param Integer[] $nums * @return Integer */ function findRepeatNumber($nums) &#123; $res = []; for($i=0;$i&lt;count($nums);$i++)&#123; if(isset($res[$nums[$i]]))&#123; return $nums[$i]; &#125; $res[$nums[$i]] = ''; &#125; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–数组中重复的数字","slug":"LeetCode–数组中重复的数字","date":"2020-07-13T05:27:58.000Z","updated":"2020-07-29T16:03:25.000Z","comments":true,"path":"2020/07/13/LeetCode–数组中重复的数字/","link":"","permalink":"https://tangleia.github.io/2020/07/13/LeetCode%E2%80%93%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"LeetCode–数组中重复的数字","text":"LeetCode–数组中重复的数字 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明剑指offer，3题 数组中重复的数字 题目在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 Java使用set集合，遍历数组，将值存入set集合，当存入错误的时候，表示遇到重复的数字，返回此时的元素即可 12345678910111213class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int temp = -1; for(int num : nums)&#123; if(!set.add(num))&#123; temp = num; break; &#125; &#125; return temp; &#125;&#125; Go使用map集合，遍历数组，当map集合的长度不改变，即遇到重复的数字 12345678910func findRepeatNumber(nums []int) int &#123; find := make(map[int]int, 0) for k, v := range nums &#123; find[v] = v if len(find) == k &#123; return v &#125; &#125; return 0&#125; C建立一个同等大小的空数组，原数组的值为新数组的下标，判断是否为第一次访问，访问一次置1，第二次访问直接返回该值。 123456789101112int findRepeatNumber(int* nums, int numsSize)&#123; int i = 0; char *tmp = calloc(numsSize,sizeof(int)); for(i=0;i&lt;numsSize;i++)&#123; if(tmp[nums[i]] == 0)&#123; tmp[nums[i]] = 1; &#125;else&#123; return nums[i]; &#125; &#125; return -1;&#125; PHP新建一个空数组，遍历数组，将元素依次插入新数组当中，使用isset判断是否重复 12345678910111213141516class Solution &#123; /** * @param Integer[] $nums * @return Integer */ function findRepeatNumber($nums) &#123; $res = []; for($i=0;$i&lt;count($nums);$i++)&#123; if(isset($res[$nums[$i]]))&#123; return $nums[$i]; &#125; $res[$nums[$i]] = ''; &#125; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java面试题——随机题（一），看看哪些你会哪些你不会","slug":"Java面试题——随机题（一），看看哪些你会哪些你不会","date":"2020-07-13T04:14:16.000Z","updated":"2020-07-29T15:57:24.000Z","comments":true,"path":"2020/07/13/Java面试题——随机题（一），看看哪些你会哪些你不会/","link":"","permalink":"https://tangleia.github.io/2020/07/13/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E9%9A%8F%E6%9C%BA%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%8C%E7%9C%8B%E7%9C%8B%E5%93%AA%E4%BA%9B%E4%BD%A0%E4%BC%9A%E5%93%AA%E4%BA%9B%E4%BD%A0%E4%B8%8D%E4%BC%9A/","excerpt":"Java面试题——随机题（一），看看哪些你会哪些你不会","text":"Java面试题——随机题（一），看看哪些你会哪些你不会 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 请说明一下EJB的几种类型分别是什么？会话（Session）Bean、实体（Entity）Bean 、消息驱动的（Message Driven）Bean 会话Bean又可分为有状态（Stateful）和无状态（Stateless）两种 实体Bean可分为Bean管理的持续性（BMP）和容器管理的持续性（CMP）两种。 请说明一下锁机制的作用是什么？并且简述一下Hibernate的悲观锁和乐观锁机制是什么？锁机制的作用是保证共享资源可以进行排他性的访问 悲观锁悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。 数据库中主要是通过数据库底层的锁机制才能保证真正的数据访问排他性。 缺点：并发量不高，效率低； 乐观锁对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的 redis为什么是单线程？多线程不一定比单线程效率高，多线程的本质就是CPU通过轮换时间片执行不同的线程，看似多个线程一起执行，但是却承担线程上下文切换的代价。 而对于Redis这样的内存数据库来说，没有上下文的切换的单线程效率是最高的。Redis用单个CPU绑定一块内存的数据，然后针对这块内存的数据进行多次读写操作都是在一个CPU上完成的。 请你谈谈Java中线程如何实现，以及如何实现多线程，线程安全在Java中是如何实现的，线程的工作区是哪里Java多线程有三种实现方式(1)继承Thread类，重写run函数 (2)实现Runnable接口，重写run函数 开启线程：Thread t = new Thread(对象) //创建线程对象 t.start() (3)实现Callable接口，重写call函数 Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其它线程执行的任务。 Callable和Runnable有几点不同:①Callable规定的方法是call()，而Runnable规定的方法是run() ②Callable的任务执行后可返回值，而Runnable的任务是不能返回值的 ③call()方法可抛出异常，而run()方法是不能抛出异常的。 ④运行Callable任务可拿到一个Future对象，Future表示异步计算的结果。它提供了检查计算是否完成的方法,以等待计算的完成,并检索计算的结果.通过Future对象可了解任务执行情况,可取消任务的执行,还可获取任务执行的结果 线程不安全的原因：在操作系统中，线程是不拥有资源的，进程是拥有资源的。而线程是由进程创建的，一个进程可以创建多个线程，这些线程共享着进程中的资源。所以，当线程一起并发运行时，同时对一个数据进行修改，就可能会造成数据的不一致性 线程安全的解决机制： 加锁。 锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。 加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。 加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。 不共享状态 无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。 线程关闭： 仅在单线程环境下使用。 不可变对象 可以使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。 线程的工作区Java内存模型分为主内存，和工作内存。主内存是所有的线程所共享的，工作内存是每个线程自己有一个，不是共享的。 每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作（读取、赋值），都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成 感谢 牛客网 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery DOM操作","slug":"jQuery DOM操作","date":"2020-07-11T08:25:35.000Z","updated":"2020-07-29T16:00:20.000Z","comments":true,"path":"2020/07/11/jQuery DOM操作/","link":"","permalink":"https://tangleia.github.io/2020/07/11/jQuery%20DOM%E6%93%8D%E4%BD%9C/","excerpt":"jQuery DOM操作","text":"jQuery DOM操作 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 内容操作 html() 获取/设置元素的标签体内容 1&lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; text() 获取/设置元素的标签体纯文本内容 1&lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 val() 获取/设置元素的value属性值 属性操作通用属性操作 attr() 获取/设置元素的属性 removeAttr() 删除属性 prop() 获取/设置元素的属性 removeProp() 删除属性 attr和prop区别？ 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 对class属性操作 addClass() 添加class属性值 removeClass() 删除class属性值 toggleClass() 切换class属性 toggleClass(“one”): 判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加 css(): 添加样式 CRUD操作 append() 父元素将子元素追加到末尾 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 prepend() 父元素将子元素追加到开头 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 appendTo() 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 prependTo() 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 after() 添加元素到元素后边 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 before() 添加元素到元素前边 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 insertAfter() 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 insertBefore() 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 remove() 移除元素 对象.remove():将对象删除掉 empty() 清空元素的所有后代元素。 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery 选择器","slug":"jQuery 选择器","date":"2020-07-11T08:05:49.000Z","updated":"2020-07-29T16:00:09.000Z","comments":true,"path":"2020/07/11/jQuery 选择器/","link":"","permalink":"https://tangleia.github.io/2020/07/11/jQuery%20%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"jQuery 选择器","text":"jQuery 选择器 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 jQuery 中所有选择器都以美元符号开头：$()。 分类基本选择器 标签选择器（元素选择器） 语法： $(“html标签名”) 获得所有匹配标签名称的元素 id选择器 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素 类选择器 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素 并集选择器： 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素 层级选择器 后代选择器 语法： $(“A B “) 选择A元素内部的所有B元素 子选择器 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素 属性选择器 属性名称选择器 语法： $(“A[属性名]”) 包含指定属性的选择器 属性选择器 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器 复合属性选择器 语法： $(“A[属性名=’值’]…”) 包含多个属性条件的选择器 过滤选择器 首元素选择器 语法： :first 获得选择的元素中的第一个元素 尾元素选择器 语法： :last 获得选择的元素中的最后一个元素 非元素选择器 语法： :not(selector) 不包括指定内容的元素 偶数选择器 语法： :even 偶数，从 0 开始计数 奇数选择器 语法： :odd 奇数，从 0 开始计数 等于索引选择器 语法： :eq(index) 指定索引元素 大于索引选择器 语法： :gt(index) 大于指定索引元素 小于索引选择器 语法： :lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 语法： :enabled 获得可用元素 不可用元素选择器 语法： :disabled 获得不可用元素 选中选择器 语法： :checked 获得单选/复选框选中的元素 选中选择器 语法： :selected 获得下拉框选中的元素 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery--基本语法","slug":"jQuery--基本语法","date":"2020-07-11T07:49:56.000Z","updated":"2020-07-29T16:00:49.000Z","comments":true,"path":"2020/07/11/jQuery--基本语法/","link":"","permalink":"https://tangleia.github.io/2020/07/11/jQuery--%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"jQuery 选择器","text":"jQuery 选择器 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 jQuery 中所有选择器都以美元符号开头：$()。 分类基本选择器 标签选择器（元素选择器） 语法： $(“html标签名”) 获得所有匹配标签名称的元素 id选择器 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素 类选择器 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素 并集选择器： 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素 层级选择器 后代选择器 语法： $(“A B “) 选择A元素内部的所有B元素 子选择器 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素 属性选择器 属性名称选择器 语法： $(“A[属性名]”) 包含指定属性的选择器 属性选择器 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器 复合属性选择器 语法： $(“A[属性名=’值’]…”) 包含多个属性条件的选择器 过滤选择器 首元素选择器 语法： :first 获得选择的元素中的第一个元素 尾元素选择器 语法： :last 获得选择的元素中的最后一个元素 非元素选择器 语法： :not(selector) 不包括指定内容的元素 偶数选择器 语法： :even 偶数，从 0 开始计数 奇数选择器 语法： :odd 奇数，从 0 开始计数 等于索引选择器 语法： :eq(index) 指定索引元素 大于索引选择器 语法： :gt(index) 大于指定索引元素 小于索引选择器 语法： :lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 语法： :enabled 获得可用元素 不可用元素选择器 语法： :disabled 获得不可用元素 选中选择器 语法： :checked 获得单选/复选框选中的元素 选中选择器 语法： :selected 获得下拉框选中的元素 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery--简介和使用","slug":"jQuery--简介和使用","date":"2020-07-11T07:18:01.000Z","updated":"2020-07-29T16:01:11.000Z","comments":true,"path":"2020/07/11/jQuery--简介和使用/","link":"","permalink":"https://tangleia.github.io/2020/07/11/jQuery--%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"jQuery–简介和使用","text":"jQuery–简介和使用 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 作用jQuery是一个JavaScript函数库。 jQuery是一个轻量级的”写的少，做的多”的JavaScript库。 jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 下载 jquery.com从这个网站上下载即可 使用jQuery 库是一个 JavaScript 文件，您可以使用 HTML 的 标签引用它： 123&lt;head&gt; &lt;script src=\"jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; 也可以使用CDN 1234&lt;head&gt;&lt;script src=\"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 感谢 百度百科 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--Filter（过滤器）","slug":"Java--Filter（过滤器）","date":"2020-07-10T11:58:30.000Z","updated":"2020-07-29T15:25:44.000Z","comments":true,"path":"2020/07/10/Java--Filter（过滤器）/","link":"","permalink":"https://tangleia.github.io/2020/07/10/Java--Filter%EF%BC%88%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89/","excerpt":"Java–Filter（过滤器）","text":"Java–Filter（过滤器） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 简介Filter也称之为过滤器，它是Servlet技术中最实用的技术，Web开发人员通过Filter技术，对web服务器管理的所有web资源，例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。 实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 配置注解方式1234567891011121314151617181920@WebFilter(&quot;&#x2F;*&quot;)&#x2F;&#x2F;访问所有资源之前，都会执行该过滤器public class Filter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filter被执行了....&quot;); &#x2F;&#x2F;放行 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125; &#125; web.xml123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt; 过滤器生命周期方法init在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter每一次请求被拦截资源时，会执行。执行多次 destroy在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 过滤器配置详解拦截路径配置 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置： 设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 设置标签 1&lt;dispatcher&gt;&lt;&#x2F;dispatcher&gt; 配置多个过滤器 执行顺序：如果有两个过滤器：过滤器1和过滤器2，具体过程？ 123456789过滤器1过滤器2资源执行过滤器2过滤器1 过滤器先后顺序问题有两个过滤器先执行哪一个？ 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置： 谁定义在上边，谁先执行 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"TP5.1让验证码在另外的项目（Electron-vue）里面使用","slug":"TP5.1让验证码在另外的项目（Electron-vue）里面使用","date":"2020-07-10T04:47:07.000Z","updated":"2020-07-29T16:07:36.000Z","comments":true,"path":"2020/07/10/TP5.1让验证码在另外的项目（Electron-vue）里面使用/","link":"","permalink":"https://tangleia.github.io/2020/07/10/TP5.1%E8%AE%A9%E9%AA%8C%E8%AF%81%E7%A0%81%E5%9C%A8%E5%8F%A6%E5%A4%96%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%88Electron-vue%EF%BC%89%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8/","excerpt":"TP5.1验证Token和Electron-vue头部携带Token","text":"TP5.1验证Token和Electron-vue头部携带Token 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍在做一个Electron-vue的项目的时候需要使用到登录，使用TP5.1作为后台框架，正规的流程是在Electron-vue中携带Token信息，在TP5.1中验证Token来判断是否过期 Electron-vue头部携带Token在配置拦截器的时候配置请求头 1234567891011// request拦截器service.interceptors.request.use(config =&gt; &#123; if (store.getters.token) &#123; config.headers['Authorization'] = store.getters.token// 让每个请求携带自定义token 请根据实际情况自行修改 &#125; return config&#125;, error =&gt; &#123; // Do something with request error console.log(error) // for debug Promise.reject(error)&#125;) 注意这个Authorization必须是在后端跨域的Access-Control-Allow-Headers参数中有的，比如 123Access-Control-Allow-Origin:*Access-Control-Allow-Methods:GET, POST, PATCH, PUT, DELETEAccess-Control-Allow-Headers:Authorization, Content-Type, If-Match, If-Modified-Since, If-None-Match, If-Unmodified-Since, X-Requested-With TP5.1验证Token首先在路由的时候设置中间件 然后我们的验证就写在这个中间件里面 123456789101112131415public function handle($request, \\Closure $next) &#123; // 获取头部信息 $param = $request-&gt;header(); // 不含token if (!array_key_exists('authorization', $param)) TApiException('非法token，禁止操作', 20003, 200); // 当前用户token是否存在（是否登录） $token = $param['authorization']; $user = Cache::get($token); // 验证失败（未登录或已过期） if (!$user) TApiException('非法token，请重新登录', 20003, 200); // 将token和userid这类常用参数放在request中 $request-&gt;userToken = $token; return $next($request); &#125; 这样经过配置过的路由都会验证Token，以此来判断用户是否登录 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue请求携带cookie跨域问题","slug":"Electron-vue请求携带cookie跨域问题","date":"2020-07-10T04:08:38.000Z","updated":"2020-07-29T15:12:12.000Z","comments":true,"path":"2020/07/10/Electron-vue请求携带cookie跨域问题/","link":"","permalink":"https://tangleia.github.io/2020/07/10/Electron-vue%E8%AF%B7%E6%B1%82%E6%90%BA%E5%B8%A6cookie%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"Electron-vue请求携带cookie跨域问题","text":"Electron-vue请求携带cookie跨域问题 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题说明在请求携带cookie的时候，跨域的问题又重新来了，原因在于cookie标识了服务器，我们在跨域配置的时候Access-Control-Allow-Origin，这个参数我们需要具体的指出，而不能使用* 问题解决这个跨域问题一般在后端，这里一TP5.1为例 在路由配置跨域的时候精确到具体的客户端服务器的地址，也就是你前端的地址 这样就可以啦 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue在发送请求时携带cookie","slug":"Electron-vue在发送请求时携带cookie","date":"2020-07-10T03:57:56.000Z","updated":"2020-07-29T15:17:31.000Z","comments":true,"path":"2020/07/10/Electron-vue在发送请求时携带cookie/","link":"","permalink":"https://tangleia.github.io/2020/07/10/Electron-vue%E5%9C%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E6%90%BA%E5%B8%A6cookie/","excerpt":"Electron-vue在发送请求时携带cookie","text":"Electron-vue在发送请求时携带cookie 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 解决axios一般呢我们会遇到在vue项目使用它来发送的我们的请求，相当于ajax 我们在使用axios的时候默认给它配置 例如我在项目调用请求的时候封装了一个request类，在引入axios的时候，给它初始化配置 代码12import axios from 'axios'axios.defaults.withCredentials=true;//让ajax携带cookie vue项目类似（尽量在全局里面配置，比如main.js） 123import axios from 'axios'axios.defaults.withCredentials=true;//让ajax携带cookieVue.prototype.$axios = axios; 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"TP5.1解决跨域","slug":"TP5.1解决跨域","date":"2020-07-10T03:47:15.000Z","updated":"2020-07-29T16:09:08.000Z","comments":true,"path":"2020/07/10/TP5.1解决跨域/","link":"","permalink":"https://tangleia.github.io/2020/07/10/TP5.1%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/","excerpt":"TP5.1解决跨域","text":"TP5.1解决跨域 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍在前后端分离开发的时候就会遇到跨域的问题，在本地调试的时候可能不会出现什么太大的问题，但是上线部署的时候难免会遇到问题 不过这种跨域的问题还是最好在后端解决 官方手册地址https://www.kancloud.cn/manual/thinkphp5_1/489844 解决在我们的route目录下的route.php，可以分组配置路由 这个是默认的跨域设置，当然这个都可以自己添加的 123Access-Control-Allow-Origin:*Access-Control-Allow-Methods:GET, POST, PATCH, PUT, DELETEAccess-Control-Allow-Headers:Authorization, Content-Type, If-Match, If-Modified-Since, If-None-Match, If-Unmodified-Since, X-Requested-With 添加可以像这样的 12345Route::get('new/:id', 'News/read') -&gt;ext('html') -&gt;header('Access-Control-Allow-Origin','thinkphp.cn') -&gt;header('Access-Control-Allow-Credentials', 'true') -&gt;allowCrossDomain(); 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue解决跨域","slug":"Electron-vue解决跨域","date":"2020-07-10T03:39:56.000Z","updated":"2020-07-29T15:12:01.000Z","comments":true,"path":"2020/07/10/Electron-vue解决跨域/","link":"","permalink":"https://tangleia.github.io/2020/07/10/Electron-vue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/","excerpt":"Electron-vue解决跨域","text":"Electron-vue解决跨域 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍在前后端分离开发的时候就会遇到跨域的问题，在本地调试的时候可能不会出现什么太大的问题，但是上线部署的时候难免会遇到问题 解决在.electron-vue下面的dev-runner.js里面的WebpackDevServer添加配置 代码1234567891011121314151617proxy: &#123; '/api': &#123; // 请求的目标服务器地址 target: 'https://www.domain.com', // 如果是https接口，需要配置这个参数 secure: false, // 设置允许跨域 changeOrigin: true, // 重写路径 pathRewrite: &#123; '^/api': '' &#125;, headers: &#123; referer: '' &#125; &#125;&#125;, 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue运行之后出现了文件浏览器","slug":"Electron-vue运行之后出现了文件浏览器","date":"2020-07-08T02:00:48.000Z","updated":"2020-07-29T15:17:21.000Z","comments":true,"path":"2020/07/08/Electron-vue运行之后出现了文件浏览器/","link":"","permalink":"https://tangleia.github.io/2020/07/08/Electron-vue%E8%BF%90%E8%A1%8C%E4%B9%8B%E5%90%8E%E5%87%BA%E7%8E%B0%E4%BA%86%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"Electron-vue运行之后出现了文件浏览器","text":"Electron-vue运行之后出现了文件浏览器 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题介绍在运行项目的时候出现了文件浏览器 问题原因（官方解释）你的 src/renderer 包含错误。请检查 控制台 (console)，修复错误，然后用 CommandOrControl+R 刷新 electron。 详述如果你的 src/renderer 中出现错误，则会在首次运行时与 ESLint 产生冲突。接着，一个无效的 webpack 的 renderer.js 会被生成出来，它会打断 HtmlWebpackPlugin 创建 index.html。由于 webpack-dev-server 没有 index.html 可以提供服务，所以服务器失败，程序返回到文件浏览器。 问题解决主要适合ESlint有关，将ESlint检查关闭就可以了，具体的在.electron-vue下面的三个配置文件里面的ESlint代码注释掉 那么这个问题就解决了 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue取消代码检查","slug":"Electron-vue取消代码检查","date":"2020-07-08T01:34:48.000Z","updated":"2020-07-29T15:16:24.000Z","comments":true,"path":"2020/07/08/Electron-vue取消代码检查/","link":"","permalink":"https://tangleia.github.io/2020/07/08/Electron-vue%E5%8F%96%E6%B6%88%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/","excerpt":"Electron-vue取消代码检查Eslint","text":"Electron-vue取消代码检查Eslint 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍在项目运行的时候容易出现错误，特别是这种检查代码的，什么格式啊，甚至分号呀，一来就是一大推 方法一在创建项目的时候不使用eslint 这里选择no 方法二在.elerton-vue目录下里面的三个文件都修改一下 把有关eslint的都注释掉 记得要重新npm run dev 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"使用Composer安装TP5.1出现zsh no matches found 5.1","slug":"使用Composer安装TP5.1出现zsh no matches found 5.1","date":"2020-07-05T09:14:47.000Z","updated":"2020-07-29T15:09:16.000Z","comments":true,"path":"2020/07/05/使用Composer安装TP5.1出现zsh no matches found 5.1/","link":"","permalink":"https://tangleia.github.io/2020/07/05/%E4%BD%BF%E7%94%A8Composer%E5%AE%89%E8%A3%85TP5.1%E5%87%BA%E7%8E%B0zsh%20no%20matches%20found%205.1/","excerpt":"使用Composer安装TP5.1出现zsh: no matches found: 5.1.*","text":"使用Composer安装TP5.1出现zsh: no matches found: 5.1.* 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题提示zsh: no matches found: 5.1.* 问题解决在之前还是可以执行的，现在新建的时候出现了现在的问题 解决办法是不使用这个版本模糊的命令，直接确定版本 1composer create-project topthink&#x2F;think&#x3D;5.1.31 sight 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Composer切换国内源","slug":"Composer切换国内源","date":"2020-07-05T09:06:50.000Z","updated":"2020-07-29T15:11:34.000Z","comments":true,"path":"2020/07/05/Composer切换国内源/","link":"","permalink":"https://tangleia.github.io/2020/07/05/Composer%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/","excerpt":"Composer切换国内源","text":"Composer切换国内源 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 局部切换在当前项目下的composer.json中添加 1234567&#123;\"repositories\": [ &#123; \"type\": \"composer\", \"url\": \"https://mirrors.aliyun.com/composer/\" //第一个源 &#125;&#125; 全局切换首先把默认的源给禁用掉 1composer config -g secure-http false 再修改镜像源，这里使用阿里的源 1composer config -g repo.packagist composer https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F; 查看 1composer config -g -l 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"TP5.1出现A non well formed numeric value encountered问题","slug":"TP5.1出现A non well formed numeric value encountered问题","date":"2020-07-05T08:57:09.000Z","updated":"2020-07-29T16:07:11.000Z","comments":true,"path":"2020/07/05/TP5.1出现A non well formed numeric value encountered问题/","link":"","permalink":"https://tangleia.github.io/2020/07/05/TP5.1%E5%87%BA%E7%8E%B0A%20non%20well%20formed%20numeric%20value%20encountered%E9%97%AE%E9%A2%98/","excerpt":"TP5.1出现A non well formed numeric value encountered问题","text":"TP5.1出现A non well formed numeric value encountered问题 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题介绍A non well formed numeric value encountered 出现这样的问题是tp5.1自动转化时间格式失败出现的问题 比如在数据库里面的字段是varchar格式的，在tp5.1里代码又是写的该字段是自动转化时间戳格式的，就会出错 问题解决在数据库中使用时间类的字段，或者使用int类型，或者不使用tp5.1的自动转化 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac正确解决checkPermissions Missing write access to问题","slug":"Mac正确解决checkPermissions Missing write access to问题","date":"2020-07-04T04:27:29.000Z","updated":"2020-07-29T16:04:56.000Z","comments":true,"path":"2020/07/04/Mac正确解决checkPermissions Missing write access to问题/","link":"","permalink":"https://tangleia.github.io/2020/07/04/Mac%E6%AD%A3%E7%A1%AE%E8%A7%A3%E5%86%B3checkPermissions%20Missing%20write%20access%20to%E9%97%AE%E9%A2%98/","excerpt":"Mac正确解决checkPermissions Missing write access to问题","text":"Mac正确解决checkPermissions Missing write access to问题 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题详情npm WARN checkPermissions Missing write access to /Users/tanglei/Downloads/sight/node_modules/uview-ui 问题解决刚开始以为是权限不够，那么就加权限sudo 然而还是没有用 那么就可能是已经有了这个文件了，把node_modules目录删除，再试一次 那么就解决了 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–最长公共前缀","slug":"LeetCode–最长公共前缀","date":"2020-07-01T10:19:34.000Z","updated":"2020-07-29T16:03:35.000Z","comments":true,"path":"2020/07/01/LeetCode–最长公共前缀/","link":"","permalink":"https://tangleia.github.io/2020/07/01/LeetCode%E2%80%93%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","excerpt":"LeetCode–最长公共前缀","text":"LeetCode–最长公共前缀 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明leetcode题，14题 最长公共前缀 题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 12输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 1所有输入只包含小写字母 a-z Java水平扫描法依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。 12345678910111213141516171819202122232425262728class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs == null || strs.length == 0)&#123; return \"\"; &#125; //假设第一个字段为公共前缀 String prefix = strs[0]; int count = strs.length; for(int i = 1;i&lt;count;i++)&#123; //获取两个字符串最长前缀 prefix = longestCommonPrefix(prefix,strs[i]); if(prefix.length() == 0)&#123; break; &#125; &#125; return prefix; &#125; //获取两个字符串最长前缀 public String longestCommonPrefix(String str1,String str2)&#123; int length = Math.min(str1.length(),str2.length()); int index = 0; while(index&lt;length &amp;&amp; str1.charAt(index) == str2.charAt(index))&#123; index++; &#125; return str1.substring(0,index); &#125;&#125; Python水平扫描法 123456789101112131415161718class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return \"\" #假设第一个字段为公共前缀 prefix , count = strs[0],len(strs) for i in range(1,count): #获取两个字符串最长前缀 prefix = self.commonPrefix(prefix,strs[i]) if not prefix: return \"\" return prefix #获取两个字符串最长前缀 def commonPrefix(self,str1,str2): length,index = min(len(str1),len(str2)),0 while index &lt; length and str1[index] == str2[index]: index += 1 return str1[:index] C++水平扫描法 123456789101112131415161718192021222324252627class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(!strs.size())&#123; return \"\"; &#125; string prefix = strs[0]; int count = strs.size(); for (int i = 1;i &lt; count; i++)&#123; prefix = longestCommonPrefix(prefix,strs[i]); if (!prefix.size())&#123; break; &#125; &#125; return prefix; &#125; string longestCommonPrefix(const string&amp; str1,const string&amp; str2)&#123; int index = 0; int length = min(str1.size(),str2.size()); while(index &lt; length &amp;&amp; str1[index] == str2[index])&#123; index++; &#125; return str1.substr(0,index); &#125;&#125;; PHP水平扫描法 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; /** * @param String[] $strs * @return String */ function longestCommonPrefix($strs) &#123; $prefix = ''; $i = 0; //判断其中是否有字符串长度为0 foreach($strs as $key =&gt; $value)&#123; if($value == '')&#123; return $prefix; &#125; &#125; //判断个数是否为空 if(count($strs)&lt;1)&#123; return $prefix; &#125; while(true)&#123; //获取当前第i个字符 $current = $strs[0]&#123;$i&#125;; if(!$current)&#123; return $prefix; &#125; foreach($strs as $key =&gt; $value)&#123; if($value&#123;$i&#125; != $current)&#123; return $prefix; &#125; &#125; $prefix .= $current; $i++; &#125; return $prefix; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"查找--差值查找（Java）","slug":"查找--差值查找（Java）","date":"2020-07-01T00:53:03.000Z","updated":"2020-07-29T15:03:12.000Z","comments":true,"path":"2020/07/01/查找--差值查找（Java）/","link":"","permalink":"https://tangleia.github.io/2020/07/01/%E6%9F%A5%E6%89%BE--%E5%B7%AE%E5%80%BC%E6%9F%A5%E6%89%BE%EF%BC%88Java%EF%BC%89/","excerpt":"查找–差值查找（Java）","text":"查找–差值查找（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。 自适应计算自适应mid int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left]) 代码1234567891011121314151617181920212223242526272829303132package cn.guizimo.search;public class InsertValueSearch &#123; public static void main(String[] args) &#123; int max = 100; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = i + 1; &#125; int index = insertValueSearch(arr, 0, arr.length - 1, 100); if(index == -1)&#123; System.out.println(\"未找到\"); &#125;else &#123; System.out.println(\"下标为：\"+index); &#125; &#125; public static int insertValueSearch(int[] arr, int left, int right, int value) &#123; if (left &gt; right || value &lt; arr[0] || value &gt; arr[arr.length - 1]) &#123; return -1; &#125; int mid = left + (right - left) * (value - arr[left]) / (arr[right] - arr[left]); int midValue = arr[left]; if (value &gt; arr[mid]) &#123; return insertValueSearch(arr, mid + 1, right, value); &#125; else if (value &lt; arr[mid]) &#123; return insertValueSearch(arr, left, mid - 1, value); &#125; else &#123; return mid; &#125; &#125;&#125; 注意的事项 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快. 关键字分布不均匀的情况下，该方法不一定比折半查找要好 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"查找--二分查找（Java）","slug":"查找--二分查找（Java）","date":"2020-06-30T06:22:39.000Z","updated":"2020-07-29T15:05:57.000Z","comments":true,"path":"2020/06/30/查找--二分查找（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/30/%E6%9F%A5%E6%89%BE--%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88Java%EF%BC%89/","excerpt":"查找–二分查找（Java）","text":"查找–二分查找（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 过程首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 代码12345678910111213141516171819202122232425262728package cn.guizimo.search;public class BinarySearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 5, 26, 68, 100, 235, 667, 896, 999&#125;; int index = binarySearch(arr, 0, arr.length - 1, 26); if(index == -1)&#123; System.out.println(\"未找到\"); &#125;else &#123; System.out.println(\"下标为：\"+index); &#125; &#125; public static int binarySearch(int[] arr, int left, int right, int value) &#123; if (left &gt; right) &#123; return -1; &#125; int mid = (right + left) / 2; int midValue = arr[mid]; if (value &gt; midValue) &#123; return binarySearch(arr, mid + 1, right, value); &#125; else if (value &lt; midValue) &#123; return binarySearch(arr, left, mid - 1, value); &#125; else &#123; return mid; &#125; &#125;&#125; 优化将数列中重复的数的下标全部找到 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.guizimo.search;import java.util.ArrayList;import java.util.List;public class BinarySearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 5, 26, 26, 26, 26, 68, 100, 235, 667, 896, 999&#125;; List&lt;Integer&gt; arrayList = binarySearch(arr, 0, arr.length - 1, 25); if (arrayList.size() == 0) &#123; System.out.println(\"未找到\"); &#125; else &#123; System.out.println(\"下标集为：\" + arrayList); &#125; &#125; public static List&lt;Integer&gt; binarySearch(int[] arr, int left, int right, int value) &#123; if (left &gt; right) &#123; return new ArrayList&lt;Integer&gt;(); &#125; int mid = (left + right) / 2; int midValue = arr[mid]; if (value &gt; midValue) &#123; return binarySearch(arr, mid + 1, right, value); &#125; else if (value &lt; midValue) &#123; return binarySearch(arr, left, mid - 1, value); &#125; else &#123; List&lt;Integer&gt; resIndexList = new ArrayList&lt;Integer&gt;(); int temp = mid - 1; while (true) &#123; if (temp &lt; 0 || arr[temp] != value) &#123; break; &#125; resIndexList.add(temp); temp -= 1; &#125; resIndexList.add(mid); temp = mid + 1; while (true) &#123; if (temp &gt; arr.length - 1 || arr[temp] != value) &#123; break; &#125; resIndexList.add(temp); temp += 1; &#125; return resIndexList; &#125; &#125;&#125; 感谢 尚硅谷 百度百科 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"查找--线性查找（Java）","slug":"查找--线性查找（Java）","date":"2020-06-30T04:23:01.000Z","updated":"2020-07-29T15:05:53.000Z","comments":true,"path":"2020/06/30/查找--线性查找（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/30/%E6%9F%A5%E6%89%BE--%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%EF%BC%88Java%EF%BC%89/","excerpt":"查找–线性查找（Java）","text":"查找–线性查找（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍线性查找又称顺序查找，是一种最简单的查找方法，它的基本思想是从第一个记录开始，逐个比较记录的关键字，直到和给定的K值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败 线性查找可以的数列可以是有序的也可以是无序的 代码12345678910111213141516171819202122package cn.guizimo.search;public class OrderSearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 69, 35, 89, 1100, 456, 2&#125;; int index = orderSearch(arr, 2); if(index == -1)&#123; System.out.println(\"未找到\"); &#125;else &#123; System.out.println(\"下标为：\"+index); &#125; &#125; public static int orderSearch(int[] arr,int value)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == value)&#123; return i; &#125; &#125; return -1; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--小项目（登录、增删改查、分页、搜索）","slug":"Java--小项目（登录、增删改查、分页、搜索）","date":"2020-06-29T11:24:31.000Z","updated":"2020-07-29T15:25:28.000Z","comments":true,"path":"2020/06/29/Java--小项目（登录、增删改查、分页、搜索）/","link":"","permalink":"https://tangleia.github.io/2020/06/29/Java--%E5%B0%8F%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%99%BB%E5%BD%95%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E3%80%81%E5%88%86%E9%A1%B5%E3%80%81%E6%90%9C%E7%B4%A2%EF%BC%89/","excerpt":"Java–小项目（登录、增删改查、分页、搜索）","text":"Java–小项目（登录、增删改查、分页、搜索） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念技术选型Servlet、JSP、MySQL、JDBCTempleat、Duird、BeanUtilS、tomcat 功能介绍登录功能，列表展示，数据添加，数据编辑，数据删除，批量删除，分页展示，关键字搜索 创建JavaWeb项目 导入依赖 添加页面文件 数据库12345678910111213create database little; -- 创建数据库use little; -- 使用数据库create table user( -- 创建表 id int primary key auto_increment, name varchar(20) not null, gender varchar(5), age int, address varchar(32), qq varchar(20), email varchar(50, username varchar(32), password varchar(32),); 列表展示思路首先我们需要一组列表的数据，那么我们就需要一个相对应servlet，通过我们的三层架构，使用service同一做接口，然后调用dao层使用JBDC操作数据库，这样我们可以获得一个map集合的数据，然后就是渲染数据到jsp页面了，通过JSTL和EL把数据循环渲染到表里面，达到列表的展示 list.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/28 Time: 下午2:15 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; td, th &#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;h3 style=\"text-align: center\"&gt;用户信息列表&lt;/h3&gt; &lt;table border=\"1\" class=\"table table-bordered table-hover\"&gt; &lt;tr class=\"success\"&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;users&#125;\" var=\"user\" varStatus=\"s\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=\"btn btn-default btn-sm\" href=\"update.html\"&gt;修改&lt;/a&gt;&amp;nbsp;&lt;a class=\"btn btn-default btn-sm\" href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;tr&gt; &lt;td colspan=\"8\" align=\"center\"&gt;&lt;a class=\"btn btn-primary\" href=\"add.html\"&gt;添加联系人&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; servlet代码文件很多，就不一一展示了 UserListServlet1234567891011121314151617181920212223242526272829303132package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(\"/userListServlet\")public class UserListServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //调用UserService完成查询 UserService userService = new UserServiceImpl(); List&lt;User&gt; users = userService.findAll(); //存入request域 req.setAttribute(\"users\",users); //转发到list.jsp req.getRequestDispatcher(\"/list.jsp\").forward(req,resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 登录思路登录功能首先就是对表单提交的数据进行比对，验证码可以在生成的时候就把它存入到session中，然后在servlet中进行比对，其他的字段在通过调用dao层的JDBC操作数据库进行比对，最后把登录成功的用户信息存入session中 login.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/28 Time: 下午7:37 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/&gt; &lt;title&gt;管理员登录&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function refreshCode() &#123; let vcode = document.getElementById(\"vcode\"); vcode.src = \"$&#123;pageContext.request.contextPath&#125;/checkCodeServlet?=\" + new Date().getTime(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\" style=\"width: 400px;\"&gt; &lt;h3 style=\"text-align: center;\"&gt;管理员登录&lt;/h3&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/loginServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"user\"&gt;用户名：&lt;/label&gt; &lt;input type=\"text\" name=\"username\" class=\"form-control\" id=\"user\" placeholder=\"请输入用户名\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"password\"&gt;密码：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" class=\"form-control\" id=\"password\" placeholder=\"请输入密码\"/&gt; &lt;/div&gt; &lt;div class=\"form-inline\"&gt; &lt;label for=\"vcode\"&gt;验证码：&lt;/label&gt; &lt;input type=\"text\" name=\"verifycode\" class=\"form-control\" id=\"verifycode\" placeholder=\"请输入验证码\" style=\"width: 120px;\"/&gt; &lt;a href=\"javascript:refreshCode()\"&gt;&lt;img src=\"$&#123;pageContext.request.contextPath&#125;/checkCodeServlet\" title=\"看不清点击刷新\" id=\"vcode\"/&gt;&lt;/a&gt; &lt;/div&gt; &lt;hr/&gt; &lt;div class=\"form-group\" style=\"text-align: center;\"&gt; &lt;input class=\"btn btn btn-primary\" type=\"submit\" value=\"登录\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 出错显示的信息框 --&gt; &lt;div class=\"alert alert-warning alert-dismissible\" role=\"alert\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\"&gt; &lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;strong&gt;$&#123;login_msg&#125;&lt;/strong&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; LoginServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(\"/loginServlet\")public class LoginServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding(\"utf-8\"); //传递过来的验证码 String verifycode = req.getParameter(\"verifycode\"); HttpSession session = req.getSession(); //session里面的验证码 String checkcode_server = (String) session.getAttribute(\"CHECKCODE_SERVER\"); session.removeAttribute(\"CHECKCODE_SERVER\"); //比对验证码 if (!checkcode_server.equalsIgnoreCase(verifycode)) &#123; req.setAttribute(\"login_msg\", \"验证码错误\"); req.getRequestDispatcher(\"/login.jsp\").forward(req, resp); return; &#125; Map&lt;String, String[]&gt; parameterMap = req.getParameterMap(); User user = new User(); try &#123; BeanUtils.populate(user, parameterMap); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; UserService userService = new UserServiceImpl(); User loginUser = userService.login(user); if(loginUser != null)&#123; session.setAttribute(\"user\",loginUser); resp.sendRedirect(req.getContextPath()+\"/index.jsp\"); &#125;else &#123; req.setAttribute(\"login_msg\", \"登录失败\"); req.getRequestDispatcher(\"/login.jsp\").forward(req, resp); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; CheckCodeServlet12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package cn.guizimo.little.web.servlet;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 验证码 */@WebServlet(\"/checkCodeServlet\")public class CheckCodeServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123; //服务器通知浏览器不要缓存 response.setHeader(\"pragma\",\"no-cache\"); response.setHeader(\"cache-control\",\"no-cache\"); response.setHeader(\"expires\",\"0\"); //在内存中创建一个长80，宽30的图片，默认黑色背景 //参数一：长 //参数二：宽 //参数三：颜色 int width = 80; int height = 30; BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //获取画笔 Graphics g = image.getGraphics(); //设置画笔颜色为灰色 g.setColor(Color.GRAY); //填充图片 g.fillRect(0,0, width,height); //产生4个随机验证码，12Ey String checkCode = getCheckCode(); //将验证码放入HttpSession中 request.getSession().setAttribute(\"CHECKCODE_SERVER\",checkCode); //设置画笔颜色为黄色 g.setColor(Color.YELLOW); //设置字体的小大 g.setFont(new Font(\"黑体\",Font.BOLD,24)); //向图片上写入验证码 g.drawString(checkCode,15,25); //将内存中的图片输出到浏览器 //参数一：图片对象 //参数二：图片的格式，如PNG,JPG,GIF //参数三：图片输出到哪里去 ImageIO.write(image,\"PNG\",response.getOutputStream()); &#125; /** * 产生4位随机字符串 */ private String getCheckCode() &#123; String base = \"0123456789ABCDEFGabcdefg\"; int size = base.length(); Random r = new Random(); StringBuffer sb = new StringBuffer(); for(int i=1;i&lt;=4;i++)&#123; //产生0到size-1的随机值 int index = r.nextInt(size); //在base字符串中获取下标为index的字符 char c = base.charAt(index); //将c放入到StringBuffer中去 sb.append(c); &#125; return sb.toString(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request,response); &#125;&#125; 测试 添加人员思路添加操作就是把jsp提交的表单的数据向数据库里面存储，过程为jsp-&gt;servlet-&gt;service-&gt;dao add.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/28 Time: 下午8:55 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!-- HTML5文档--&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;添加用户&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;center&gt;&lt;h3&gt;添加联系人页面&lt;/h3&gt;&lt;/center&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/addUserServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" placeholder=\"请输入姓名\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" checked=\"checked\"/&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\"/&gt;女 &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"age\" name=\"age\" placeholder=\"请输入年龄\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"address\"&gt;籍贯：&lt;/label&gt; &lt;select name=\"address\" class=\"form-control\" id=\"jiguan\"&gt; &lt;option value=\"广东\"&gt;广东&lt;/option&gt; &lt;option value=\"广西\"&gt;广西&lt;/option&gt; &lt;option value=\"湖南\"&gt;湖南&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"qq\"&gt;QQ：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" name=\"qq\" placeholder=\"请输入QQ号码\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"email\"&gt;Email：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" name=\"email\" placeholder=\"请输入邮箱地址\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"text-align: center\"&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" value=\"提交\" /&gt; &lt;input class=\"btn btn-default\" type=\"reset\" value=\"重置\" /&gt; &lt;input class=\"btn btn-default\" type=\"button\" value=\"返回\" /&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; AddUserServlet12345678910111213141516171819202122232425262728293031323334353637383940package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(\"/addUserServlet\")public class AddUserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(\"utf-8\"); Map&lt;String, String[]&gt; parameterMap = req.getParameterMap(); User user = new User(); try &#123; BeanUtils.populate(user,parameterMap); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; UserService userService = new UserServiceImpl(); userService.addUser(user); resp.sendRedirect(req.getContextPath()+\"/userListServlet\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 修改思路首先我们需要在打开jsp页面的时候就查询到这样的一条记录，通过这一条记录的id作为表单的隐藏域，在servlet里面将数据进行保存即可 update.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/29 Time: 上午10:44 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;修改用户&lt;/title&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\" style=\"width: 400px;\"&gt; &lt;h3 style=\"text-align: center;\"&gt;修改联系人&lt;/h3&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/updateUserServlet\" method=\"post\"&gt; &lt;!-- 隐藏域 提交id--&gt; &lt;input type=\"hidden\" name=\"id\" value=\"$&#123;user.id&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" value=\"$&#123;user.name&#125;\" readonly=\"readonly\" placeholder=\"请输入姓名\" /&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;c:if test=\"$&#123;user.gender == '男'&#125;\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" checked /&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\" /&gt;女 &lt;/c:if&gt; &lt;c:if test=\"$&#123;user.gender == '女'&#125;\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" /&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\" checked /&gt;女 &lt;/c:if&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" value=\"$&#123;user.age&#125;\" id=\"age\" name=\"age\" placeholder=\"请输入年龄\" /&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"address\"&gt;籍贯：&lt;/label&gt; &lt;select name=\"address\" id=\"address\" class=\"form-control\" &gt; &lt;c:if test=\"$&#123;user.address == '陕西'&#125;\"&gt; &lt;option value=\"陕西\" selected&gt;陕西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;user.address == '北京'&#125;\"&gt; &lt;option value=\"陕西\" &gt;陕西&lt;/option&gt; &lt;option value=\"北京\" selected&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;user.address == '上海'&#125;\"&gt; &lt;option value=\"陕西\" &gt;陕西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\" selected&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"qq\"&gt;QQ：&lt;/label&gt; &lt;input type=\"text\" id=\"qq\" class=\"form-control\" value=\"$&#123;user.qq&#125;\" name=\"qq\" placeholder=\"请输入QQ号码\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"email\"&gt;Email：&lt;/label&gt; &lt;input type=\"text\" id=\"email\" class=\"form-control\" value=\"$&#123;user.email&#125;\" name=\"email\" placeholder=\"请输入邮箱地址\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"text-align: center\"&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" value=\"提交\" /&gt; &lt;input class=\"btn btn-default\" type=\"reset\" value=\"重置\" /&gt; &lt;a class=\"btn btn-default\" href=\"$&#123;pageContext.request.contextPath&#125;/userListServlet\"&gt;返回&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; FindUserServlet12345678910111213141516171819202122232425262728293031323334package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/findUserServlet\")public class FindUserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取id String id = req.getParameter(\"id\"); //2.调用Service查询 UserService service = new UserServiceImpl(); User user = service.findUserById(id); //3.将user存入request req.setAttribute(\"user\",user); //4.转发到update.jsp req.getRequestDispatcher(\"/update.jsp\").forward(req,resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; UpdateUserServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(\"/updateUserServlet\")public class UpdateUserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置编码 req.setCharacterEncoding(\"utf-8\"); //2.获取map Map&lt;String, String[]&gt; map = req.getParameterMap(); //3.封装对象 User user = new User(); try &#123; BeanUtils.populate(user,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; //4.调用Service修改 UserService service = new UserServiceImpl(); service.updateUser(user); //5.跳转到查询所有Servlet resp.sendRedirect(req.getContextPath()+\"/userListServlet\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 删除思路通过获取到对应的id即可到servlet中处理，操作数据库删除，在进行删除的时候可出现提示框 DelUserServlet12345678910111213141516171819202122232425262728293031package cn.guizimo.little.web.servlet;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/delUserServlet\")public class DelUserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取id String id = req.getParameter(\"id\"); //2.调用service删除 UserService service = new UserServiceImpl(); service.deleteUser(id); //3.跳转到查询所有Servlet resp.sendRedirect(req.getContextPath()+\"/userListServlet\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 删除选择的多个思路和删除差不多，最主要是获取id的集合 DelSelectedServlet12345678910111213141516171819202122232425262728293031package cn.guizimo.little.web.servlet;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/delSelectedServlet\")public class DelSelectedServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取所有id String[] ids = req.getParameterValues(\"uid\"); //2.调用service删除 UserService service = new UserServiceImpl(); service.delSelectedUser(ids); //3.跳转查询所有Servlet resp.sendRedirect(req.getContextPath()+\"/userListServlet\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 分页思路在jsp中获取查询的总条数，每页显示的条数，当前的页码，将之传递给服务器，操作数据库进行查询 list.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/28 Time: 下午2:15 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; td, th &#123; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; function deleteUser(id) &#123; //用户安全提示 if (confirm(\"您确定要删除吗？\")) &#123; //访问路径 location.href = \"$&#123;pageContext.request.contextPath&#125;/delUserServlet?id=\" + id; &#125; &#125; window.onload = function () &#123; //给删除选中按钮添加单击事件 document.getElementById(\"delSelected\").onclick = function () &#123; if (confirm(\"您确定要删除选中条目吗？\")) &#123; var flag = false; //判断是否有选中条目 var cbs = document.getElementsByName(\"uid\"); for (var i = 0; i &lt; cbs.length; i++) &#123; if (cbs[i].checked) &#123; //有一个条目选中了 flag = true; break; &#125; &#125; if (flag) &#123;//有条目被选中 //表单提交 document.getElementById(\"form\").submit(); &#125; &#125; &#125; //1.获取第一个cb document.getElementById(\"firstCb\").onclick = function () &#123; //2.获取下边列表中所有的cb var cbs = document.getElementsByName(\"uid\"); //3.遍历 for (var i = 0; i &lt; cbs.length; i++) &#123; //4.设置这些cbs[i]的checked状态 = firstCb.checked cbs[i].checked = this.checked; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;h3 style=\"text-align: center\"&gt;用户信息列表&lt;/h3&gt; &lt;div style=\"float: left;\"&gt; &lt;form class=\"form-inline\" action=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName2\"&gt;姓名&lt;/label&gt; &lt;input type=\"text\" name=\"name\" value=\"$&#123;condition.name[0]&#125;\" class=\"form-control\" id=\"exampleInputName2\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName3\"&gt;籍贯&lt;/label&gt; &lt;input type=\"text\" name=\"address\" value=\"$&#123;condition.address[0]&#125;\" class=\"form-control\" id=\"exampleInputName3\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail2\"&gt;邮箱&lt;/label&gt; &lt;input type=\"text\" name=\"email\" value=\"$&#123;condition.email[0]&#125;\" class=\"form-control\" id=\"exampleInputEmail2\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style=\"float: right;margin: 5px;\"&gt; &lt;a class=\"btn btn-primary\" href=\"$&#123;pageContext.request.contextPath&#125;/add.jsp\"&gt;添加联系人&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"javascript:void(0);\" id=\"delSelected\"&gt;删除选中&lt;/a&gt; &lt;/div&gt; &lt;form id=\"form\" action=\"$&#123;pageContext.request.contextPath&#125;/delSelectedServlet\" method=\"post\"&gt; &lt;table border=\"1\" class=\"table table-bordered table-hover\"&gt; &lt;tr class=\"success\"&gt; &lt;th&gt;&lt;input type=\"checkbox\" id=\"firstCb\"&gt;&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;pb.list&#125;\" var=\"user\" varStatus=\"s\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" name=\"uid\" value=\"$&#123;user.id&#125;\"&gt;&lt;/td&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-default btn-sm\" href=\"$&#123;pageContext.request.contextPath&#125;/findUserServlet?id=$&#123;user.id&#125;\"&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=\"btn btn-default btn-sm\" href=\"javascript:deleteUser($&#123;user.id&#125;);\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;c:if test=\"$&#123;pb.currentPage == 1&#125;\"&gt; &lt;li class=\"disabled\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=1&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;pb.currentPage != 1&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage - 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:forEach begin=\"1\" end=\"$&#123;pb.totalPage&#125;\" var=\"i\"&gt; &lt;c:if test=\"$&#123;pb.currentPage == i&#125;\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\"&gt;$&#123;i&#125;&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;pb.currentPage != i&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\"&gt;$&#123;i&#125;&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;c:if test=\"$&#123;pb.currentPage == pb.totalPage&#125;\"&gt; &lt;li class=\"disabled\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.totalPage&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;pb.currentPage != pb.totalPage&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage + 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;span style=\"font-size: 25px;margin-left: 5px;\"&gt; 共$&#123;pb.totalCount&#125;条记录，共$&#123;pb.totalPage&#125;页 &lt;/span&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; FindUserByPageServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.PageBean;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Map;@WebServlet(\"/findUserByPageServlet\")public class FindUserByPageServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); //1.获取参数 String currentPage = request.getParameter(\"currentPage\");//当前页码 String rows = request.getParameter(\"rows\");//每页显示条数 if(currentPage == null || \"\".equals(currentPage))&#123; currentPage = \"1\"; &#125; if(rows == null || \"\".equals(rows))&#123; rows = \"5\"; &#125; //获取条件查询参数 Map&lt;String, String[]&gt; condition = request.getParameterMap(); //2.调用service查询 UserService service = new UserServiceImpl(); PageBean&lt;User&gt; pb = service.findUserByPage(currentPage,rows,condition); System.out.println(pb); //3.将PageBean存入request request.setAttribute(\"pb\",pb); request.setAttribute(\"condition\",condition);//将查询条件存入request //4.转发到list.jsp request.getRequestDispatcher(\"/list.jsp\").forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 测试 条件查询思路主要是在sql语句的编写 jsp12345678910111213141516171819&lt;div style=\"float: left;\"&gt; &lt;form class=\"form-inline\" action=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName2\"&gt;姓名&lt;/label&gt; &lt;input type=\"text\" name=\"name\" value=\"$&#123;condition.name[0]&#125;\" class=\"form-control\" id=\"exampleInputName2\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName3\"&gt;籍贯&lt;/label&gt; &lt;input type=\"text\" name=\"address\" value=\"$&#123;condition.address[0]&#125;\" class=\"form-control\" id=\"exampleInputName3\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail2\"&gt;邮箱&lt;/label&gt; &lt;input type=\"text\" name=\"email\" value=\"$&#123;condition.email[0]&#125;\" class=\"form-control\" id=\"exampleInputEmail2\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; dao层方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Override public int findTotalCount(Map&lt;String, String[]&gt; condition) &#123; //1.定义模板初始化sql String sql = \"select count(*) from user where 1 = 1 \"; StringBuilder sb = new StringBuilder(sql); //2.遍历map Set&lt;String&gt; keySet = condition.keySet(); //定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) &#123; //排除分页条件参数 if(\"currentPage\".equals(key) || \"rows\".equals(key))&#123; continue; &#125; //获取value String value = condition.get(key)[0]; //判断value是否有值 if(value != null &amp;&amp; !\"\".equals(value))&#123; //有值 sb.append(\" and \"+key+\" like ? \"); params.add(\"%\"+value+\"%\");//？条件的值 &#125; &#125; System.out.println(sb.toString()); System.out.println(params); return template.queryForObject(sb.toString(),Integer.class,params.toArray()); &#125; @Override public List&lt;User&gt; findByPage(int start, int rows, Map&lt;String, String[]&gt; condition) &#123; String sql = \"select * from user where 1 = 1 \"; StringBuilder sb = new StringBuilder(sql); //2.遍历map Set&lt;String&gt; keySet = condition.keySet(); //定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) &#123; //排除分页条件参数 if(\"currentPage\".equals(key) || \"rows\".equals(key))&#123; continue; &#125; //获取value String value = condition.get(key)[0]; //判断value是否有值 if(value != null &amp;&amp; !\"\".equals(value))&#123; //有值 sb.append(\" and \"+key+\" like ? \"); params.add(\"%\"+value+\"%\");//？条件的值 &#125; &#125; //添加分页查询 sb.append(\" limit ?,? \"); //添加分页查询参数值 params.add(start); params.add(rows); sql = sb.toString(); System.out.println(sql); System.out.println(params); return template.query(sql,new BeanPropertyRowMapper&lt;User&gt;(User.class),params.toArray()); &#125; 测试 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"JSP--EL表达式","slug":"JSP--EL表达式","date":"2020-06-28T05:10:48.000Z","updated":"2020-07-29T16:01:34.000Z","comments":true,"path":"2020/06/28/JSP--EL表达式/","link":"","permalink":"https://tangleia.github.io/2020/06/28/JSP--EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"JSP–EL表达式","text":"JSP–EL表达式 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念Expression Language 表达式语言 JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null 作用替换和简化jsp页面中java代码的编写 语法1$&#123;表达式&#125; 注意 jsp默认支持el表达式的。如果要忽略el表达式 设置jsp中page指令中 1isELIgnored&#x3D;&quot;true&quot; 忽略当前jsp页面中所有的el表达式 忽略当前这个el表达式 1\\$&#123;表达式&#125; 使用运算 运算符： 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 获取值 el表达式只能从域对象中获取值 语法： ${域名称.键名}：从指定域中获取指定键的值 域名称： pageScope –&gt; pageContext requestScope –&gt; request sessionScope –&gt; session applicationScope –&gt; application（ServletContext） 举例：在request域中存储了name=张三 获取：${requestScope.name} ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名} 本质上会去调用对象的getter方法 List集合：${域名称.键名[索引]} Map集合： ${域名称.键名.key名称} ${域名称.键名[“key名称”]} 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"JSP--JSTL（JSP标准标签库）","slug":"JSP--JSTL（JSP标准标签库）","date":"2020-06-28T03:57:11.000Z","updated":"2020-07-29T16:02:46.000Z","comments":true,"path":"2020/06/28/JSP--JSTL（JSP标准标签库）/","link":"","permalink":"https://tangleia.github.io/2020/06/28/JSP--JSTL%EF%BC%88JSP%E6%A0%87%E5%87%86%E6%A0%87%E7%AD%BE%E5%BA%93%EF%BC%89/","excerpt":"JSP–JSTL（JSP标准标签库）","text":"JSP–JSTL（JSP标准标签库） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 作用用于简化和替换jsp页面上的java代码 安装菜鸟教程文档地址 https://www.runoob.com/jsp/jsp-jstl.html 下载地址 官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/ 菜鸟教程下载地址：jakarta-taglibs-standard-1.1.2.zip 下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文件：standard.jar 和 jstl.jar 文件拷贝到 /WEB-INF/lib/ 下。 将 tld 下的需要引入的 tld 文件复制到 WEB-INF 目录下。 接下来我们在 web.xml 文件中添加以下配置： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt; &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/fmt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/fmt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/fmt-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/fmt-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/core&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/c.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/core-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/c-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/sql&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/sql.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/sql-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/sql-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/x&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/x.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/x-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/x-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; 使用步骤 导入jstl相关jar包 引入标签库：taglib指令： 1&lt;%@ taglib %&gt; 使用标签 常用的JSTL标签if–相当于java代码的if语句 属性： test 必须属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 注意： c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 choose–相当于java代码的switch语句 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default foreach–相当于java代码的for语句感谢 菜鸟教程 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--MVC开发模式","slug":"Java--MVC开发模式","date":"2020-06-28T03:23:16.000Z","updated":"2020-07-29T15:26:04.000Z","comments":true,"path":"2020/06/28/Java--MVC开发模式/","link":"","permalink":"https://tangleia.github.io/2020/06/28/Java--MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","excerpt":"Java–MVC开发模式","text":"Java–MVC开发模式 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ Jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 MVC开发模式示意图 再来一张 M：Model–模型–JavaBeanModel层：Model指模型部分，一般在应用中Model层包括业务处理层Service和数据访问层Dao。数据访问层主要是对数据库的一些操作的封装。业务处理层主要是用作将从Controller层获取的数据和数据库的数据进行桥接。除此以外，对复杂业务逻辑进行处理,比如事务处理 完成具体的业务操作，如：查询数据库，封装对象 V：View–视图–JSPView层：View指视图部分，这一部分的内容是展示给用户实际进行交互的，通常使用JSP和HTML进行构建 展示数据 C：Controller–控制器–ServletController层：Controller指控制部分，一般是对View层提交的请求为其设置对应的Servlet进行特定功能的处理，这里的进行特定功能的处理一般是编写在Model中的业务处理层中的。Controller一般只是在Web应用中充当一个中介者的作用 获取用户的输入 调用模型 将数据交给视图进行展示 优缺点 优点： 耦合性低，方便维护，可以利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"十大排序算法的分析","slug":"十大排序算法的分析","date":"2020-06-27T07:49:25.000Z","updated":"2020-07-29T15:09:05.000Z","comments":true,"path":"2020/06/27/十大排序算法的分析/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90/","excerpt":"十大排序算法的分析","text":"十大排序算法的分析 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 十大算法比对图（来自尚硅谷） 相关术语解释稳定如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序所有排序操作都在内存中完成； 外排序由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度 一个算法执行所耗费的时间。 空间复杂度运行完一个程序所需内存的大小。 n数据规模 k“桶”的个数 In-place不占用额外内存 Out-place占用额外内存 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"基数排序（Java）","slug":"基数排序（Java）","date":"2020-06-27T07:36:30.000Z","updated":"2020-07-29T15:06:50.000Z","comments":true,"path":"2020/06/27/基数排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"基数排序（Java）","text":"基数排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 基数排序(桶排序)介绍基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 基数排序(Radix Sort)是桶排序的扩展 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序基本思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 特点空间换时间，稳定 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.guizimo.sort;import java.util.Arrays;public class RadixSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;53,45,6,378,15,234,78&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); radixSort(arr); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void radixSort(int arr[]) &#123; //获取最大位数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //计算位数 int maxLength = (max + \"\").length(); int[][] bucket = new int[10][arr.length]; int[] bucketElemtCounts = new int[10]; for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; int digitOfElemt = arr[j] / n % 10; bucket[digitOfElemt][bucketElemtCounts[digitOfElemt]] = arr[j]; bucketElemtCounts[digitOfElemt]++; &#125; int index = 0; for (int k = 0; k &lt; bucketElemtCounts.length; k++) &#123; if (bucketElemtCounts[k] != 0) &#123; for (int l = 0; l &lt; bucketElemtCounts[k]; l++) &#123; arr[index++] = bucket[k][l]; &#125; &#125; bucketElemtCounts[k] = 0; &#125; System.out.println(\"第\"+(i+1)+\"轮排序\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 测试速度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.guizimo.sort;import java.util.Arrays;public class RadixSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 80000); &#125; long date1 = System.currentTimeMillis(); radixSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"位移式希尔排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void radixSort(int arr[]) &#123; //获取最大位数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //计算位数 int maxLength = (max + \"\").length(); int[][] bucket = new int[10][arr.length]; int[] bucketElemtCounts = new int[10]; for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; int digitOfElemt = arr[j] / n % 10; bucket[digitOfElemt][bucketElemtCounts[digitOfElemt]] = arr[j]; bucketElemtCounts[digitOfElemt]++; &#125; int index = 0; for (int k = 0; k &lt; bucketElemtCounts.length; k++) &#123; if (bucketElemtCounts[k] != 0) &#123; for (int l = 0; l &lt; bucketElemtCounts[k]; l++) &#123; arr[index++] = bucket[k][l]; &#125; &#125; bucketElemtCounts[k] = 0; &#125; &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"归并排序（Java）","slug":"归并排序（Java）","date":"2020-06-27T06:41:48.000Z","updated":"2020-07-29T15:06:41.000Z","comments":true,"path":"2020/06/27/归并排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"归并排序（Java）","text":"归并排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 归并排序介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.guizimo.sort;import java.util.Arrays;public class MergetSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; int temp[] = new int[arr.length]; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); mergeSort(arr, 0, arr.length - 1, temp); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; mergeSort(arr, left, mid, temp); mergeSort(arr, mid + 1, right, temp); merge(arr, left, mid, right, temp); &#125; &#125; public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; int j = mid + 1; int t = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; temp[t] = arr[j]; t += 1; j += 1; &#125; &#125; while (i &lt;= mid) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; while (j &lt;= right) &#123; temp[t] = arr[j]; t += 1; j += 1; &#125; t = 0; int tempIndex = left; while (tempIndex &lt;= right) &#123; arr[tempIndex] = temp[t]; t += 1; tempIndex += 1; &#125; &#125;&#125; 测试 速度测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.guizimo.sort;import java.util.Arrays;public class MergetSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; int temp[] = new int[arr.length]; long date1 = System.currentTimeMillis(); mergeSort(arr, 0, arr.length - 1, temp); long date2 = System.currentTimeMillis(); System.out.println(\"归并排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; mergeSort(arr, left, mid, temp); mergeSort(arr, mid + 1, right, temp); merge(arr, left, mid, right, temp); &#125; &#125; public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; int j = mid + 1; int t = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; temp[t] = arr[j]; t += 1; j += 1; &#125; &#125; while (i &lt;= mid) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; while (j &lt;= right) &#123; temp[t] = arr[j]; t += 1; j += 1; &#125; t = 0; int tempIndex = left; while (tempIndex &lt;= right) &#123; arr[tempIndex] = temp[t]; t += 1; tempIndex += 1; &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"交换排序之快速排序（Java）","slug":"交换排序之快速排序（Java）","date":"2020-06-27T05:39:54.000Z","updated":"2020-07-29T15:07:06.000Z","comments":true,"path":"2020/06/27/交换排序之快速排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"交换排序之快速排序（Java）","text":"交换排序之快速排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 快速排序法介绍快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.guizimo.sort;import java.util.Arrays;public class QuickSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;-9, 78, 0, 23, -587, 71&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); quickSort(arr, 0, arr.length - 1); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void quickSort(int[] arr, int left, int right) &#123; int l = left; int r = right; int temp = 0; int pivot = arr[(left + right) / 2]; while (l &lt; r) &#123; while (arr[l] &lt; pivot) &#123; l += 1; &#125; while (arr[r] &gt; pivot) &#123; r -= 1; &#125; if (l &gt;= r) &#123; break; &#125; temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; if (arr[l] == pivot) &#123; r -= 1; &#125; if (arr[r] == pivot) &#123; l += 1; &#125; &#125; if (l == r) &#123; l += 1; r -= 1; &#125; //向左递归 if (left &lt; r) &#123; quickSort(arr, left, r); &#125; //向右递归 if (right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125;&#125; 测试 测试速度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.guizimo.sort;import java.util.Arrays;public class QuickSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); quickSort(arr, 0, arr.length - 1); long date2 = System.currentTimeMillis(); System.out.println(\"快速排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void quickSort(int[] arr, int left, int right) &#123; int l = left; int r = right; int temp = 0; int pivot = arr[(left + right) / 2]; while (l &lt; r) &#123; while (arr[l] &lt; pivot) &#123; l += 1; &#125; while (arr[r] &gt; pivot) &#123; r -= 1; &#125; if (l &gt;= r) &#123; break; &#125; temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; if (arr[l] == pivot) &#123; r -= 1; &#125; if (arr[r] == pivot) &#123; l += 1; &#125; &#125; if (l == r) &#123; l += 1; r -= 1; &#125; //向左递归 if (left &lt; r) &#123; quickSort(arr, left, r); &#125; //向右递归 if (right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"插入排序之希尔排序（Java）","slug":"插入排序之希尔排序（Java）","date":"2020-06-27T03:45:20.000Z","updated":"2020-07-29T15:02:34.000Z","comments":true,"path":"2020/06/27/插入排序之希尔排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"插入排序之希尔排序（Java）","text":"插入排序之希尔排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 希尔排序法介绍希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序法基本思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 代码（交换式）12345678910111213141516171819202122232425262728293031323334package cn.guizimo.sort;import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); shellSort(arr); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void shellSort(int[] arr) &#123; int count = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; count++; int temp = 0; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i - gap; j &gt;= 0; j -= gap) &#123; if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; &#125; &#125; &#125; System.out.println(\"第\"+count+\"轮排序\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 测试速度123456789101112131415161718192021222324252627282930313233package cn.guizimo.sort;import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); shellSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"交换式希尔排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void shellSort(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; int temp = 0; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i - gap; j &gt;= 0; j -= gap) &#123; if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; &#125; &#125; &#125; &#125; &#125;&#125; 代码（位移式）123456789101112131415161718192021222324252627282930313233343536package cn.guizimo.sort;import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); shellSort(arr); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void shellSort(int[] arr) &#123; int count = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; count++; for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[i]; if(arr[j]&lt;arr[j-gap])&#123; while (j-gap &gt;= 0 &amp;&amp; temp &lt; arr[j-gap])&#123; arr[j] = arr[j-gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125; System.out.println(\"第\"+count+\"轮排序\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 速度测试12345678910111213141516171819202122232425262728293031323334package cn.guizimo.sort;import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); shellSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"位移式希尔排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void shellSort(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[i]; if(arr[j]&lt;arr[j-gap])&#123; while (j-gap &gt;= 0 &amp;&amp; temp &lt; arr[j-gap])&#123; arr[j] = arr[j-gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125; &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"插入排序之直接插入排序（Java）","slug":"插入排序之直接插入排序（Java）","date":"2020-06-26T15:08:42.000Z","updated":"2020-07-29T15:02:48.000Z","comments":true,"path":"2020/06/26/插入排序之直接插入排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B9%8B%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"插入排序之直接插入排序（Java）","text":"插入排序之直接插入排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 插入排序法思想插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 代码12345678910111213141516171819202122232425262728293031package cn.guizimo.sort;import java.util.Arrays;public class InsertSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;12, 28, 3, 109, 50&#125;; System.out.println(\"插入前\"); System.out.println(Arrays.toString(arr)); insertSort(arr); System.out.println(\"插入后\"); System.out.println(Arrays.toString(arr)); &#125; public static void insertSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int insertVal = arr[i]; int insertIndex = i - 1; while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; System.out.println(\"第\" + i + \"轮插入\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 测试速度12345678910111213141516171819202122232425262728293031package cn.guizimo.sort;public class InsertSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); insertSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"冒泡排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void insertSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int insertVal = arr[i]; int insertIndex = i - 1; while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"选择排序之简单选择排序（Java）","slug":"选择排序之简单选择排序（Java）","date":"2020-06-26T14:18:15.000Z","updated":"2020-07-29T15:10:23.000Z","comments":true,"path":"2020/06/26/选择排序之简单选择排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"选择排序之简单选择排序（Java）","text":"选择排序之简单选择排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。 代码1234567891011121314151617181920212223242526272829303132package cn.guizimo.sort;import java.util.Arrays;public class SelectSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;102, 34, 98, 6&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); selectSort(arr); &#125; public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; System.out.println(\"第\" + (i + 1) + \"轮后\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 测试速度1234567891011121314151617181920212223242526272829303132333435package cn.guizimo.sort;import java.util.Arrays;public class SelectSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); selectSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"冒泡排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; &#125; &#125;&#125; 运行的时间与自身的电脑有关 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"交换排序之冒泡排序（java）","slug":"交换排序之冒泡排序（java）","date":"2020-06-26T13:46:42.000Z","updated":"2020-07-29T15:07:15.000Z","comments":true,"path":"2020/06/26/交换排序之冒泡排序（java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88java%EF%BC%89/","excerpt":"交换排序之冒泡排序（java）","text":"交换排序之冒泡排序（java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 代码123456789101112131415161718192021package cn.guizimo.sort;import java.util.Arrays;public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println(\"第\"+(i+1)+\"躺排序后的数组\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 优化减少未曾发生交换的次数 1234567891011121314151617181920212223242526272829303132333435package cn.guizimo.sort;import java.util.Arrays;public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); bubbledSort(arr); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void bubbledSort(int[] arr)&#123; int temp = 0; boolean flag = false; //标识，是否发生交换 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; if(!flag)&#123; //没有发生交换 break; &#125;else &#123; //进行下次交换 flag = false; &#125; &#125; &#125;&#125; 测试 测试速度1234567891011121314151617181920212223242526272829303132333435363738394041package cn.guizimo.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class BubbleSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); bubbledSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"冒泡排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void bubbledSort(int[] arr)&#123; int temp = 0; boolean flag = false; //标识，是否发生交换 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; if(!flag)&#123; //没有发生交换 break; &#125;else &#123; //进行下次交换 flag = false; &#125; &#125; &#125;&#125; 运行的时间与自身的电脑有关 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"算法的时间复杂度和空间复杂度","slug":"算法的时间复杂度和空间复杂度","date":"2020-06-26T12:29:29.000Z","updated":"2020-07-29T15:09:57.000Z","comments":true,"path":"2020/06/26/算法的时间复杂度和空间复杂度/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"算法的时间复杂度和空间复杂度","text":"算法的时间复杂度和空间复杂度 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 算法的时间复杂度时间频度一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。 时间复杂度一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 计算时间复杂度的方法 用常数1代替运行时间中的所有加法常数 修改后的运行次数函数中，只保留最高阶项 去除最高阶项的系数 常见的时间复杂度常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) 1234int i = 1;int j = 2;i++;j++; 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(log2n)1234int i = 1;while(i&lt;n)&#123; i = i * 2;&#125; 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n) 。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) 线性阶O(n)123for(i = 1; i &lt;= n; i++)&#123; j = i;&#125; 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 线性对数阶O(nlog2n)123456for(m =1;m&lt;n;m++)&#123; i = 1; while(i&lt;n)&#123; i = i * 2; &#125;&#125; 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) 平方阶O(n^2)12345for(j=1;j&lt;n;j++)&#123; for(i=1;i&lt;n;i++)&#123; m = j+i; &#125;&#125; 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(nn)，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(mn) 立方阶O(n^3)三层循环 k次方阶O(n^k)k层循环 指数阶O(2^n)常见的算法时间复杂度大小由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低从图中可见， 建议尽可能避免使用指数阶的算法 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关 算法的空间复杂度 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间. 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Session--验证码案例（Java）","slug":"Session--验证码案例（Java）","date":"2020-06-26T10:35:13.000Z","updated":"2020-07-29T16:06:07.000Z","comments":true,"path":"2020/06/26/Session--验证码案例（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/Session--%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A1%88%E4%BE%8B%EF%BC%88Java%EF%BC%89/","excerpt":"Session–验证码案例（Java）","text":"Session–验证码案例（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 案例用户输入用户名，密码以及验证码。 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 如果验证码输入有误，跳转登录页面，提示：验证码错误 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 思路在生成验证码的时候将它的值存入到session中，在比对的时候再取出来进行对比 代码index.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/26 Time: 下午12:48 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; document.getElementById(\"img\").onclick = function()&#123; this.src=\"/login_time_war_exploded/checkCode?time=\"+new Date().getTime(); &#125; &#125; &lt;/script&gt; &lt;style&gt; div&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/login_time_war_exploded/login\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"checkCode\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;img id=\"img\" src=\"/login_time_war_exploded/checkCode\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;div&gt;&lt;%=request.getAttribute(\"cc_error\") == null ? \"\" : request.getAttribute(\"cc_error\")%&gt;&lt;/div&gt;&lt;div&gt;&lt;%=request.getAttribute(\"login_error\") == null ? \"\" : request.getAttribute(\"login_error\") %&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; success.jsp12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/26 Time: 下午6:27 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;%=request.getSession().getAttribute(\"user\")%&gt;,欢迎您&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 验证码checkCode.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.guizimo.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(\"/checkCode\")public class CheckCode extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int width = 100; int height = 50; //创建图片对象 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR); //美化 Graphics g = image.getGraphics(); //背景 g.setColor(Color.PINK); g.fillRect(0, 0, width, height); //边框 g.setColor(Color.BLUE); g.drawRect(0, 0, width - 1, height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; Random ran = new Random(); StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= 4; i++) &#123; int index = ran.nextInt(str.length()); char ch = str.charAt(index); sb.append(ch); g.drawString(ch+\"\",width/5*i,height/2); &#125; String checkCode_session = sb.toString(); //将验证码存入session req.getSession().setAttribute(\"checkCode_session\",checkCode_session); //干扰线 g.setColor(Color.GREEN); for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2= ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); &#125; //输出图片到浏览器 ImageIO.write(image, \"jpg\", resp.getOutputStream()); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; login.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.guizimo.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;@WebServlet(\"/login\")public class Login extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置request编码 req.setCharacterEncoding(\"utf-8\"); //2.获取参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); String checkCode = req.getParameter(\"checkCode\"); //3.先获取生成的验证码 HttpSession session = req.getSession(); String checkCode_session = (String) session.getAttribute(\"checkCode_session\"); //删除session中存储的验证码 //session.removeAttribute(\"checkCode_session\"); //3.先判断验证码是否正确 if(checkCode_session!= null &amp;&amp; checkCode_session.equalsIgnoreCase(checkCode))&#123; //忽略大小写比较 //验证码正确 //判断用户名和密码是否一致 if(\"zhangsan\".equals(username) &amp;&amp; \"123\".equals(password))&#123;//需要调用UserDao查询数据库 //登录成功 //存储信息，用户信息 session.setAttribute(\"user\",username); //重定向到success.jsp resp.sendRedirect(req.getContextPath()+\"/success.jsp\"); &#125;else&#123; //登录失败 //存储提示信息到request req.setAttribute(\"login_error\",\"用户名或密码错误\"); //转发到登录页面 req.getRequestDispatcher(\"/login.jsp\").forward(req,resp); &#125; &#125;else&#123; //验证码不一致 //存储提示信息到request req.setAttribute(\"cc_error\",\"验证码错误\"); //转发到登录页面 req.getRequestDispatcher(\"/login.jsp\").forward(req,resp); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试登录界面 验证码错误 用户名密码错误 登录成功 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"服务端会话技术--Session","slug":"服务端会话技术--Session","date":"2020-06-26T04:40:34.000Z","updated":"2020-07-29T15:06:29.000Z","comments":true,"path":"2020/06/26/服务端会话技术--Session/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF--Session/","excerpt":"服务端会话技术–Session","text":"服务端会话技术–Session 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门 获取HttpSession对象： 1HttpSession session = request.getSession(); 使用HttpSession对象： 123Object getAttribute(String name) void setAttribute(String name, Object value)void removeAttribute(String name) 原理Session的实现是依赖于Cookie的。 细节 当客户端关闭后，服务器不关闭，两次获取Session是否为同一个？ 默认情况下。不是。 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 123Cookie c = new Cookie(\"JSESSIONID\",session.getId()); c.setMaxAge(60*60); response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的Session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 Session的钝化： 在服务器正常关闭之前，将Session对象系列化到硬盘上 Session的活化： 在服务器启动后，将Session文件转化为内存中的Session对象即可。 Session什么时候被销毁？ 服务器关闭 Session对象调用invalidate() 。 Session默认失效时间 30分钟 选择性配置修改 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; Session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--JSP简介","slug":"Java--JSP简介","date":"2020-06-26T04:29:25.000Z","updated":"2020-07-29T15:25:53.000Z","comments":true,"path":"2020/06/26/Java--JSP简介/","link":"","permalink":"https://tangleia.github.io/2020/06/26/Java--JSP%E7%AE%80%E4%BB%8B/","excerpt":"Java–JSP简介","text":"Java–JSP简介 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明JSP（全称JavaServer Pages）是由Su 公司主导创建的一种动态网页技术标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、XML或其他格式文档的Web网页，然后返回给请求者。JSP技术以Java语言作为脚本语言，为用户的HTTP请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 原理JSP本质上就是一个Servlet JSP的脚本JSP定义Java代码的方式 &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 JSP的内置对象 在jsp页面中不需要获取和创建，可以直接使用的对象 out：JSPWriter，用来写入响应流的数据 page：servlet自身 pageContext：一个PageContext实例包括和整个页面相联系的数据，一个给定的HTML页面可以在多个JSP之间传递。 request：HTTP request（请求）对象 response：HTTP response（响应）对象 session：HTTP session（服务端会话）对象 JSP动作JSP动作是一系列可以调用内建于网络服务器中的功能的XML标签。JSP提供了以下动作： jsp:include 和子过程类似，JAVA SERVLET暂时接管对其它指定的JSP页的请求和响应。当处理完该JSP页后就马上把控制权交还当前JSP页。这样JSP代码就可以在多个JSP页中共享而不用复制。 jsp:param 可以在jsp:include, jsp:forward或jsp:params块之间使用。指定一个将加入请求的当前参数组中的参数。 jsp:forward 用于处理对另一个JSP或SERVLET的请求和响应。控制权永远不会交还给当前JSP页。 jsp:plugin Netscape Navigator使用不同的标签以嵌入一个applet。这个动作产生为嵌入一个APPLET所需要的指定浏览器标签。 jsp:fallback 如果浏览器不支持APPLETS则会显示的内容。 jsp:getProperty 从指定的JavaBean中获取一个属性值。 jsp:setProperty 在指定的JavaBean中设置一个属性值。 jsp:useBean 创建或者复用一个JavaBean变量到JSP页。 为什么使用JSPJSP程序与CGI程序有着相似的功能，但和CGI程序相比，JSP程序有如下优势： 性能更加优越，因为JSP可以直接在HTML网页中动态嵌入元素而不需要单独引用CGI文件。 服务器调用的是已经编译好的JSP文件，而不像CGI/Perl那样必须先载入解释器和目标脚本。 JSP 基于Java Servlet API，因此，JSP拥有各种强大的企业级Java API，包括JDBC，JNDI，EJB，JAXP等等。 JSP页面可以与处理业务逻辑的 Servlet 一起使用，这种模式被Java servlet 模板引擎所支持。 最后，JSP是Java EE不可或缺的一部分，是一个完整的企业级应用平台。这意味着JSP可以用最简单的方式来实现最复杂的应用。 感谢 百度百科 菜鸟教程 以及勤劳的自己","categories":[],"tags":[]},{"title":"Cookie--记住上一次访问时间案例（Java）","slug":"Cookie--记住上一次访问时间案例（Java）","date":"2020-06-26T02:56:26.000Z","updated":"2020-07-29T15:11:50.000Z","comments":true,"path":"2020/06/26/Cookie--记住上一次访问时间案例（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/Cookie--%E8%AE%B0%E4%BD%8F%E4%B8%8A%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E6%A1%88%E4%BE%8B%EF%BC%88Java%EF%BC%89/","excerpt":"Cookie–记住上一次访问时间案例（Java）","text":"Cookie–记住上一次访问时间案例（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 需求 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 分析 可以采用Cookie来完成 在服务器中的Servlet判断是否有一个名为lastTime的cookie 有：不是第一次访问 响应数据：欢迎回来，您上次访问时间为:2020年06月26日 10:52:29 写回Cookie：lastTime=2020年06月26日 10:52:29 没有：是第一次访问 响应数据：您好，欢迎您首次访问 写回Cookie：lastTime=2020年06月26日 10:52:29 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.guizimo.cookie;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URLDecoder;import java.net.URLEncoder;import java.text.SimpleDateFormat;import java.util.Date;@WebServlet(\"/cookieTest\")public class CookieTest extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置响应的编码 resp.setContentType(\"text/html;charset=utf-8\"); boolean flag = false; //获取所有的cookie Cookie[] cookies = req.getCookies(); if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie cookie : cookies) &#123; String name = cookie.getName(); //判断是否第一次登录 if (\"lastTime\".equals(name)) &#123; //获取当前时间，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str_date = sdf.format(date); //编码 str_date = URLEncoder.encode(str_date, \"utf-8\"); cookie.setValue(str_date); //设置存活时间，一个月 cookie.setMaxAge(60 * 60 * 24 * 30); resp.addCookie(cookie); //响应数据 String value = cookie.getValue(); //解码 value = URLDecoder.decode(value, \"utf-8\"); resp.getWriter().write(\"&lt;h1&gt;欢迎回来，您上次的登录时间为：\" + value + \"&lt;/h1&gt;\"); &#125; &#125; &#125; if (cookies == null || cookies.length == 0 || flag == false) &#123; //获取当前时间，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str_date = sdf.format(date); //编码 str_date = URLEncoder.encode(str_date, \"utf-8\"); Cookie cookie = new Cookie(\"lastTime\", str_date); //设置存活时间，一个月 cookie.setMaxAge(60 * 60 * 24 * 30); resp.addCookie(cookie); resp.getWriter().write(\"&lt;h1&gt;欢迎首次访问&lt;/h1&gt;\"); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试第一次访问 再次访问 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"客户端会话技术--Cookie","slug":"客户端会话技术--Cookie","date":"2020-06-26T01:36:53.000Z","updated":"2020-07-29T15:07:29.000Z","comments":true,"path":"2020/06/26/客户端会话技术--Cookie/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF--Cookie/","excerpt":"客户端会话技术–Cookie","text":"客户端会话技术–Cookie 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念客户端会话技术，将数据保存到客户端 快速入门 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理基于响应头set-cookie和请求头cookie实现 cookie的细节处理 一次可不可以发送多个cookie? 可以 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码—一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为”/“ 不同的tomcat服务器间cookie共享问题？ setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--ServletContext对象","slug":"Java--ServletContext对象","date":"2020-06-25T14:02:49.000Z","updated":"2020-07-29T15:28:36.000Z","comments":true,"path":"2020/06/25/Java--ServletContext对象/","link":"","permalink":"https://tangleia.github.io/2020/06/25/Java--ServletContext%E5%AF%B9%E8%B1%A1/","excerpt":"Java–ServletContext对象","text":"Java–ServletContext对象 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念代表整个web应用，可以和程序的容器(服务器)来通信 获取 通过request对象获取 1request.getServletContext(); 通过HttpServlet获取 1this.getServletContext(); 功能 获取MIME类型： MIME类型: 在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取： 1String getMimeType(String file) 域对象：共享数据 ServletContext对象范围：所有用户所有请求的数据 常用方法 123setAttribute(String name,Object value)getAttribute(String name)removeAttribute(String name) 获取文件的真实(服务器)路径 123456789String getRealPath(String path) String b = context.getRealPath(\"/b.txt\");//web目录下资源访问System.out.println(b);String c = context.getRealPath(\"/WEB-INF/c.txt\");//WEB-INF目录下的资源访问System.out.println(c);String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//src目录下的资源访问System.out.println(a); 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"动态生成验证码案例（Java）","slug":"动态生成验证码案例（Java）","date":"2020-06-25T13:43:04.000Z","updated":"2020-07-29T15:06:18.000Z","comments":true,"path":"2020/06/25/动态生成验证码案例（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A1%88%E4%BE%8B%EF%BC%88Java%EF%BC%89/","excerpt":"动态生成验证码案例（Java）","text":"动态生成验证码案例（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ servlet代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.guizimo.web.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(\"/checkCode\")public class CheckCode extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int width = 100; int height = 50; //创建图片对象 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR); //美化 Graphics g = image.getGraphics(); //背景 g.setColor(Color.PINK); g.fillRect(0, 0, width, height); //边框 g.setColor(Color.BLUE); g.drawRect(0, 0, width - 1, height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; Random ran = new Random(); for (int i = 1; i &lt;= 4; i++) &#123; int index = ran.nextInt(str.length()); char ch = str.charAt(index); g.drawString(ch+\"\",width/5*i,height/2); &#125; //干扰线 g.setColor(Color.GREEN); for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2= ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); &#125; //输出图片到浏览器 ImageIO.write(image, \"jpg\", resp.getOutputStream()); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var img = document.getElementById(\"checkCode\"); img.onclick = function () &#123; var data = new Date().getTime(); img.src = \"/tomcat_test_war_exploded/checkCode?\" + data; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img id=\"checkCode\" src=\"/tomcat_test_war_exploded/checkCode\"/&gt;&lt;/body&gt;&lt;/html&gt; 启动项目 点击图片可以切换验证码 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"HTTP–Response详解","slug":"HTTP–Response详解","date":"2020-06-25T10:14:35.000Z","updated":"2020-07-29T15:25:01.000Z","comments":true,"path":"2020/06/25/HTTP–Response详解/","link":"","permalink":"https://tangleia.github.io/2020/06/25/HTTP%E2%80%93Response%E8%AF%A6%E8%A7%A3/","excerpt":"HTTP–Response详解","text":"HTTP–Response详解 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 响应消息数据格式响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态 态码都是3位数字 分类： 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误 404（请求路径没有对应的资源） 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：头名称： 值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 in-line:默认值,在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行响应体:传输的数据响应字符串格式 123456789101112131415HTTP&#x2F;1.1 200 OKContent-Type: text&#x2F;html;charset&#x3D;UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; hello , response &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Response对象设置响应消息 设置响应行 格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 设置响应头：setHeader(String name, String value) 设置响应体： 使用步骤： 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"完整逆波兰计算器（Java）","slug":"完整逆波兰计算器（Java）","date":"2020-06-25T09:43:54.000Z","updated":"2020-07-29T15:10:08.000Z","comments":true,"path":"2020/06/25/完整逆波兰计算器（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E5%AE%8C%E6%95%B4%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%88Java%EF%BC%89/","excerpt":"完整逆波兰计算器（Java）","text":"完整逆波兰计算器（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 功能支持 + - * / ( )多位数，支持小数,兼容处理, 过滤任何空白字符，包括空格、制表符、换页符 基本思路中缀表达式转后缀表达式 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;import java.util.Collections;import java.util.regex.Pattern;public class ReversePolishMultiCalc &#123; //匹配运算符 static final String SYMBOL = \"\\\\+|-|\\\\*|/|\\\\(|\\\\)\"; static final String LEFT = \"(\"; static final String RIGHT = \")\"; static final String ADD = \"+\"; static final String MINUS = \"-\"; static final String TIMES = \"*\"; static final String DIVISION = \"/\"; //优先级 static final int LEVEL_01 = 1; static final int LEVEL_02 = 2; static final int LEVEL_HIGH = Integer.MAX_VALUE; static Stack&lt;String&gt; stack = new Stack&lt;&gt;(); static List&lt;String&gt; data = Collections.synchronizedList(new ArrayList&lt;String&gt;()); //去除所有空白符号 public static String replaceAllBlank(String s) &#123; return s.replaceAll(\"\\\\s+\", \"\"); &#125; //判断是否为数字 public static boolean isNumber(String s) &#123; Pattern pattern = Pattern.compile(\"^[-\\\\+]?[.\\\\d]*$\"); return pattern.matcher(s).matches(); &#125; //判断是否是运算符 public static boolean isSymbol(String s) &#123; return s.matches(SYMBOL); &#125; //匹配运算优先级 public static int calcLevel(String s) &#123; if (\"+\".equals(s) || \"-\".equals(s)) &#123; return LEVEL_01; &#125; else if (\"*\".equals(s) || \"/\".equals(s)) &#123; return LEVEL_02; &#125; return LEVEL_HIGH; &#125; //匹配 public static List&lt;String&gt; doMatch(String s) throws Exception &#123; if (s == null || \"\".equals(s.trim())) throw new RuntimeException(\"data is empty\"); if (!isNumber(s.charAt(0) + \"\")) throw new RuntimeException(\"data illeagle,start not with a number\"); s = replaceAllBlank(s); String each; int start = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (isSymbol(s.charAt(i) + \"\")) &#123; each = s.charAt(i) + \"\"; if (stack.isEmpty() || LEFT.equals(each) || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH)) &#123; stack.push(each); &#125; else if (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek())) &#123; while (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek())) &#123; if (calcLevel(stack.peek()) == LEVEL_HIGH) &#123; break; &#125; data.add(stack.pop()); &#125; stack.push(each); &#125; else if (RIGHT.equals(each)) &#123; while (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek())) &#123; if (LEVEL_HIGH == calcLevel(stack.peek())) &#123; stack.pop(); break; &#125; data.add(stack.pop()); &#125; &#125; start = i; &#125; else if (i == s.length() - 1 || isSymbol(s.charAt(i + 1) + \"\")) &#123; each = start == 0 ? s.substring(start, i + 1) : s.substring(start + 1, i + 1); if (isNumber(each)) &#123; data.add(each); continue; &#125; throw new RuntimeException(\"data not match number\"); &#125; &#125; Collections.reverse(stack); data.addAll(new ArrayList&lt;&gt;(stack)); System.out.println(data); return data; &#125; //计算结果 public static Double doCalc(List&lt;String&gt; list)&#123; Double d = 0d; if(list == null || list.isEmpty())&#123; return null; &#125; if(list.size() == 1)&#123; System.out.println(list); d = Double.valueOf(list.get(0)); return d; &#125; ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; list1.add(list.get(i)); if(isSymbol(list.get(i)))&#123; Double d1 = doTheMath(list.get(i-2),list.get(i-1),list.get(i)); list1.remove(i); list1.remove(i-1); list1.set(i-2,d1+\"\"); list1.addAll(list.subList(i+1,list.size())); break; &#125; &#125; doCalc(list1); return d; &#125; //运算 public static Double doTheMath(String s1,String s2,String symbol)&#123; Double result; switch (symbol)&#123; case ADD: result = Double.valueOf(s1) + Double.valueOf(s2); break; case MINUS: result = Double.valueOf(s1) - Double.valueOf(s2); break; case TIMES: result = Double.valueOf(s1) * Double.valueOf(s2); break; case DIVISION: result = Double.valueOf(s1) / Double.valueOf(s2); break; default: result = null; &#125; return result; &#125; public static void main(String[] args) &#123; String math = \"12.8 + (2-3.55)*4+10/5.0\"; try&#123; doCalc(doMatch(math)); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 结果 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"中缀表达式转换为后缀表达式（Java）","slug":"中缀表达式转换为后缀表达式（Java）","date":"2020-06-25T08:26:38.000Z","updated":"2020-07-29T15:10:33.000Z","comments":true,"path":"2020/06/25/中缀表达式转换为后缀表达式（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Java%EF%BC%89/","excerpt":"中缀表达式转换为后缀表达式（Java）","text":"中缀表达式转换为后缀表达式（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 步骤 初始化两个栈:运算符栈 s1 和储存中间结果的栈 s2 从左至右扫描中缀表达式 遇到操作数时，将其压 s2 遇到运算符时，比较其与 s1 栈顶运算符的优先级: 如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈 否则，若优先级比栈顶运算符的高，也将运算符压入 s1; 否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较; 遇到括号时: 如果是左括号“(”，则直接压入 s1 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 重复步骤 2 至 5，直到表达式的最右边 将 s1 中剩余的运算符依次弹出并压入 s2 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 案例将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下 因此结果为 :”123+4 × +5 –” 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;/** * @author guizimo * @date 2020/4/6 12:25 下午 */public class PolandNotation &#123; public static void main(String[] args) &#123; //表达式 String suffixExpression = \"1+((2+3)*4)-5\"; //中缀表达式对应的List System.out.println(\"中缀表达式对应的List\"); List&lt;String&gt; infixExpressionList = toInfixExpressionList(suffixExpression); System.out.println(infixExpressionList); //后缀表达式对应的List System.out.println(\"后缀表达式对应的List\"); List&lt;String&gt; suffixExpressionList = parseSuffixExpressionList(infixExpressionList); System.out.println(suffixExpressionList); //计算逆波兰表达式 System.out.printf(\"suffixExpression=%d\", calculate(suffixExpressionList)); &#125; public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls) &#123; //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); //符号栈 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;(); //结果 for (String item : ls) &#123; //如果是一个数 if (item.matches(\"\\\\d+\")) &#123; s2.add(item); &#125; else if (item.equals(\"(\")) &#123; s1.push(item); &#125; else if (item.equals(\")\")) &#123; while (!s1.peek().equals(\"(\")) &#123; s2.add(s1.pop()); &#125; s1.pop(); &#125; else &#123; while (s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123; s2.add(s1.pop()); &#125; s1.push(item); &#125; &#125; while (s1.size() != 0) &#123; s2.add(s1.pop()); &#125; return s2; &#125; //将中缀表达式转换成list public static List&lt;String&gt; toInfixExpressionList(String s) &#123; List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int i = 0; String str; //多位数 char c; do &#123; //非数字 if ((c = s.charAt(i)) &lt; 48 || (c = s.charAt(i)) &gt; 57) &#123; ls.add(\"\" + c); i++; &#125; else &#123; //数字，但是考虑到多位数 str = \"\"; while (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= 48 &amp;&amp; (c = s.charAt(i)) &lt;= 57) &#123; str += c; i++; &#125; ls.add(str); &#125; &#125; while (i &lt; s.length()); return ls; &#125; //完成对逆波兰表达式的计算 public static int calculate(List&lt;String&gt; ls) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (String item : ls) &#123; //使用正则表达式 if (item.matches(\"\\\\d+\")) &#123; //匹配多位数 //入栈 stack.push(item); &#125; else &#123; int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals(\"+\")) &#123; res = num1 + num2; &#125; else if (item.equals(\"-\")) &#123; res = num1 - num2; &#125; else if (item.equals(\"*\")) &#123; res = num1 * num2; &#125; else if (item.equals(\"/\")) &#123; res = num1 / num2; &#125; else &#123; throw new RuntimeException(\"运算符有问题\"); &#125; //把结果入栈 stack.push(\"\" + res); &#125; &#125; return Integer.parseInt(stack.pop()); &#125;&#125;class Operation &#123; private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; public static int getValue(String operation) &#123; int result = 0; switch (operation) &#123; case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; default: System.out.println(\"不存在\"); break; &#125; return result; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"递归--迷宫问题（Java）","slug":"递归--迷宫问题（Java）","date":"2020-06-25T08:03:58.000Z","updated":"2020-07-29T15:06:07.000Z","comments":true,"path":"2020/06/25/递归--迷宫问题（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E9%80%92%E5%BD%92--%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%EF%BC%88Java%EF%BC%89/","excerpt":"递归–迷宫问题（Java）","text":"递归–迷宫问题（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题说明制定好小球的移动路线，让它在迷宫里面找到终点的位置 问题思路 创建一个二维数组作为迷宫的地图 制定好小球的起点和终点位置 确定小球的运动规则，如下右上左 使用递归判断小球是否到达终点 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package question;public class Migong &#123; public static void main(String[] args) &#123; //创建一个地图 int[][] map = new int[8][7]; //1表示墙，0表示可以移动，2代表已经走过，3代表失败 //上下为墙 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; //左右为墙 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //设置障碍物 map[3][1] = 1; map[3][2] = 1; //输出地图 System.out.println(\"地图\"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; //递归 setWay(map,1,1); //输出新的地图 System.out.println(\"到达终点地图\"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; &#125; public static boolean setWay(int[][] map,int i,int j)&#123; if(map[6][5] == 2)&#123; //到达终点 return true; &#125;else &#123; if(map[i][j] == 0)&#123; //继续 //制定策略，下右上左 map[i][j] = 2; if(setWay(map,i+1,j))&#123; //向下走 return true; &#125;else if(setWay(map,i,j+1))&#123; //向右走 return true; &#125;else if(setWay(map,i-1,j))&#123; //向上走 return true; &#125;else if(setWay(map,i,j-1))&#123; //向左走 return true; &#125;else &#123; //走不通 map[i][j] = 3; return false; &#125; &#125;else &#123; return false; &#125; &#125; &#125;&#125; 结果 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"递归--八皇后问题（Java）","slug":"递归--八皇后问题（Java）","date":"2020-06-25T07:39:16.000Z","updated":"2020-07-29T15:05:50.000Z","comments":true,"path":"2020/06/25/递归--八皇后问题（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E9%80%92%E5%BD%92--%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88Java%EF%BC%89/","excerpt":"递归–八皇后问题（Java）","text":"递归–八皇后问题（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题介绍八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法 问题思路 第一个皇后先放第一行第一列 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到. 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 代码思路创建一个一维数组代替原本的二维数组，只针对列和斜线的判断 采用循环来判断在第n个皇后的不同列（i）是否冲突 使用递归来判断不同的皇后的情况 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package question;public class Queen &#123; //定义最大的行 int max = 8; //创建一维数组存储每行的列的位置 int[] array = new int[max]; //结果数 static int count = 0; //检查是否冲突的次数 static int judgecount = 0; public static void main(String[] args) &#123; Queen queen = new Queen(); queen.check(0); System.out.printf(\"一共有%d总解法\", count); System.out.println(); System.out.printf(\"一共有%d次判断冲突\", judgecount); &#125; //放置皇后 private void check(int n) &#123; if (n == max) &#123; //已经放置好 //打印函数 print(); return; &#125; //依次放置皇后的列数 for (int i = 0; i &lt; max; i++) &#123; //把皇后放置到该行的第一列 array[n] = i; //判断当前皇后在i列时是否冲突 if (judge(n)) &#123; //不冲突 //接着放n+1个皇后（递归） check(n + 1); &#125; &#125; &#125; //判断是否冲突 private boolean judge(int n) &#123; judgecount++; for (int i = 0; i &lt; n; i++) &#123; //由于n代表行，所以不会出现在同一行的情况，判断是否在同一列，判断是否在同一斜线上 if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123; return false; &#125; &#125; return true; &#125; //打印结果 private void print() &#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + \" \"); &#125; System.out.println(); &#125;&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293940 4 7 5 2 6 1 3 0 5 7 2 6 3 1 4 0 6 3 5 7 1 4 2 0 6 4 7 1 3 5 2 1 3 5 7 2 0 6 4 1 4 6 0 2 7 5 3 1 4 6 3 0 7 5 2 1 5 0 6 3 7 2 4 1 5 7 2 0 3 6 4 1 6 2 5 7 4 0 3 1 6 4 7 0 3 5 2 1 7 5 0 2 4 6 3 2 0 6 4 7 1 3 5 2 4 1 7 0 6 3 5 2 4 1 7 5 3 6 0 2 4 6 0 3 1 7 5 2 4 7 3 0 6 1 5 2 5 1 4 7 0 6 3 2 5 1 6 0 3 7 4 2 5 1 6 4 0 7 3 2 5 3 0 7 4 6 1 2 5 3 1 7 4 6 0 2 5 7 0 3 6 4 1 2 5 7 0 4 6 1 3 2 5 7 1 3 0 6 4 2 6 1 7 4 0 3 5 2 6 1 7 5 3 0 4 2 7 3 6 0 5 1 4 3 0 4 7 1 6 2 5 3 0 4 7 5 2 6 1 3 1 4 7 5 0 2 6 3 1 6 2 5 7 0 4 3 1 6 2 5 7 4 0 3 1 6 4 0 7 5 2 3 1 7 4 6 0 2 5 3 1 7 5 0 2 4 6 3 5 0 4 1 7 2 6 3 5 7 1 6 0 2 4 3 5 7 2 0 6 4 1 3 6 0 7 4 1 5 2 3 6 2 7 1 4 0 5 3 6 4 1 5 0 2 7 3 6 4 2 0 5 7 1 3 7 0 2 5 1 6 4 3 7 0 4 6 1 5 2 3 7 4 2 0 6 1 5 4 0 3 5 7 1 6 2 4 0 7 3 1 6 2 5 4 0 7 5 2 6 1 3 4 1 3 5 7 2 0 6 4 1 3 6 2 7 5 0 4 1 5 0 6 3 7 2 4 1 7 0 3 6 2 5 4 2 0 5 7 1 3 6 4 2 0 6 1 7 5 3 4 2 7 3 6 0 5 1 4 6 0 2 7 5 3 1 4 6 0 3 1 7 5 2 4 6 1 3 7 0 2 5 4 6 1 5 2 0 3 7 4 6 1 5 2 0 7 3 4 6 3 0 2 7 5 1 4 7 3 0 2 5 1 6 4 7 3 0 6 1 5 2 5 0 4 1 7 2 6 3 5 1 6 0 2 4 7 3 5 1 6 0 3 7 4 2 5 2 0 6 4 7 1 3 5 2 0 7 3 1 6 4 5 2 0 7 4 1 3 6 5 2 4 6 0 3 1 7 5 2 4 7 0 3 1 6 5 2 6 1 3 7 0 4 5 2 6 1 7 4 0 3 5 2 6 3 0 7 1 4 5 3 0 4 7 1 6 2 5 3 1 7 4 6 0 2 5 3 6 0 2 4 1 7 5 3 6 0 7 1 4 2 5 7 1 3 0 6 4 2 6 0 2 7 5 3 1 4 6 1 3 0 7 4 2 5 6 1 5 2 0 3 7 4 6 2 0 5 7 4 1 3 6 2 7 1 4 0 5 3 6 3 1 4 7 0 2 5 6 3 1 7 5 0 2 4 6 4 2 0 5 7 1 3 7 1 3 0 6 4 2 5 7 1 4 2 0 6 3 5 7 2 0 5 1 4 6 3 7 3 0 2 5 1 6 4 一共有92总解法一共有15720次判断冲突 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--用户登录（JDBC，MYSQL，Servlet）","slug":"Java--用户登录（JDBC，MYSQL，Servlet）","date":"2020-06-22T05:13:15.000Z","updated":"2020-07-29T15:25:25.000Z","comments":true,"path":"2020/06/22/Java--用户登录（JDBC，MYSQL，Servlet）/","link":"","permalink":"https://tangleia.github.io/2020/06/22/Java--%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%EF%BC%88JDBC%EF%BC%8CMYSQL%EF%BC%8CServlet%EF%BC%89/","excerpt":"Java–用户登录（JDBC，MYSQL，Servlet）","text":"Java–用户登录（JDBC，MYSQL，Servlet） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 用户登录案例需求 编写login.html登录页面username &amp; password 两个输入框 使用Druid数据库连接池技术,操作mysql，day14数据库中user表 使用JdbcTemplate技术封装JDBC 登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 登录页面12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/login_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建数据库123456789CREATE DATABASE login;USE login;CREATE TABLE user( id INT PRIMARY KEY auto_increment, username VARCHAR(32) UNIQUE NOT NULL, password VARCHAR(32) NOT NULL) 配置文件1234567driverClassName&#x3D;com.mysql.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;loginusername&#x3D;rootpassword&#x3D;rootinitialSize&#x3D;5maxActive&#x3D;10maxWait&#x3D;3000 项目依赖 创建用户实体类创建包cn.guizimo.domain,创建类User 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.guizimo.domain;/** * @author tanglei * @date 2020/6/22 10:28 上午 */public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125;&#125; 创建工具类创建包cn.guizimo.util,编写工具类JDBCUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.guizimo.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * @author tanglei * @date 2020/6/22 10:38 上午 */public class JDBCUtils &#123; private static DataSource ds ; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接池对象 */ public static DataSource getDataSource()&#123; return ds; &#125; /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125;&#125; 创建数据操作类创建包cn.guizimo.dao,创建类UserDao,提供login方法 123456789101112131415161718192021222324252627282930package cn.guizimo.dao;import cn.guizimo.domain.User;import cn.guizimo.util.JDBCUtils;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;/** * @author tanglei * @date 2020/6/22 10:34 上午 */public class UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); public User login(User loginUser) &#123; try &#123; String sql = \"select * from user where username = ? and password = ?\"; User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; &#125; catch (DataAccessException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 创建servlet类cn.guizimo.web.servlet.LoginServlet类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.guizimo.web.servlet;import cn.guizimo.dao.UserDao;import cn.guizimo.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author tanglei * @date 2020/6/22 11:15 上午 */@WebServlet(\"/loginServlet\")public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置编码 req.setCharacterEncoding(\"utf-8\"); //2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null)&#123; //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); &#125;else&#123; //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; cn.guizimo.web.servlet.FailServlet类 1234567891011121314151617181920212223242526272829package cn.guizimo.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author tanglei * @date 2020/6/22 11:26 上午 */@WebServlet(\"/failServlet\")public class FailServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 resp.setContentType(\"text/html;charset=utf-8\"); //输出 resp.getWriter().write(\"登录失败，用户名或密码错误\"); &#125;&#125; cn.guizimo.web.servlet.SuccessServlet类 1234567891011121314151617181920212223242526272829303132333435package cn.guizimo.web.servlet;import cn.guizimo.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author tanglei * @date 2020/6/22 11:31 上午 */@WebServlet(\"/successServlet\")public class SuccessServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取request域中共享的user对象 User user = (User) req.getAttribute(\"user\"); if(user != null)&#123; //设置编码 resp.setContentType(\"text/html;charset=utf-8\"); //输出 resp.getWriter().write(\"登录成功！\"+user.getUsername()+\",欢迎您\"); &#125; &#125;&#125; 运行在浏览器中打开http://localhost:8080/login_test/login.html 登录成功 登录失败 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java问题解决--java.lang.NoClassDefFoundError","slug":"Java问题解决--java.lang.NoClassDefFoundError","date":"2020-06-22T04:47:54.000Z","updated":"2020-07-29T15:57:54.000Z","comments":true,"path":"2020/06/22/Java问题解决--java.lang.NoClassDefFoundError/","link":"","permalink":"https://tangleia.github.io/2020/06/22/Java%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3--java.lang.NoClassDefFoundError/","excerpt":"Java问题解决–java.lang.NoClassDefFoundError","text":"Java问题解决–java.lang.NoClassDefFoundError 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题 java.lang.NoClassDefFoundError: org/springframework/dao/DataAccessException 问题截图 问题解决这个是由于不能找到导入的依赖 注意在WEB-INF的lib目录下导入，名字不要写错 右击lib目录，Add as Library 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"HTTP--Request详解","slug":"HTTP--Request详解","date":"2020-06-22T01:58:51.000Z","updated":"2020-07-29T15:24:46.000Z","comments":true,"path":"2020/06/22/HTTP--Request详解/","link":"","permalink":"https://tangleia.github.io/2020/06/22/HTTP--Request%E8%AF%A6%E8%A7%A3/","excerpt":"HTTP–Request详解","text":"HTTP–Request详解 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 请求消息数据格式请求行12请求方式 请求url 请求协议&#x2F;版本GET &#x2F;login.html HTTP&#x2F;1.1 请求头客户端浏览器告诉服务器一些信息 1请求头名称: 请求头值 常见的请求头： User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost/login.html 告诉服务器，我(当前请求)从哪里来？ 作用： 防盗链： 统计工作： 请求空行空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文) 封装POST请求消息的请求参数的 字符串格式： 1234567891011POST &#x2F;login.html HTTP&#x2F;1.1Host: localhostUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko&#x2F;20100101 Firefox&#x2F;60.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateReferer: http:&#x2F;&#x2F;localhost&#x2F;login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1username&#x3D;zhangsan 获取请求消息数据 获取请求行数据 GET /day14/demo1?name=zhangsan HTTP/1.1 方法： 获取请求方式 ：GET String getMethod() (*)获取虚拟目录：/day14 String getContextPath() 获取Servlet路径: /demo1 String getServletPath() 获取get方式请求参数：name=zhangsan String getQueryString() (*)获取请求URI：/day14/demo1 String getRequestURI(): /day14/demo1 StringBuffer getRequestURL() :http://localhost/day14/demo1 URL:统一资源定位符 ： http://localhost/day14/demo1 URI：统一资源标识符 : /day14/demo1 获取协议及版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址： String getRemoteAddr() 获取请求头数据 方法： (*)String getHeader(String name):通过请求头的名称获取请求头的值 Enumeration getHeaderNames():获取所有的请求头名称 获取请求体数据: 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 再从流对象中拿数据 获取请求参数通用方式不论get还是post请求方式都可以使用下列方法来获取请求参数 String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game Enumeration getParameterNames():获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 请求转发一种在服务器内部的资源跳转方式 步骤： 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 特点： 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中。 转发是一次请求 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj):存储数据 Object getAttitude(String name):通过键获取值 void removeAttribute(String name):通过键移除键值对 获取ServletContextServletContext getServletContext() 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"HTTP--协议详解","slug":"HTTP--协议详解","date":"2020-06-22T01:24:34.000Z","updated":"2020-07-29T15:24:09.000Z","comments":true,"path":"2020/06/22/HTTP--协议详解/","link":"","permalink":"https://tangleia.github.io/2020/06/22/HTTP--%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"HTTP–协议详解","text":"HTTP–协议详解 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ HTTP 简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP 工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80，但是你也可以改为8080或者其他端口。 HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP 协议的 8 种请求类型介绍HTTP 协议中共定义了八种方法或者叫“动作”来表明对 Request-URI 指定的资源的不同操作方式，具体介绍如下： OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除 Request-URI 所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Servlet--生命周期","slug":"Servlet--生命周期","date":"2020-06-22T01:05:48.000Z","updated":"2020-07-29T16:05:36.000Z","comments":true,"path":"2020/06/22/Servlet--生命周期/","link":"","permalink":"https://tangleia.github.io/2020/06/22/Servlet--%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"Servlet–生命周期","text":"Servlet–生命周期 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 生命周期Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 init() 方法init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。 Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。 当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。 123public void init() throws ServletException &#123; // 初始化代码...&#125; service() 方法service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。 1234public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException&#123;&#125; service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。 doGet() 方法GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。 12345public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码&#125; doPost() 方法POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。 12345public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码&#125; destroy() 方法destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。 123public void destroy() &#123; // 终止化代码...&#125; 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Servlet 简介","slug":"Servlet 简介","date":"2020-06-21T10:39:54.000Z","updated":"2020-07-29T16:05:24.000Z","comments":true,"path":"2020/06/21/Servlet 简介/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Servlet%20%E7%AE%80%E4%BB%8B/","excerpt":"Servlet 简介","text":"Servlet 简介 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 简介Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet的位置 Servlet的工作 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Servlet--实例","slug":"Servlet--实例","date":"2020-06-21T10:38:10.000Z","updated":"2020-07-29T16:05:48.000Z","comments":true,"path":"2020/06/21/Servlet--实例/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Servlet--%E5%AE%9E%E4%BE%8B/","excerpt":"Servlet–实例","text":"Servlet–实例 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ HelloWorld创建Java Web项目，在src目录下新建类文件Helloworld.java 12345678910111213141516171819202122232425262728293031323334353637import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @author tanglei * @date 2020/6/21 6:04 下午 */public class HelloWorld extends HttpServlet &#123; private String message; public void init() throws ServletException &#123; // 执行必需的初始化 message = \"Hello World\"; &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置响应内容类型 response.setContentType(\"text/html\"); // 实际的逻辑是在这里 PrintWriter out = response.getWriter(); out.println(\"&lt;h1&gt;\" + message + \"&lt;/h1&gt;\"); &#125; public void destroy() &#123; // 什么也不做 &#125;&#125; 编写配置文件在web目录下的WEB-INF里面的web.xml里面配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 启动项目点击启动项目，等待项目成功启动之后，会自动打开浏览器的localhost:8080的默认项目，由于我们这里是Idea启动的，所以启动的项目就是我们当前的项目，名称为tomcat_test_war_exploded 我们在浏览器中输入完整的url路径http://localhost:8080/tomcat_test_war_exploded/HelloWorld 打开检查，找到接口的回应 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Tomcat--在IDEA创建Java Web项目，通过tomcat启动","slug":"Tomcat--在IDEA创建Java Web项目，通过tomcat启动","date":"2020-06-21T09:34:30.000Z","updated":"2020-07-29T16:06:50.000Z","comments":true,"path":"2020/06/21/Tomcat--在IDEA创建Java Web项目，通过tomcat启动/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Tomcat--%E5%9C%A8IDEA%E5%88%9B%E5%BB%BAJava%20Web%E9%A1%B9%E7%9B%AE%EF%BC%8C%E9%80%9A%E8%BF%87tomcat%E5%90%AF%E5%8A%A8/","excerpt":"Tomcat–在IDEA创建Java Web项目，通过tomcat启动","text":"Tomcat–在IDEA创建Java Web项目，通过tomcat启动 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 配置Idea找到run菜单，找到配置 选择模版，找到tomcat 选择自己的tomcat的目录 创建Java Web项目选择新建项目，选择好版本 当我们创建好了之后。tomcat服务器相应的也搭建好了 运行 在浏览器中localhost:8080 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Tomcat--配置","slug":"Tomcat--配置","date":"2020-06-21T02:58:57.000Z","updated":"2020-07-29T16:06:32.000Z","comments":true,"path":"2020/06/21/Tomcat--配置/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Tomcat--%E9%85%8D%E7%BD%AE/","excerpt":"Tomcat–配置","text":"Tomcat–配置 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明web服务器软件 下载和启动这里就不多说了，之前有过博客的 配置部署项目的方式 直接将项目放到webapps目录下即可。 直接部署：项目的访问路径–&gt;虚拟目录（把html页面放入其中） 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 war包会自动解压缩 配置conf/server.xml文件 在标签体中配置 * docBase:项目存放的路径 * path：虚拟目录 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写 * 虚拟目录：xml文件的名称 静态项目和动态项目 目录结构 java动态项目的目录结构： 项目的根目录 WEB-INF目录： web.xml：web项目的核心配置文件 classes目录：放置字节码文件的目录 lib目录：放置依赖的jar包 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac安装Tomcat","slug":"Mac安装Tomcat","date":"2020-06-21T01:38:03.000Z","updated":"2020-07-29T16:04:24.000Z","comments":true,"path":"2020/06/21/Mac安装Tomcat/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Mac%E5%AE%89%E8%A3%85Tomcat/","excerpt":"Mac安装Tomcat","text":"Mac安装Tomcat 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 下载官网地址http://tomcat.apache.org/ 注意下载的版本，我这里是mac的 启动将文件解压，可以改名成为Tomcat，进入到bin目录下 开启1sh .&#x2F;startup.sh 关闭1sh .&#x2F;shutdown.sh 测试在浏览器中打开localhost:8080 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"XML--解析","slug":"XML--解析","date":"2020-06-21T00:38:29.000Z","updated":"2020-07-29T16:08:01.000Z","comments":true,"path":"2020/06/21/XML--解析/","link":"","permalink":"https://tangleia.github.io/2020/06/21/XML--%E8%A7%A3%E6%9E%90/","excerpt":"XML–解析","text":"XML–解析 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 解析操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式 DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 xml常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup快速入门 步骤： 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 代码 123456789101112//2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource(\"student.xml\").getPath(); //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document Document document = Jsoup.parse(new File(path), \"utf-8\"); //3.获取元素对象 Element Elements elements = document.getElementsByTag(\"name\"); System.out.println(elements.size()); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name); 对象的使用 1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse(File in, String charsetName)：解析xml或html文件的。 * parse(String html)：解析xml或html字符串 * parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 Document：文档对象。代表内存中的dom树 获取Element对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Elements：元素Element对象的集合。可以当做 ArrayList来使用 Element：元素对象 获取子元素对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) 5、Node：节点对象 是Document和Element的父类 快捷查询方式 selector:选择器 使用的方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 代码： 123456789101112131415161718192021222324252627282930313233343536 //1.获取student.xml的path String path = JsoupDemo6.class.getClassLoader().getResource(\"student.xml\").getPath();//2.获取Document对象 Document document = Jsoup.parse(new File(path), \"utf-8\"); //3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询 //4.1查询所有student标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(\"//student\"); for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode); &#125; System.out.println(\"--------------------\"); //4.2查询所有student标签下的name标签 List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(\"//student/name\"); for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode); &#125; System.out.println(\"--------------------\"); //4.3查询student标签下带有id属性的name标签 List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(\"//student/name[@id]\"); for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode); &#125; System.out.println(\"--------------------\"); //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(\"//student/name[@id='itcast']\"); for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode); &#125; 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"XML--简介和基本用法","slug":"XML--简介和基本用法","date":"2020-06-20T08:19:06.000Z","updated":"2020-07-29T16:07:47.000Z","comments":true,"path":"2020/06/20/XML--简介和基本用法/","link":"","permalink":"https://tangleia.github.io/2020/06/20/XML--%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"XML–简介和基本用法","text":"XML–简介和基本用法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念Extensible Markup Language 可扩展标记语言 可扩展标签都是自定义的。 功能：存储数据配置文件 在网络中传输 xml与html的区别xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 语法基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 案例123456789101112131415&lt;?xml version='1.0' ?&gt; &lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 组成部分：文档声明 格式： 1&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值： yes：不依赖其他文件 no：依赖其他文件 指令(了解)：结合css的 1&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;a.css&quot; ?&gt; 标签：标签名称自定义的 规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性 id属性值唯一 文本： CDATA区：在该区域中的数据会被原样展示 1&lt;![CDATA[ 数据 ]]&gt; 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"XML--约束","slug":"XML--约束","date":"2020-06-20T08:17:30.000Z","updated":"2020-07-29T16:08:20.000Z","comments":true,"path":"2020/06/20/XML--约束/","link":"","permalink":"https://tangleia.github.io/2020/06/20/XML--%E7%BA%A6%E6%9D%9F/","excerpt":"XML–简介和基本用法","text":"XML–简介和基本用法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念Extensible Markup Language 可扩展标记语言 可扩展标签都是自定义的。 功能：存储数据配置文件 在网络中传输 xml与html的区别xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 语法基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 案例123456789101112131415&lt;?xml version='1.0' ?&gt; &lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 组成部分：文档声明 格式： 1&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值： yes：不依赖其他文件 no：依赖其他文件 指令(了解)：结合css的 1&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;a.css&quot; ?&gt; 标签：标签名称自定义的 规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性 id属性值唯一 文本： * CDATA区：在该区域中的数据会被原样展示 1&lt;![CDATA[ 数据 ]]&gt; 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"博客园添加live2d看板娘","slug":"博客园添加live2d看板娘","date":"2020-06-18T15:22:32.000Z","updated":"2020-08-05T03:36:50.000Z","comments":true,"path":"2020/06/18/博客园添加live2d看板娘/","link":"","permalink":"https://tangleia.github.io/2020/06/18/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%B7%BB%E5%8A%A0live2d%E7%9C%8B%E6%9D%BF%E5%A8%98/","excerpt":"博客园添加live2d看板娘","text":"博客园添加live2d看板娘 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 配置添加代码到博客园侧边栏公告 代码12345678910111213141516171819202122232425&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;eqcn.ajz.miesnfu.com&#x2F;wp-content&#x2F;plugins&#x2F;wp-3d-pony&#x2F;live2dw&#x2F;lib&#x2F;L2Dwidget.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; L2Dwidget.init(&#123; &quot;model&quot;: &#123; jsonPath: &quot;https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-shizuku@1.0.5&#x2F;assets&#x2F;shizuku.model.json&quot;, &quot;scale&quot;: 1 &#125;, &quot;display&quot;: &#123; &quot;position&quot;: &quot;right&quot;, &quot;width&quot;: 75, &quot;height&quot;: 150, &quot;hOffset&quot;: 0, &quot;vOffset&quot;: -20 &#125;, &quot;mobile&quot;: &#123; &quot;show&quot;: true, &quot;scale&quot;: 0.5 &#125;, &quot;react&quot;: &#123; &quot;opacityDefault&quot;: 0.7, &quot;opacityOnHover&quot;: 0.2 &#125; &#125;);&lt;&#x2F;script&gt; 选择人物在上面jsonPath切换就可以啦 123456黑猫：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-hijiki@1.0.5&#x2F;assets&#x2F;hijiki.model.json萌娘：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-shizuku@1.0.5&#x2F;assets&#x2F;shizuku.model.json白猫：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-tororo@1.0.5&#x2F;assets&#x2F;tororo.model.json狗狗：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json小可爱：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-z16@1.0.5&#x2F;assets&#x2F;z16.model.json小可爱：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-koharu@1.0.5&#x2F;assets&#x2F;koharu.model.json 测试 当然这个大小可以去调整的 感谢 hexo+github+live2d+volantis 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"使用GitHub+Hexo+live2d搭建个人博客","slug":"使用GitHub+Hexo+live2d搭建个人博客","date":"2020-06-18T14:51:12.000Z","updated":"2020-06-18T15:25:07.000Z","comments":true,"path":"2020/06/18/使用GitHub+Hexo+live2d搭建个人博客/","link":"","permalink":"https://tangleia.github.io/2020/06/18/%E4%BD%BF%E7%94%A8GitHub+Hexo+live2d%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"使用GitHub+Hexo+live2d搭建个人博客","text":"使用GitHub+Hexo+live2d搭建个人博客 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 安装hexo1sudo npm install hexo-cli -g 创建博客目录123hexo init username.github.iocd username.github.ionpm install 运行123hexo clean #清理文件hexo g #生成文件hexo s #运行 打开浏览器，输入地址localhost:4000即可看到博客页面 安装主题主题官网可以查看 https://hexo.io/themes/[](https://hexo.io/themes/) 我使用的是volantis，文档地址 https://volantis.js.org/v2/getting-started/[](https://volantis.js.org/v2/getting-started/) 下载主题1git clone https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis themes&#x2F;volantis 修改配置文件项目根目录下_config.yml文件 1theme: volantis 安装依赖12npm i -S hexo-generator-search hexo-generator-json-contentnpm i -S hexo-renderer-stylus 配置文件一般在/_config.yml配置网页图标名称等 一般在/theme/{theme}/_config.yml配置主题等页面显示的问题 部署到Github在GitHub创建一个&lt;username&gt;.github.io的public仓库，如果你的用户名是xxx,则需要创建一个xxx.github.io的public仓库，这个步骤很简单就跳过了 安装依赖1npm install hexo-deployer-git --save 网站配置git在网站的_config.yml中配置deploy 1234deploy: type: git repo: &lt;repository url&gt; #你的仓库地址 branch: master 部署1hexo d 需要Github的用户名和密码，填入即可 现在的样子当然这个需要你们根据主题里面的文档进行配置 配置live2dhexo可以直接当做插件使用live2d，不过很慢 下载依赖1npm install --save hexo-helper-live2d 下载主题可以选择主题下载，选择不同的人物 1npm install live2d-widget-model-shizuku 配置主题在/_config.yml配置文件里面添加一段配置 12345678910111213141516171819202122232425262728293031# Live2D## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d## https:&#x2F;&#x2F;l2dwidget.js.org&#x2F;docs&#x2F;class&#x2F;src&#x2F;index.js~L2Dwidget.html#instance-method-initlive2d: enable: true #enable: false scriptFrom: local # 默认 pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径) pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径 pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-shizuku # use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名 # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径 # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url display: position: left width: 150 height: 300 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8 可以自己选择大小和位置 配置好了之后再次部署 123hexo cleanhexo ghexo d 测试下面那个人物等了一会再出现的 感谢 hexo+github+live2d+volantis 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Go--Beego新建项目（解决不能访问的问题)","slug":"Go--Beego新建项目（解决不能访问的问题)","date":"2020-06-18T08:06:58.000Z","updated":"2020-06-18T15:25:25.000Z","comments":true,"path":"2020/06/18/Go--Beego新建项目（解决不能访问的问题)/","link":"","permalink":"https://tangleia.github.io/2020/06/18/Go--Beego%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%88%E8%A7%A3%E5%86%B3%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98)/","excerpt":"Go–Beego新建项目（解决不能访问的问题）","text":"Go–Beego新建项目（解决不能访问的问题） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明beego开发文档 https://beego.me/docs/quickstart/new.md 安装beego请首先安装beego和bee 12go get github.com/astaxie/beegogo get github.com/beego/bee 使用bee创建项目 进入gopath下src里面 1MacBook-Air :: ~/go/src » bee new project 在Goland中打开项目 运行项目 1bee run 发现不能够访问 修改配置文件在conf/app.conf文件里面添加 1httpaddr &#x3D; 127.0.0.1 测试再次运行，发现可以了 在浏览器中打开 感谢 beego 万能的网络 以及勤劳的自己","categories":[],"tags":[]}],"categories":[],"tags":[]}