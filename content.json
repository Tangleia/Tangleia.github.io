{"meta":{"title":"归子莫的博客","subtitle":"","description":"归子莫的个人博客","author":"归子莫","url":"https://Tangleia.github.io","root":"/"},"pages":[{"title":"","date":"2020-07-03T05:46:54.913Z","updated":"2020-06-18T07:41:34.640Z","comments":true,"path":"index.html","permalink":"https://tangleia.github.io/index.html","excerpt":"","text":""},{"title":"404 Not Found","date":"2020-07-03T05:46:54.967Z","updated":"2020-06-18T07:40:45.180Z","comments":true,"path":"404.html","permalink":"https://tangleia.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2020-07-03T05:46:50.781Z","updated":"2020-06-18T08:12:32.140Z","comments":true,"path":"mylist/index.html","permalink":"https://tangleia.github.io/mylist/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-07-03T05:46:54.821Z","updated":"2020-06-18T07:29:22.840Z","comments":true,"path":"about/index.html","permalink":"https://tangleia.github.io/about/index.html","excerpt":"","text":"本站是个人博客，希望一起交流学习。 本站所使用的主题是：Volantis，与主题相关的疑问请前去主题文档页面查询或者提 issue 求助！"},{"title":"我的朋友们","date":"2020-07-03T05:46:55.030Z","updated":"2020-06-18T07:37:44.290Z","comments":true,"path":"friends/index.html","permalink":"https://tangleia.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"数据结构--二叉树（Java）","slug":"数据结构--二叉树（Java）","date":"2020-07-29T14:52:58.400Z","updated":"2020-07-29T14:57:44.446Z","comments":true,"path":"2020/07/29/数据结构--二叉树（Java）/","link":"","permalink":"https://tangleia.github.io/2020/07/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构–二叉树（Java）","text":"数据结构–二叉树（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 树的常用术语(结合示意图理解) 节点 根节点 父节点 子节点 叶子节点 (没有子节点的节点) 节点的权(节点值) 路径(从root节点找到该节点的路线) 层 子树 树的高度(最大层数) 森林 :多颗子树构成森林 树存储方式优势能提高数据存储，读取的效率, 比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度 二叉树的概念 每个节点最多只能有两个子节点的一种形式称为二叉树 二叉树的子节点分为左节点和右节点 如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。 如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树 遍历 前序遍历: 先输出父节点，再遍历左子树和右子树 中序遍历: 先遍历左子树，再输出父节点，再遍历右子树 后序遍历: 先遍历左子树，再遍历右子树，最后输出父节点 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281package cn.guizimo.tree;/** * @author guizimo * @date 2020/7/29 8:03 下午 */public class TreeDemo &#123; public static void main(String[] args) &#123; BinaryTree binaryTree = new BinaryTree(); HeroNode root = new HeroNode(1, \"宋江\"); HeroNode node2 = new HeroNode(2, \"李逵\"); HeroNode node3 = new HeroNode(3, \"卢俊义\"); HeroNode node4 = new HeroNode(4, \"吴用\"); HeroNode node5 = new HeroNode(5, \"林冲\"); HeroNode node6 = new HeroNode(6, \"鲁智深\"); //创建二叉树 root.setLeft(node2); root.setRight(node3); node2.setLeft(node4); node3.setLeft(node5); node3.setRight(node6); binaryTree.setRoot(root); //前序遍历// HeroNode heroNode = binaryTree.preOrderSearch(5);// System.out.println(heroNode); &#125;&#125;/** * 二叉树 */class BinaryTree &#123; //根节点 private HeroNode root; public void setRoot(HeroNode root) &#123; this.root = root; &#125; //删除二叉树的节点 public void delNode(int no) &#123; if (root != null) &#123; if (root.getNo() == no) &#123; root = null; &#125; else &#123; root.delNode(no); &#125; &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //前序 public void preOrder() &#123; if (this.root != null) &#123; this.root.preOrder(); &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //中序 public void infixOrder() &#123; if (this.root != null) &#123; this.root.infixOrder(); &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //后序 public void postOrder() &#123; if (this.root != null) &#123; this.root.postOrder(); &#125; else &#123; System.out.println(\"二叉树为空\"); &#125; &#125; //前序查找 public HeroNode preOrderSearch(int no) &#123; if (root != null) &#123; return root.preOrderSearch(no); &#125; else &#123; return null; &#125; &#125; //中序查找 public HeroNode infixOrderSearch(int no) &#123; if (root != null) &#123; return root.infixOrderSearch(no); &#125; else &#123; return null; &#125; &#125; //后序查找 public HeroNode postOrderSearch(int no) &#123; if (root != null) &#123; return this.root.postOrderSearch(no); &#125; else &#123; return null; &#125; &#125;&#125;/** * 节点 */class HeroNode &#123; private int no; private String name; private HeroNode left; private HeroNode right; public HeroNode(int no, String name) &#123; this.no = no; this.name = name; &#125; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public HeroNode getLeft() &#123; return left; &#125; public void setLeft(HeroNode left) &#123; this.left = left; &#125; public HeroNode getRight() &#123; return right; &#125; public void setRight(HeroNode right) &#123; this.right = right; &#125; @Override public String toString() &#123; return \"HeroNode&#123;\" + \"no=\" + no + \", name='\" + name + '\\'' + '&#125;'; &#125; //删除节点 public void delNode(int no) &#123; //判读左节点是否为空，找到 if (this.left != null &amp;&amp; this.left.no == no) &#123; this.left = null; return; &#125; //判断右节点，找到 if (this.right != null &amp;&amp; this.right.no == no) &#123; this.right = null; return; &#125; //判断左节点，未找到，递归 if (this.left != null) &#123; this.left.delNode(no); &#125; //判断右节点，未找到，递归 if (this.right != null) &#123; this.right.delNode(no); &#125; &#125; //前序 public void preOrder() &#123; System.out.println(this); if (this.left != null) &#123; this.left.preOrder(); &#125; if (this.right != null) &#123; this.right.preOrder(); &#125; &#125; //中序 public void infixOrder() &#123; if (this.left != null) &#123; this.left.infixOrder(); &#125; System.out.println(this); if (this.right != null) &#123; this.right.infixOrder(); &#125; &#125; //后序 public void postOrder() &#123; if (this.left != null) &#123; this.left.postOrder(); &#125; if (this.right != null) &#123; this.right.postOrder(); &#125; System.out.println(this); &#125; //前序遍历查找 public HeroNode preOrderSearch(int no) &#123; if (this.no == no) &#123; return this; &#125; HeroNode resNode = null; //判断左子树 if (this.left != null) &#123; resNode = this.left.preOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; //判断右子树 if (this.right != null) &#123; resNode = this.right.preOrderSearch(no); &#125; return resNode; &#125; //中序遍历查找 public HeroNode infixOrderSearch(int no) &#123; HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.infixOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.no == no) &#123; return this; &#125; if (this.right != null) &#123; resNode = this.right.infixOrderSearch(no); &#125; return resNode; &#125; //后序遍历查找 public HeroNode postOrderSearch(int no) &#123; HeroNode resNode = null; if (this.left != null) &#123; resNode = this.left.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.right != null) &#123; resNode = this.right.postOrderSearch(no); &#125; if (resNode != null) &#123; return resNode; &#125; if (this.no == no) &#123; return this; &#125; return resNode; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"数据结构--哈希表（Java）","slug":"数据结构--哈希表（Java）","date":"2020-07-23T15:34:53.030Z","updated":"2020-07-29T15:09:44.855Z","comments":true,"path":"2020/07/23/数据结构--哈希表（Java）/","link":"","permalink":"https://tangleia.github.io/2020/07/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84--%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%88Java%EF%BC%89/","excerpt":"数据结构–哈希表（Java）","text":"数据结构–哈希表（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍哈希表底层是数组加链表或者是数组加二叉树，一个数组里面有多个链表，通过散列函数来提高效率 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package cn.guizimo.hashtab;import java.util.Scanner;/** * @author guizimo * @date 2020/7/23 10:29 下午 */public class HashTabDemo &#123; public static void main(String[] args) &#123; HashTab hashTab = new HashTab(7); String key = \"\"; Scanner scanner = new Scanner(System.in); while (true)&#123; System.out.println(\"add:添加\"); System.out.println(\"list:显示\"); System.out.println(\"find:显示\"); System.out.println(\"exit:退出\"); key = scanner.next(); switch (key)&#123; case \"add\": System.out.println(\"输入id\"); int id = scanner.nextInt(); System.out.println(\"输入名字\"); String name = scanner.next(); Emp emp = new Emp(id, name); hashTab.add(emp); break; case \"list\": hashTab.list(); break; case \"find\": System.out.println(\"请输入id\"); id = scanner.nextInt(); hashTab.find(id); break; case \"exit\": scanner.close(); System.exit(0); default: break; &#125; &#125; &#125;&#125;class Emp&#123; public int id; public String name; public Emp next; public Emp(int id, String name) &#123; super(); this.id = id; this.name = name; &#125;&#125;//哈希表class HashTab&#123; private EmpLinkedList[] empLinkedListArray; private int size; //构造器 public HashTab(int size)&#123; this.size = size; empLinkedListArray = new EmpLinkedList[size]; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i] = new EmpLinkedList(); &#125; &#125; //添加 public void add(Emp emp)&#123; int empLinkedListNo = hashFun(emp.id); empLinkedListArray[empLinkedListNo].add(emp); &#125; public void find(int id)&#123; int empLinkedListNo = hashFun(id); Emp emp = empLinkedListArray[empLinkedListNo].find(id); if (emp != null)&#123; System.out.printf(\"在第%d条链表中找到id=%d\\n\",(empLinkedListNo+1),id); &#125;else &#123; System.out.println(\"没有找到\"); &#125; &#125; //遍历 public void list()&#123; for (int i = 0; i &lt; size; i++) &#123; empLinkedListArray[i].list(i); &#125; &#125; //散列(取模) public int hashFun(int id)&#123; return id % size; &#125;&#125;class EmpLinkedList&#123; private Emp head; public void add(Emp emp)&#123; if(head == null)&#123; head = emp; return; &#125; Emp curEmp = head; while (true)&#123; if(curEmp.next == null)&#123; break; &#125; curEmp = curEmp.next; &#125; curEmp.next = emp; &#125; public void list(int no)&#123; if(head == null)&#123; System.out.println(\"第\"+(no+1)+\"条链表为空\"); return; &#125; System.out.print(\"第\"+(no+1)+\"条链表信息\"); Emp curemp = head; while (true)&#123; System.out.printf(\"id=%d,name=%s\\t\",curemp.id,curemp.name); if(curemp.next == null)&#123; break; &#125; curemp = curemp.next; &#125; System.out.println(); &#125; public Emp find(int id)&#123; if(head == null)&#123; System.out.println(\"链表为空\"); return null; &#125; Emp curEmp = head; while (true)&#123; if(curEmp.id == id)&#123; break; &#125; if(curEmp.next == null)&#123; curEmp = null; break; &#125; curEmp = curEmp.next; &#125; return curEmp; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"查找--斐波那契查找（Java）","slug":"查找--斐波那契查找（Java）","date":"2020-07-23T14:28:45.871Z","updated":"2020-07-29T15:25:31.116Z","comments":true,"path":"2020/07/23/查找--斐波那契查找（Java）/","link":"","permalink":"https://tangleia.github.io/2020/07/23/%E6%9F%A5%E6%89%BE--%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%EF%BC%88Java%EF%BC%89/","excerpt":"查找–斐波那契查找（Java）","text":"查找–斐波那契查找（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。 斐波那契数列 {1, 1, 2, 3, 5, 8, 13, 21, 34, 55 } 发现斐波那契数列的两个相邻数 的比例，无限接近 黄金分割值0.618 思路利用斐波那契数列的特性来查找mid 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package cn.guizimo.search;import java.util.Arrays;/** * @author guizimo * @date 2020/7/23 10:06 下午 */public class FibonacciSearch &#123; public static int maxSize = 20; public static void main(String[] args) &#123; int[] arr = &#123;1, 8, 10, 89, 100, 1000&#125;; System.out.println(fibSearch(arr,8)); &#125; //斐波那契数列 public static int[] fib() &#123; int[] f = new int[maxSize]; f[0] = 1; f[1] = 1; for (int i = 2; i &lt; maxSize; i++) &#123; f[i] = f[i - 1] + f[i - 2]; &#125; return f; &#125; public static int fibSearch(int[] a, int key) &#123; int low = 0; int high = a.length - 1; int k = 0; int mid = 0; int f[] = fib(); while (high &gt; f[k] - 1) &#123; k++; &#125; int[] temp = Arrays.copyOf(a, f[k]); for (int i = high + 1; i &lt; temp.length; i++) &#123; temp[i] = a[high]; &#125; while (low &lt;= high) &#123; mid = low + f[k - 1] - 1; if (key &lt; temp[mid]) &#123; high = mid - 1; k--; &#125; else if (key &gt; temp[mid]) &#123; low = mid + 1; k -= 2; &#125; else &#123; if (mid &lt;= high) &#123; return mid; &#125; else &#123; return high; &#125; &#125; &#125; return -1; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"牛客网--字节跳动面试题--特征提取","slug":"牛客网--字节跳动面试题--特征提取","date":"2020-07-18T07:03:01.388Z","updated":"2020-07-29T15:08:02.731Z","comments":true,"path":"2020/07/18/牛客网--字节跳动面试题--特征提取/","link":"","permalink":"https://tangleia.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%E7%BD%91--%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98--%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/","excerpt":"牛客网–字节跳动面试题–特征提取","text":"牛客网–字节跳动面试题–特征提取 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 来源链接：特征提取 来源：牛客网 题目小明是一名算法工程师，同时也是一名铲屎官。某天，他突发奇想，想从猫咪的视频里挖掘一些猫咪的运动信息。为了提取运动信息，他需要从视频的每一帧提取“猫咪特征”。一个猫咪特征是一个两维的vector&lt;x, y&gt;。如果x_1=x_2 and y_1=y_2，那么这俩是同一个特征。 因此，如果喵咪特征连续一致，可以认为喵咪在运动。也就是说，如果特征&lt;a, b&gt;在持续帧里出现，那么它将构成特征运动。比如，特征&lt;a, b&gt;在第2/3/4/7/8帧出现，那么该特征将形成两个特征运动2-3-4 和7-8。 现在，给定每一帧的特征，特征的数量可能不一样。小明期望能找到最长的特征运动。 输入描述:123456789第一行包含一个正整数N，代表测试用例的个数。每个测试用例的第一行包含一个正整数M，代表视频的帧数。接下来的M行，每行代表一帧。其中，第一个数字是该帧的特征个数，接下来的数字是在特征的取值；比如样例输入第三行里，2代表该帧有两个猫咪特征，&lt;1，1&gt;和&lt;2，2&gt;所有用例的输入特征总数和&lt;100000N满足1≤N≤100000，M满足1≤M≤10000，一帧的特征个数满足 ≤ 10000。特征取值均为非负整数。 输出描述:1对每一个测试用例，输出特征运动的长度作为一行 输入例子1:12345678910182 1 1 2 22 1 1 1 42 1 1 2 22 2 2 1 4001 1 11 1 1 输出例子1:13 例子说明1:1特征&lt;1,1&gt;在连续的帧中连续出现3次，相比其他特征连续出现的次数大，所以输出3 思路1、使用map，将遍历的得到的第一个坐标作为key存入map集合，在辅助map里面记录次坐标的次数 2、遍历所有的帧，比较最大的次数 代码1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.HashMap;import java.util.Scanner;/** * @author guizimo * @date 2020/7/18 2:25 下午 */public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); for (int i = 0; i &lt; n; i++) &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); HashMap&lt;String, Integer&gt; temp = new HashMap&lt;&gt;(); int m = scanner.nextInt(); int max = 1; //遍历帧 for (int j = 0; j &lt; m; j++) &#123; //清空辅助map temp.clear(); int number = scanner.nextInt(); //遍历帧内的坐标 for (int k = 0; k &lt; number; k++) &#123; int x = scanner.nextInt(); int y = scanner.nextInt(); //拼接key String key = String.valueOf(x) + \" \" + String.valueOf(y); temp.put(key,map.getOrDefault(key,0)+1); max = Math.max(temp.get(key),max); &#125; map.clear(); map.putAll(temp); &#125; if (max &lt;= 1) &#123; System.out.println(1); &#125;else &#123; System.out.println(max); &#125; &#125; &#125;&#125; 感谢 牛客网 字节跳动 以及勤劳的自己","categories":[],"tags":[]},{"title":"牛客网--字节跳动面试题--万万没想到之聪明的编辑","slug":"牛客网--字节跳动面试题--万万没想到之聪明的编辑","date":"2020-07-18T06:17:56.663Z","updated":"2020-07-29T15:08:34.188Z","comments":true,"path":"2020/07/18/牛客网--字节跳动面试题--万万没想到之聪明的编辑/","link":"","permalink":"https://tangleia.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%E7%BD%91--%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98--%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E8%81%AA%E6%98%8E%E7%9A%84%E7%BC%96%E8%BE%91/","excerpt":"牛客网–字节跳动面试题–万万没想到之聪明的编辑","text":"牛客网–字节跳动面试题–万万没想到之聪明的编辑 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 来源链接：万万没想到之聪明的编辑 来源：牛客网 题目我叫王大锤，是一家出版社的编辑。我负责校对投稿来的英文稿件，这份工作非常烦人，因为每天都要去修正无数的拼写错误。但是，优秀的人总能在平凡的工作中发现真理。我发现一个发现拼写错误的捷径： 三个同样的字母连在一起，一定是拼写错误，去掉一个的就好啦：比如 helllo -&gt; hello 两对一样的字母（AABB型）连在一起，一定是拼写错误，去掉第二对的一个字母就好啦：比如 helloo -&gt; hello 上面的规则优先“从左到右”匹配，即如果是AABBCC，虽然AABB和BBCC都是错误拼写，应该优先考虑修复AABB，结果为AABCC 我特喵是个天才！我在蓝翔学过挖掘机和程序设计，按照这个原理写了一个自动校对器，工作效率从此起飞。用不了多久，我就会出任CEO，当上董事长，迎娶白富美，走上人生巅峰，想想都有点小激动呢！ …… 万万没想到，我被开除了，临走时老板对我说： “做人做事要兢兢业业、勤勤恳恳、本本分分，人要是行，干一行行一行。一行行行行行；要是不行，干一行不行一行，一行不行行行不行。” 我现在整个人红红火火恍恍惚惚的…… 请听题：请实现大锤的自动校对程序 输入描述:123第一行包括一个数字N，表示本次用例包括多少个待校验的字符串。后面跟随N行，每行为一个待校验的字符串。 输出描述:1N行，每行包括一个被修复后的字符串。 输入例子1:1232helloowooooooow 输出例子1:12hellowoow 思路使用Java的正则表达式 代码如果不是看到，绝对不会想到这样的解法（代码来自牛客Lunatic201904011812400） 12345678910111213141516import java.util.Scanner;/** * @author guizimo * @date 2020/7/17 9:48 下午 */public class zijie1 &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int line = scanner.nextInt(); scanner.nextLine(); for(int i = 0;i &lt; line;i++)&#123; System.out.println(scanner.nextLine().replaceAll(\"(.)\\\\1+\",\"$1$1\").replaceAll(\"(.)\\\\1(.)\\\\2\",\"$1$1$2\")); &#125; &#125;&#125; 感谢 牛客网 字节跳动 以及勤劳的自己","categories":[],"tags":[]},{"title":"牛客网--字节跳动面试题--万万没想到之抓捕孔连顺","slug":"牛客网--字节跳动面试题--万万没想到之抓捕孔连顺","date":"2020-07-18T06:17:50.374Z","updated":"2020-07-29T15:08:43.938Z","comments":true,"path":"2020/07/18/牛客网--字节跳动面试题--万万没想到之抓捕孔连顺/","link":"","permalink":"https://tangleia.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%E7%BD%91--%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98--%E4%B8%87%E4%B8%87%E6%B2%A1%E6%83%B3%E5%88%B0%E4%B9%8B%E6%8A%93%E6%8D%95%E5%AD%94%E8%BF%9E%E9%A1%BA/","excerpt":"牛客网–字节跳动面试题–万万没想到之抓捕孔连顺","text":"牛客网–字节跳动面试题–万万没想到之抓捕孔连顺 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 来源链接：万万没想到之抓捕孔连顺 来源：牛客网 题目我叫王大锤，是一名特工。我刚刚接到任务：在字节跳动大街进行埋伏，抓捕恐怖分子孔连顺。和我一起行动的还有另外两名特工，我提议 我们在字节跳动大街的N个建筑中选定3个埋伏地点。 为了相互照应，我们决定相距最远的两名特工间的距离不超过D。 我特喵是个天才! 经过精密的计算，我们从X种可行的埋伏方案中选择了一种。这个方案万无一失，颤抖吧，孔连顺！ …… 万万没想到，计划还是失败了，孔连顺化妆成小龙女，混在cosplay的队伍中逃出了字节跳动大街。只怪他的伪装太成功了，就是杨过本人来了也发现不了的！ 请听题：给定N（可选作为埋伏点的建筑物数）、D（相距最远的两名特工间的距离的最大值）以及可选建筑的坐标，计算在这次行动中，大锤的小队有多少种埋伏选择。 注意： 两个特工不能埋伏在同一地点 三个特工是等价的：即同样的位置组合(A, B, C) 只算一种埋伏方法，不能因“特工之间互换位置”而重复使用 输入描述:123第一行包含空格分隔的两个数字 N和D(1 ≤ N ≤ 1000000; 1 ≤ D ≤ 1000000)第二行包含N个建筑物的的位置，每个位置用一个整数（取值区间为[0, 1000000]）表示，从小到大排列（将字节跳动大街看做一条数轴） 输出描述:1一个数字，表示不同埋伏方案的数量。结果可能溢出，请对 99997867 取模 输入例子1:124 31 2 3 4 输出例子1:14 例子说明1:1可选方案 (1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4) 输入例子2:125 191 10 20 30 50 输出例子2:11 例子说明2:1可选方案 (1, 10, 20) 思路1、首先确定范围，计算排列组合，从第三个数开始判断，因为必须有三个数嘛，判断违法的次数，如果当前数字不合法，那么违法的次数加一，那么每次的次数为（当前第几个数-违法次数）x（当前第几个数-违法次数）/ 2 2、累加每次范围的次数，就可以得到全部的了 代码1234567891011121314151617181920212223242526272829303132333435import java.util.Scanner;/** * @author guizimo * @date 2020/7/17 10:04 下午 */public class zijie2 &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; int n = scanner.nextInt(); int d = scanner.nextInt(); int[] position = new int[n]; scanner.nextLine(); for (int i = 0; i &lt; n; i++) &#123; position[i] = scanner.nextInt(); &#125; run(n, d, position); &#125; &#125; public static void run(int n, int d, int[] position) &#123; long sum = 0L; long mod = 99997867; for (int i = 0, j = 0; i &lt; n; i++) &#123; //从第三个开始判断，判断是否违法，如果违法j++ while (i &gt;= 2 &amp;&amp; position[i] - position[j] &gt; d) &#123; j++; &#125; //计算合法的次数，n(n-i)/2 sum += (long) (i - j) * (long) (i - j - 1) / 2; &#125; System.out.println(sum % mod); &#125;&#125; 感谢 牛客网 字节跳动 以及勤劳的自己","categories":[],"tags":[]},{"title":"牛客网--字节跳动面试题--雀魂启动","slug":"牛客网--字节跳动面试题--雀魂启动","date":"2020-07-18T05:55:13.054Z","updated":"2020-07-29T15:07:52.791Z","comments":true,"path":"2020/07/18/牛客网--字节跳动面试题--雀魂启动/","link":"","permalink":"https://tangleia.github.io/2020/07/18/%E7%89%9B%E5%AE%A2%E7%BD%91--%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E9%A2%98--%E9%9B%80%E9%AD%82%E5%90%AF%E5%8A%A8/","excerpt":"牛客网–字节跳动面试题–雀魂启动","text":"牛客网–字节跳动面试题–雀魂启动 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 来源链接：雀魂启动来源：牛客网 题目小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。 于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下： 总共有36张牌，每张牌是1~9。每个数字4张牌。 你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌 14张牌中有2张相同数字的牌，称为雀头。 除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777） 例如 1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌 1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌 1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。 要求 现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。 输入描述:1输入只有一行，包含13个数字，用空格分隔，每个数字在1~9之间，数据保证同种数字最多出现4次。 输出描述:1输出同样是一行，包含1个或以上的数字。代表他再取到哪些牌可以和牌。若满足条件的有多种牌，请按从小到大的顺序输出。若没有满足条件的牌，请输出一个数字0 示例1输入11 1 1 2 2 2 5 5 5 6 6 6 9 输出19 说明1可以组成1,2,6,7的4个刻子和9的雀头 示例2输入11 1 1 1 2 2 3 3 5 6 7 8 9 输出14 7 说明1用1做雀头，组123,123,567或456,789的四个顺子 示例3输入11 1 1 2 2 2 3 3 3 5 7 7 9 输出10 说明1来任何牌都无法和牌 思路1、统计所有数字出现的次数 2、循环补充一个数字，凑成14个数字 3、循环选取次数2以及以上的数字为雀头 4、排除雀头，递归判断剩下12个数字是否可以组成刻子或者顺子，如果能够符合规则，记录次数字 5、返回数据 代码代码整理自牛客大佬kakifuu 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import java.util.ArrayList;import java.util.Scanner;/** * @author guizimo * @date 2020/7/18 12:44 下午 */public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); int[] state = new int[9], temp = new int[9]; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); //获取13个数字，统计每个数字出现的次数 for (int i = 0; i &lt; 13; i++) &#123; int num = scanner.nextInt(); state[num - 1]++; &#125; //依次添加数字进行测试 for (int i = 0; i &lt; 9; i++) &#123; if (state[i] &lt; 4) &#123; int num = i + 1; System.arraycopy(state, 0, temp, 0, 9); temp[i]++; //判断是否符合规则，若符合记录当前的数字 if (run(temp, 14, false)) &#123; res.add(num); &#125; &#125; &#125; if (res.isEmpty()) &#123; //如果为空 System.out.println(0); &#125; else &#123; //不为空 StringBuffer sbf = new StringBuffer(); sbf.append(res.get(0)); for (int i = 1; i &lt; res.size(); i++) &#123; sbf.append(\" \"); sbf.append(res.get(i)); &#125; System.out.println(sbf.toString()); &#125; &#125; public static boolean run(int[] temp, int count, boolean hasRun) &#123; if (count == 0) &#123; return true; &#125; if (!hasRun) &#123; for (int i = 0; i &lt; 9; i++) &#123; //遍历个数大于2的数字，让它作为雀头，判断后面的规则是否通过 if (temp[i] &gt;= 2) &#123; temp[i] -= 2; //递归 if (run(temp, count - 2, true)) &#123; return true; &#125; temp[i] += 2; &#125; &#125; return false; &#125; else &#123; for (int i = 0; i &lt; 9; i++) &#123; if (temp[i] &gt; 0) &#123; //判断刻子 if (temp[i] &gt;= 3) &#123; temp[i] -= 3; if (run(temp, count - 3, true)) &#123; return true; &#125; temp[i] += 3; &#125; //判断顺子 if (i + 2 &lt; 9 &amp;&amp; temp[i + 1] &gt; 0 &amp;&amp; temp[i + 2] &gt; 0) &#123; temp[i]--; temp[i+1]--; temp[i+2]--; if(run(temp,count-3,true))&#123; return true; &#125; temp[i]++; temp[i+1]++; temp[i+2]++; &#125; &#125; &#125; &#125; return false; &#125;&#125; 感谢 牛客网 字节跳动 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac安装svn（解决新系统Xcode不支持问题）","slug":"Mac安装svn（解决新系统Xcode不支持问题）","date":"2020-07-17T15:15:00.485Z","updated":"2020-07-29T16:04:10.896Z","comments":true,"path":"2020/07/17/Mac安装svn（解决新系统Xcode不支持问题）/","link":"","permalink":"https://tangleia.github.io/2020/07/17/Mac%E5%AE%89%E8%A3%85svn%EF%BC%88%E8%A7%A3%E5%86%B3%E6%96%B0%E7%B3%BB%E7%BB%9FXcode%E4%B8%8D%E6%94%AF%E6%8C%81%E9%97%AE%E9%A2%98%EF%BC%89/","excerpt":"Mac安装svn（解决新系统Xcode不支持问题）","text":"Mac安装svn（解决新系统Xcode不支持问题） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明在新版的系统里面xcode不再支持svn 所以我们要使用的话，请使用brew来安装 安装请使用国内中科大的源(解决报错问题) https://guizimo.blog.csdn.net/article/details/107419919 1brew install subversion 测试1svn --version 感谢 百度百科 以及勤劳的自己","categories":[],"tags":[]},{"title":"Brew发现自动更新homebrew时卡住","slug":"Brew发现自动更新homebrew时卡住","date":"2020-07-17T15:05:35.764Z","updated":"2020-07-29T15:11:22.514Z","comments":true,"path":"2020/07/17/Brew发现自动更新homebrew时卡住/","link":"","permalink":"https://tangleia.github.io/2020/07/17/Brew%E5%8F%91%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0homebrew%E6%97%B6%E5%8D%A1%E4%BD%8F/","excerpt":"Brew发现自动更新homebrew时卡住","text":"Brew发现自动更新homebrew时卡住 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 原因因为我之前换过源，换成了是阿里的源，然后阿里的源没有cask，所以出错在这里 解决换成中科大的源 1234567891011// 替换brew.git:cd \"$(brew --repo)\"git remote set-url origin https://mirrors.ustc.edu.cn/brew.git// 替换homebrew-core.git:cd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\"git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git// 替换homebrew-cask.git:cd \"$(brew --repo)\"/Library/Taps/homebrew/homebrew-cask git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git 更新源 1brew update 之后再次安装就解决了问题 感谢 百度百科 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac安装oracle（使用Docker）","slug":"Mac安装oracle（使用Docker）","date":"2020-07-17T14:47:12.663Z","updated":"2020-07-29T16:03:56.131Z","comments":true,"path":"2020/07/17/Mac安装oracle（使用Docker）/","link":"","permalink":"https://tangleia.github.io/2020/07/17/Mac%E5%AE%89%E8%A3%85oracle%EF%BC%88%E4%BD%BF%E7%94%A8Docker%EF%BC%89/","excerpt":"Mac安装oracle（使用Docker）","text":"Mac安装oracle（使用Docker） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 安装拉取oracle 11g 镜像，这个版本可以自行选择 1docker pull registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g 安装oracle容器 1docker run -dp 9090:8080 -p 1521:1521 registry.cn-hangzhou.aliyuncs.com&#x2F;helowin&#x2F;oracle_11g 进入容器 1docker exec -it 容器id &#x2F;bin&#x2F;bash 容器id可以通过一下命令查询 1docker ps -a 使用navicat连接默认值服务名：helowin 用户名：system 密码：helowin 测试 停止/启动oracle服务： 12docker stop oracledocker start oracle 感谢 百度百科 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac安装Docker配置网易源","slug":"Mac安装Docker配置网易源","date":"2020-07-17T14:19:35.363Z","updated":"2020-07-29T16:03:46.090Z","comments":true,"path":"2020/07/17/Mac安装Docker配置网易源/","link":"","permalink":"https://tangleia.github.io/2020/07/17/Mac%E5%AE%89%E8%A3%85Docker%E9%85%8D%E7%BD%AE%E7%BD%91%E6%98%93%E6%BA%90/","excerpt":"Mac安装Docker配置网易源","text":"Mac安装Docker配置网易源 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 安装使用brew安装 1brew cask install docker 这个过程有一会儿 安装成功后打开Docker，需要验证一下 配置源 找到配置镜像的地方，新版的改成这里了 代码1234567&#123; \"registry-mirrors\": [ \"https://hub-mirror.c.163.com\" ], \"experimental\": false, \"debug\": true&#125; 测试1docker -v 感谢 百度百科 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac下安装配置Maven并在IDEA中配置","slug":"Mac下安装配置Maven并在IDEA中配置","date":"2020-07-16T06:08:49.606Z","updated":"2020-07-29T16:04:40.354Z","comments":true,"path":"2020/07/16/Mac下安装配置Maven并在IDEA中配置/","link":"","permalink":"https://tangleia.github.io/2020/07/16/Mac%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEMaven%E5%B9%B6%E5%9C%A8IDEA%E4%B8%AD%E9%85%8D%E7%BD%AE/","excerpt":"Mac下安装配置Maven并在IDEA中配置","text":"Mac下安装配置Maven并在IDEA中配置 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 下载Maven下载地址 注意看自己系统，mac/linux下载tar.gz，windows下载zip 设置环境变量首先解压到usr/local下 打开终端，vim ~/.zshrc，在后面添加路径 12export MAVEN_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;apache-maven-3.6.3export PATH&#x3D;$PATH:$MAVEN_HOME&#x2F;bin 注意自己的版本和路径，应用配置source ~/.zshrc 测试mvn -v，出现以下表示安装成功 配置阿里云源打开 /usr/local/apache-maven-3.6.3/conf/settings.xml 配置文件 1234567&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt; 测试，在终端输入mvn help:system，下载一些默认的jar包到本地仓库 在 idea 中配置 maven 把默认的修改成我们刚才下载好的 因为仓库我没有改，所以没变，如果改了仓库那么就在这里也要配置好 测试创建一个maven项目 选择maven版本 然后就会自动补充maven项目所需要的依赖 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Redis --Java客户端 Jedis","slug":"Redis --Java客户端 Jedis","date":"2020-07-15T09:05:29.346Z","updated":"2020-07-29T16:05:07.560Z","comments":true,"path":"2020/07/15/Redis --Java客户端 Jedis/","link":"","permalink":"https://tangleia.github.io/2020/07/15/Redis%20--Java%E5%AE%A2%E6%88%B7%E7%AB%AF%20Jedis/","excerpt":"Redis –Java客户端 Jedis","text":"Redis –Java客户端 Jedis 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 简介Jedis: 一款java操作redis数据库的工具. 菜鸟教程文档地址 使用步骤导入jedis包 使用1234567891011121314151617181920package com.jedis.test;import org.junit.Test;import redis.clients.jedis.Jedis;/** * @author guizimo * @date 2020/7/15 4:42 下午 */public class JedisTest &#123; @Test public void test()&#123; //1. 获取连接 Jedis jedis = new Jedis(\"127.0.0.1\",6379); //2. 操作 jedis.set(\"name\",\"zhangsan\"); //3. 关闭连接 jedis.close(); &#125;&#125; 测试 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"JSON的介绍","slug":"JSON的介绍","date":"2020-07-15T08:06:37.856Z","updated":"2020-07-29T16:01:21.263Z","comments":true,"path":"2020/07/15/JSON的介绍/","link":"","permalink":"https://tangleia.github.io/2020/07/15/JSON%E7%9A%84%E4%BB%8B%E7%BB%8D/","excerpt":"JSON的介绍","text":"JSON的介绍 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 简介JSON: JavaScript Object Notation(JavaScript 对象表示法) JSON 是存储和交换文本信息的语法。类似 XML。 JSON 比 XML 更小、更快，更易解析。 语法JSON 语法是 JavaScript 对象表示语法的子集。 数据在名称/值对中 数据由逗号分隔 大括号保存对象 中括号保存数组 JSON 与 XMLJSON 与 XML 的相同之处： JSON 和 XML 数据都是 “自我描述” ，都易于理解。 JSON 和 XML 数据都是有层次的结构 JSON 和 XML 数据可以被大多数编程语言使用 JSON 与 XML 的不同之处： JSON 不需要结束标签 JSON 更加简短 JSON 读写速度更快 JSON 可以使用数组 123[JSON.parse(): 将一个 JSON 字符串转换为 JavaScript 对象。[JSON.stringify(): 于将 JavaScript 值转换为 JSON 字符串。 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"AJAX介绍和使用","slug":"AJAX介绍和使用","date":"2020-07-15T07:53:44.160Z","updated":"2020-07-29T15:10:49.916Z","comments":true,"path":"2020/07/15/AJAX介绍和使用/","link":"","permalink":"https://tangleia.github.io/2020/07/15/AJAX%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"AJAX介绍和使用","text":"AJAX介绍和使用 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 菜鸟教程地址https://www.runoob.com/ajax/ajax-tutorial.html 简介AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 异步和同步客户端和服务器端相互通信的基础上 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 实现方式使用js1234567891011121314151617181920212223242526272829303132333435363738394041//1.创建核心对象var xmlhttp;if (window.XMLHttpRequest)&#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest();&#125;else&#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;//2. 建立连接/* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);//3.发送请求xmlhttp.send();//4.接受并处理来自服务器的响应结果//获取方式 ：xmlhttp.responseText//什么时候获取？当服务器响应成功后再获取//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。xmlhttp.onreadystatechange=function()&#123; //判断readyState就绪状态是否为4，判断status响应状态码是否为200 if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125;&#125; 使用jquery$.ajax实现 1234567891011121314$.ajax(&#123; url:\"ajaxServlet1111\" , // 请求路径 type:\"POST\" , //请求方式 //data: \"username=jack&amp;age=23\",//请求参数 data:&#123;\"username\":\"jack\",\"age\":23&#125;, success:function (data) &#123; alert(data); &#125;,//响应成功后的回调函数 error:function () &#123; alert(\"出错啦...\") &#125;,//表示如果请求响应出现错误，会执行的回调函数 dataType:\"text\"//设置接受到的响应数据的格式&#125;); $.get 发送get请求 语法：$.get(url, [data], [callback], [type]) 参数： url：请求路径 data：请求参数 callback：回调函数 type：响应结果的类型 $.post() 发送post请求 语法：$.post(url, [data], [callback], [type]) 参数： url：请求路径 data：请求参数 callback：回调函数 type：响应结果的类型 感谢 菜鸟教程 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery--高级","slug":"jQuery--高级","date":"2020-07-15T07:29:20.924Z","updated":"2020-07-29T16:00:30.976Z","comments":true,"path":"2020/07/15/jQuery--高级/","link":"","permalink":"https://tangleia.github.io/2020/07/15/jQuery--%E9%AB%98%E7%BA%A7/","excerpt":"jQuery–高级","text":"jQuery–高级 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 动画三种方式显示和隐藏元素 默认显示和隐藏方式 show([speed,[easing],[fn]])，参数： speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000) easing：用来指定切换效果，默认是”swing”，可用参数”linear” swing：动画执行时效果是 先慢，中间快，最后又慢 linear：动画执行时速度是匀速的 fn：在动画完成时执行的函数，每个元素执行一次。 hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动显示和隐藏方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出显示和隐藏方式 fadeIn([speed],[easing],[fn]) fadeOut([speed],[easing],[fn]) fadeToggle([speed,[easing],[fn]]) 遍历js的遍历方式 for(初始化值;循环结束条件;步长) jquery的遍历方式 jq对象.each(callback) 语法： 1234jquery对象.each(function(index,element)&#123;&#125;);index:就是元素在集合中的索引element：就是集合中的每一个元素对象this：集合中的每一个元素对象 回调函数返回值： true:如果当前function返回为false，则结束循环(break)。 false:如果当前function返回为true，则结束本次循环，继续下次循环(continue) $.each(object, [callback]) for..of: jquery 3.0 版本之后提供的方式 for(元素对象 of 容器对象) 事件绑定 jquery标准的绑定方式 jq对象.事件方法(回调函数)； 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。 表单对象.submit();//让表单提交 on绑定事件/off解除绑定 jq对象.on(“事件名称”,回调函数) jq对象.off(“事件名称”) 如果off方法不传递任何参数，则将组件上的所有事件全部解绑 事件切换：toggle jq对象.toggle(fn1,fn2…) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2….. 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。 1&lt;script src=\"../js/jquery-migrate-1.0.0.js\" type=\"text/javascript\" charset=\"utf-8\"&gt;&lt;/script&gt; 插件增强JQuery的功能 实现方式： $.fn.extend(object) 增强通过Jquery获取的对象的功能 $(“#id”) $.extend(object) 增强JQeury对象自身的功能 $/jQuery 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–二维数组中的查找","slug":"LeetCode–二维数组中的查找","date":"2020-07-14T05:56:57.055Z","updated":"2020-07-29T16:03:13.321Z","comments":true,"path":"2020/07/14/LeetCode–二维数组中的查找/","link":"","permalink":"https://tangleia.github.io/2020/07/14/LeetCode%E2%80%93%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","excerpt":"LeetCode–二维数组中的查找","text":"LeetCode–二维数组中的查找 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明剑指offer，4题，主站 240题 二维数组中的查找 题目在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： 1234567[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 Java使用线性查找，从右上角开始查找，因为一行的最大值在右上角，如果比当前的值小，那么就向左查询，如果比当前的值大，那么就向右查 12345678910111213141516171819class Solution &#123; public boolean findNumberIn2DArray(int[][] matrix, int target) &#123; if(matrix.length == 0 || matrix[0].length == 0)&#123; return false; &#125; int x = 0, y = matrix[0].length - 1; while(x&lt;matrix.length &amp;&amp; y&gt;=0)&#123; int num = matrix[x][y]; if(num == target)&#123; return true; &#125;else if(num &gt; target)&#123; y--; &#125;else&#123; x++; &#125; &#125; return false; &#125;&#125; Go使用线性查找，从右上角开始查找，因为一行的最大值在右上角，如果比当前的值小，那么就向左查询，如果比当前的值大，那么就向右查 1234567891011121314func findNumberIn2DArray(matrix [][]int, target int) bool &#123; y := len(matrix[0])-1 x := 0 for x&lt;len(matrix) &amp;&amp; y&gt;=0&#123; if matrix[x][y] == target&#123; return true &#125;else if matrix[x][y] &gt; target&#123; y-- &#125;else&#123; x++ &#125; &#125; return false;&#125; C使用线性查找，从右上角开始查找，因为一行的最大值在右上角，如果比当前的值小，那么就向左查询，如果比当前的值大，那么就向右查 1234567891011121314bool findNumberIn2DArray(int** matrix, int matrixSize, int* matrixColSize, int target)&#123; int x = 0; int y = matrixSize - 1; while(x&lt;matrixSize &amp;&amp; y&gt;=0)&#123; if(matrix[x][y] == target)&#123; return true; &#125;else if(matrix[x][y] &gt; target)&#123; y--; &#125;else&#123; x++; &#125; &#125; return false;&#125; PHP暴力法 123456789101112131415161718192021class Solution &#123; /** * @param Integer[][] $matrix * @param Integer $target * @return Boolean */ function findNumberIn2DArray($matrix, $target) &#123; if(count($matrix)==0 || count($matrix[0])==0)&#123; return false; &#125; for($i = 0;$i&lt;count($matrix);$i++)&#123; for($j = 0; $j&lt;count($matrix[$i]);$j++)&#123; if($matrix[$i][$j] == $target)&#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 线性查找 12345678910111213141516class Solution &#123; /** * @param Integer[] $nums * @return Integer */ function findRepeatNumber($nums) &#123; $res = []; for($i=0;$i&lt;count($nums);$i++)&#123; if(isset($res[$nums[$i]]))&#123; return $nums[$i]; &#125; $res[$nums[$i]] = ''; &#125; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–数组中重复的数字","slug":"LeetCode–数组中重复的数字","date":"2020-07-13T05:27:58.831Z","updated":"2020-07-29T16:03:25.252Z","comments":true,"path":"2020/07/13/LeetCode–数组中重复的数字/","link":"","permalink":"https://tangleia.github.io/2020/07/13/LeetCode%E2%80%93%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"LeetCode–数组中重复的数字","text":"LeetCode–数组中重复的数字 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明剑指offer，3题 数组中重复的数字 题目在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 Java使用set集合，遍历数组，将值存入set集合，当存入错误的时候，表示遇到重复的数字，返回此时的元素即可 12345678910111213class Solution &#123; public int findRepeatNumber(int[] nums) &#123; Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int temp = -1; for(int num : nums)&#123; if(!set.add(num))&#123; temp = num; break; &#125; &#125; return temp; &#125;&#125; Go使用map集合，遍历数组，当map集合的长度不改变，即遇到重复的数字 12345678910func findRepeatNumber(nums []int) int &#123; find := make(map[int]int, 0) for k, v := range nums &#123; find[v] = v if len(find) == k &#123; return v &#125; &#125; return 0&#125; C建立一个同等大小的空数组，原数组的值为新数组的下标，判断是否为第一次访问，访问一次置1，第二次访问直接返回该值。 123456789101112int findRepeatNumber(int* nums, int numsSize)&#123; int i = 0; char *tmp = calloc(numsSize,sizeof(int)); for(i=0;i&lt;numsSize;i++)&#123; if(tmp[nums[i]] == 0)&#123; tmp[nums[i]] = 1; &#125;else&#123; return nums[i]; &#125; &#125; return -1;&#125; PHP新建一个空数组，遍历数组，将元素依次插入新数组当中，使用isset判断是否重复 12345678910111213141516class Solution &#123; /** * @param Integer[] $nums * @return Integer */ function findRepeatNumber($nums) &#123; $res = []; for($i=0;$i&lt;count($nums);$i++)&#123; if(isset($res[$nums[$i]]))&#123; return $nums[$i]; &#125; $res[$nums[$i]] = ''; &#125; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java面试题——随机题（一），看看哪些你会哪些你不会","slug":"Java面试题——随机题（一），看看哪些你会哪些你不会","date":"2020-07-13T04:14:16.276Z","updated":"2020-07-29T15:57:24.963Z","comments":true,"path":"2020/07/13/Java面试题——随机题（一），看看哪些你会哪些你不会/","link":"","permalink":"https://tangleia.github.io/2020/07/13/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E9%9A%8F%E6%9C%BA%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%8C%E7%9C%8B%E7%9C%8B%E5%93%AA%E4%BA%9B%E4%BD%A0%E4%BC%9A%E5%93%AA%E4%BA%9B%E4%BD%A0%E4%B8%8D%E4%BC%9A/","excerpt":"Java面试题——随机题（一），看看哪些你会哪些你不会","text":"Java面试题——随机题（一），看看哪些你会哪些你不会 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 请说明一下EJB的几种类型分别是什么？会话（Session）Bean、实体（Entity）Bean 、消息驱动的（Message Driven）Bean 会话Bean又可分为有状态（Stateful）和无状态（Stateless）两种 实体Bean可分为Bean管理的持续性（BMP）和容器管理的持续性（CMP）两种。 请说明一下锁机制的作用是什么？并且简述一下Hibernate的悲观锁和乐观锁机制是什么？锁机制的作用是保证共享资源可以进行排他性的访问 悲观锁悲观的认为在数据处理过程中极有可能存在修改数据的并发事务（包括本系统的其他事务或来自外部系统的事务），于是将处理的数据设置为锁定状态。 数据库中主要是通过数据库底层的锁机制才能保证真正的数据访问排他性。 缺点：并发量不高，效率低； 乐观锁对并发事务持乐观态度（认为对数据的并发操作不会经常性的发生），通过更加宽松的锁机制来解决由于悲观锁排他性的数据访问对系统性能造成的严重影响。最常见的乐观锁是通过数据版本标识来实现的 redis为什么是单线程？多线程不一定比单线程效率高，多线程的本质就是CPU通过轮换时间片执行不同的线程，看似多个线程一起执行，但是却承担线程上下文切换的代价。 而对于Redis这样的内存数据库来说，没有上下文的切换的单线程效率是最高的。Redis用单个CPU绑定一块内存的数据，然后针对这块内存的数据进行多次读写操作都是在一个CPU上完成的。 请你谈谈Java中线程如何实现，以及如何实现多线程，线程安全在Java中是如何实现的，线程的工作区是哪里Java多线程有三种实现方式(1)继承Thread类，重写run函数 (2)实现Runnable接口，重写run函数 开启线程：Thread t = new Thread(对象) //创建线程对象 t.start() (3)实现Callable接口，重写call函数 Callable是类似于Runnable的接口，实现Callable接口的类和实现Runnable的类都是可被其它线程执行的任务。 Callable和Runnable有几点不同:①Callable规定的方法是call()，而Runnable规定的方法是run() ②Callable的任务执行后可返回值，而Runnable的任务是不能返回值的 ③call()方法可抛出异常，而run()方法是不能抛出异常的。 ④运行Callable任务可拿到一个Future对象，Future表示异步计算的结果。它提供了检查计算是否完成的方法,以等待计算的完成,并检索计算的结果.通过Future对象可了解任务执行情况,可取消任务的执行,还可获取任务执行的结果 线程不安全的原因：在操作系统中，线程是不拥有资源的，进程是拥有资源的。而线程是由进程创建的，一个进程可以创建多个线程，这些线程共享着进程中的资源。所以，当线程一起并发运行时，同时对一个数据进行修改，就可能会造成数据的不一致性 线程安全的解决机制： 加锁。 锁能使其保护的代码以串行的形式来访问，当给一个复合操作加锁后，能使其成为原子操作。一种错误的思想是只要对写数据的方法加锁，其实这是错的，对数据进行操作的所有方法都需加锁，不管是读还是写。 加锁时需要考虑性能问题，不能总是一味地给整个方法加锁synchronized就了事了，应该将方法中不影响共享状态且执行时间比较长的代码分离出去。 加锁的含义不仅仅局限于互斥，还包括可见性。为了确保所有线程都能看见最新值，读操作和写操作必须使用同样的锁对象。 不共享状态 无状态对象： 无状态对象一定是线程安全的，因为不会影响到其他线程。 线程关闭： 仅在单线程环境下使用。 不可变对象 可以使用final修饰的对象保证线程安全，由于final修饰的引用型变量(除String外)不可变是指引用不可变，但其指向的对象是可变的，所以此类必须安全发布，也即不能对外提供可以修改final对象的接口。 线程的工作区Java内存模型分为主内存，和工作内存。主内存是所有的线程所共享的，工作内存是每个线程自己有一个，不是共享的。 每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝。线程对变量的所有操作（读取、赋值），都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成 感谢 牛客网 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery DOM操作","slug":"jQuery DOM操作","date":"2020-07-11T08:25:35.935Z","updated":"2020-07-29T16:00:20.859Z","comments":true,"path":"2020/07/11/jQuery DOM操作/","link":"","permalink":"https://tangleia.github.io/2020/07/11/jQuery%20DOM%E6%93%8D%E4%BD%9C/","excerpt":"jQuery DOM操作","text":"jQuery DOM操作 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 内容操作 html() 获取/设置元素的标签体内容 1&lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; text() 获取/设置元素的标签体纯文本内容 1&lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 val() 获取/设置元素的value属性值 属性操作通用属性操作 attr() 获取/设置元素的属性 removeAttr() 删除属性 prop() 获取/设置元素的属性 removeProp() 删除属性 attr和prop区别？ 如果操作的是元素的固有属性，则建议使用prop 如果操作的是元素自定义的属性，则建议使用attr 对class属性操作 addClass() 添加class属性值 removeClass() 删除class属性值 toggleClass() 切换class属性 toggleClass(“one”): 判断如果元素对象上存在class=”one”，则将属性值one删除掉。 如果元素对象上不存在class=”one”，则添加 css(): 添加样式 CRUD操作 append() 父元素将子元素追加到末尾 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 prepend() 父元素将子元素追加到开头 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 appendTo() 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 prependTo() 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 after() 添加元素到元素后边 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 before() 添加元素到元素前边 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 insertAfter() 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 insertBefore() 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 remove() 移除元素 对象.remove():将对象删除掉 empty() 清空元素的所有后代元素。 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery 选择器","slug":"jQuery 选择器","date":"2020-07-11T08:05:49.638Z","updated":"2020-07-29T16:00:09.547Z","comments":true,"path":"2020/07/11/jQuery 选择器/","link":"","permalink":"https://tangleia.github.io/2020/07/11/jQuery%20%E9%80%89%E6%8B%A9%E5%99%A8/","excerpt":"jQuery 选择器","text":"jQuery 选择器 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 jQuery 中所有选择器都以美元符号开头：$()。 分类基本选择器 标签选择器（元素选择器） 语法： $(“html标签名”) 获得所有匹配标签名称的元素 id选择器 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素 类选择器 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素 并集选择器： 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素 层级选择器 后代选择器 语法： $(“A B “) 选择A元素内部的所有B元素 子选择器 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素 属性选择器 属性名称选择器 语法： $(“A[属性名]”) 包含指定属性的选择器 属性选择器 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器 复合属性选择器 语法： $(“A[属性名=’值’]…”) 包含多个属性条件的选择器 过滤选择器 首元素选择器 语法： :first 获得选择的元素中的第一个元素 尾元素选择器 语法： :last 获得选择的元素中的最后一个元素 非元素选择器 语法： :not(selector) 不包括指定内容的元素 偶数选择器 语法： :even 偶数，从 0 开始计数 奇数选择器 语法： :odd 奇数，从 0 开始计数 等于索引选择器 语法： :eq(index) 指定索引元素 大于索引选择器 语法： :gt(index) 大于指定索引元素 小于索引选择器 语法： :lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 语法： :enabled 获得可用元素 不可用元素选择器 语法： :disabled 获得不可用元素 选中选择器 语法： :checked 获得单选/复选框选中的元素 选中选择器 语法： :selected 获得下拉框选中的元素 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery--基本语法","slug":"jQuery--基本语法","date":"2020-07-11T07:49:56.364Z","updated":"2020-07-29T16:00:49.104Z","comments":true,"path":"2020/07/11/jQuery--基本语法/","link":"","permalink":"https://tangleia.github.io/2020/07/11/jQuery--%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"jQuery 选择器","text":"jQuery 选择器 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍jQuery 选择器允许您对 HTML 元素组或单个元素进行操作。 jQuery 选择器基于元素的 id、类、类型、属性、属性值等”查找”（或选择）HTML 元素。 jQuery 中所有选择器都以美元符号开头：$()。 分类基本选择器 标签选择器（元素选择器） 语法： $(“html标签名”) 获得所有匹配标签名称的元素 id选择器 语法： $(“#id的属性值”) 获得与指定id属性值匹配的元素 类选择器 语法： $(“.class的属性值”) 获得与指定的class属性值匹配的元素 并集选择器： 语法： $(“选择器1,选择器2….”) 获取多个选择器选中的所有元素 层级选择器 后代选择器 语法： $(“A B “) 选择A元素内部的所有B元素 子选择器 语法： $(“A &gt; B”) 选择A元素内部的所有B子元素 属性选择器 属性名称选择器 语法： $(“A[属性名]”) 包含指定属性的选择器 属性选择器 语法： $(“A[属性名=’值’]”) 包含指定属性等于指定值的选择器 复合属性选择器 语法： $(“A[属性名=’值’]…”) 包含多个属性条件的选择器 过滤选择器 首元素选择器 语法： :first 获得选择的元素中的第一个元素 尾元素选择器 语法： :last 获得选择的元素中的最后一个元素 非元素选择器 语法： :not(selector) 不包括指定内容的元素 偶数选择器 语法： :even 偶数，从 0 开始计数 奇数选择器 语法： :odd 奇数，从 0 开始计数 等于索引选择器 语法： :eq(index) 指定索引元素 大于索引选择器 语法： :gt(index) 大于指定索引元素 小于索引选择器 语法： :lt(index) 小于指定索引元素 标题选择器 语法： :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 语法： :enabled 获得可用元素 不可用元素选择器 语法： :disabled 获得不可用元素 选中选择器 语法： :checked 获得单选/复选框选中的元素 选中选择器 语法： :selected 获得下拉框选中的元素 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"jQuery--简介和使用","slug":"jQuery--简介和使用","date":"2020-07-11T07:18:01.700Z","updated":"2020-07-29T16:01:11.243Z","comments":true,"path":"2020/07/11/jQuery--简介和使用/","link":"","permalink":"https://tangleia.github.io/2020/07/11/jQuery--%E7%AE%80%E4%BB%8B%E5%92%8C%E4%BD%BF%E7%94%A8/","excerpt":"jQuery–简介和使用","text":"jQuery–简介和使用 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。 作用jQuery是一个JavaScript函数库。 jQuery是一个轻量级的”写的少，做的多”的JavaScript库。 jQuery库包含以下功能： HTML 元素选取 HTML 元素操作 CSS 操作 HTML 事件函数 JavaScript 特效和动画 HTML DOM 遍历和修改 AJAX Utilities 下载 jquery.com从这个网站上下载即可 使用jQuery 库是一个 JavaScript 文件，您可以使用 HTML 的 标签引用它： 123&lt;head&gt; &lt;script src=\"jquery-1.10.2.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; 也可以使用CDN 1234&lt;head&gt;&lt;script src=\"https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\"&gt;&lt;/script&gt;&lt;/head&gt; 感谢 百度百科 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--Filter（过滤器）","slug":"Java--Filter（过滤器）","date":"2020-07-10T11:58:30.653Z","updated":"2020-07-29T15:25:44.485Z","comments":true,"path":"2020/07/10/Java--Filter（过滤器）/","link":"","permalink":"https://tangleia.github.io/2020/07/10/Java--Filter%EF%BC%88%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89/","excerpt":"Java–Filter（过滤器）","text":"Java–Filter（过滤器） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 简介Filter也称之为过滤器，它是Servlet技术中最实用的技术，Web开发人员通过Filter技术，对web服务器管理的所有web资源，例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。 实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 配置注解方式1234567891011121314151617181920@WebFilter(&quot;&#x2F;*&quot;)&#x2F;&#x2F;访问所有资源之前，都会执行该过滤器public class Filter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println(&quot;filter被执行了....&quot;); &#x2F;&#x2F;放行 filterChain.doFilter(servletRequest,servletResponse); &#125; @Override public void destroy() &#123; &#125; &#125; web.xml123456789&lt;filter&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;&#x2F;filter-class&gt; &lt;&#x2F;filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;demo1&lt;&#x2F;filter-name&gt; &lt;!-- 拦截路径 --&gt; &lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt; &lt;&#x2F;filter-mapping&gt; 过滤器生命周期方法init在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源 doFilter每一次请求被拦截资源时，会执行。执行多次 destroy在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源 过滤器配置详解拦截路径配置 具体资源路径： /index.jsp 只有访问index.jsp资源时，过滤器才会被执行 拦截目录： /user/* 访问/user下的所有资源时，过滤器都会被执行 后缀名拦截： *.jsp 访问所有后缀名为jsp资源时，过滤器都会被执行 拦截所有资源：/* 访问所有资源时，过滤器都会被执行 拦截方式配置：资源被访问的方式 注解配置： 设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置 设置标签 1&lt;dispatcher&gt;&lt;&#x2F;dispatcher&gt; 配置多个过滤器 执行顺序：如果有两个过滤器：过滤器1和过滤器2，具体过程？ 123456789过滤器1过滤器2资源执行过滤器2过滤器1 过滤器先后顺序问题有两个过滤器先执行哪一个？ 注解配置：按照类名的字符串比较规则比较，值小的先执行 如： AFilter 和 BFilter，AFilter就先执行了。 web.xml配置： 谁定义在上边，谁先执行 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"TP5.1让验证码在另外的项目（Electron-vue）里面使用","slug":"TP5.1让验证码在另外的项目（Electron-vue）里面使用","date":"2020-07-10T04:47:07.203Z","updated":"2020-07-29T16:07:36.743Z","comments":true,"path":"2020/07/10/TP5.1让验证码在另外的项目（Electron-vue）里面使用/","link":"","permalink":"https://tangleia.github.io/2020/07/10/TP5.1%E8%AE%A9%E9%AA%8C%E8%AF%81%E7%A0%81%E5%9C%A8%E5%8F%A6%E5%A4%96%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%88Electron-vue%EF%BC%89%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8/","excerpt":"TP5.1验证Token和Electron-vue头部携带Token","text":"TP5.1验证Token和Electron-vue头部携带Token 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍在做一个Electron-vue的项目的时候需要使用到登录，使用TP5.1作为后台框架，正规的流程是在Electron-vue中携带Token信息，在TP5.1中验证Token来判断是否过期 Electron-vue头部携带Token在配置拦截器的时候配置请求头 1234567891011// request拦截器service.interceptors.request.use(config =&gt; &#123; if (store.getters.token) &#123; config.headers['Authorization'] = store.getters.token// 让每个请求携带自定义token 请根据实际情况自行修改 &#125; return config&#125;, error =&gt; &#123; // Do something with request error console.log(error) // for debug Promise.reject(error)&#125;) 注意这个Authorization必须是在后端跨域的Access-Control-Allow-Headers参数中有的，比如 123Access-Control-Allow-Origin:*Access-Control-Allow-Methods:GET, POST, PATCH, PUT, DELETEAccess-Control-Allow-Headers:Authorization, Content-Type, If-Match, If-Modified-Since, If-None-Match, If-Unmodified-Since, X-Requested-With TP5.1验证Token首先在路由的时候设置中间件 然后我们的验证就写在这个中间件里面 123456789101112131415public function handle($request, \\Closure $next) &#123; // 获取头部信息 $param = $request-&gt;header(); // 不含token if (!array_key_exists('authorization', $param)) TApiException('非法token，禁止操作', 20003, 200); // 当前用户token是否存在（是否登录） $token = $param['authorization']; $user = Cache::get($token); // 验证失败（未登录或已过期） if (!$user) TApiException('非法token，请重新登录', 20003, 200); // 将token和userid这类常用参数放在request中 $request-&gt;userToken = $token; return $next($request); &#125; 这样经过配置过的路由都会验证Token，以此来判断用户是否登录 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue请求携带cookie跨域问题","slug":"Electron-vue请求携带cookie跨域问题","date":"2020-07-10T04:08:38.090Z","updated":"2020-07-29T15:12:12.241Z","comments":true,"path":"2020/07/10/Electron-vue请求携带cookie跨域问题/","link":"","permalink":"https://tangleia.github.io/2020/07/10/Electron-vue%E8%AF%B7%E6%B1%82%E6%90%BA%E5%B8%A6cookie%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"Electron-vue请求携带cookie跨域问题","text":"Electron-vue请求携带cookie跨域问题 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题说明在请求携带cookie的时候，跨域的问题又重新来了，原因在于cookie标识了服务器，我们在跨域配置的时候Access-Control-Allow-Origin，这个参数我们需要具体的指出，而不能使用* 问题解决这个跨域问题一般在后端，这里一TP5.1为例 在路由配置跨域的时候精确到具体的客户端服务器的地址，也就是你前端的地址 这样就可以啦 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue在发送请求时携带cookie","slug":"Electron-vue在发送请求时携带cookie","date":"2020-07-10T03:57:56.597Z","updated":"2020-07-29T15:17:31.526Z","comments":true,"path":"2020/07/10/Electron-vue在发送请求时携带cookie/","link":"","permalink":"https://tangleia.github.io/2020/07/10/Electron-vue%E5%9C%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%E6%97%B6%E6%90%BA%E5%B8%A6cookie/","excerpt":"Electron-vue在发送请求时携带cookie","text":"Electron-vue在发送请求时携带cookie 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 解决axios一般呢我们会遇到在vue项目使用它来发送的我们的请求，相当于ajax 我们在使用axios的时候默认给它配置 例如我在项目调用请求的时候封装了一个request类，在引入axios的时候，给它初始化配置 代码12import axios from 'axios'axios.defaults.withCredentials=true;//让ajax携带cookie vue项目类似（尽量在全局里面配置，比如main.js） 123import axios from 'axios'axios.defaults.withCredentials=true;//让ajax携带cookieVue.prototype.$axios = axios; 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"TP5.1解决跨域","slug":"TP5.1解决跨域","date":"2020-07-10T03:47:15.611Z","updated":"2020-07-29T16:09:08.662Z","comments":true,"path":"2020/07/10/TP5.1解决跨域/","link":"","permalink":"https://tangleia.github.io/2020/07/10/TP5.1%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/","excerpt":"TP5.1解决跨域","text":"TP5.1解决跨域 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍在前后端分离开发的时候就会遇到跨域的问题，在本地调试的时候可能不会出现什么太大的问题，但是上线部署的时候难免会遇到问题 不过这种跨域的问题还是最好在后端解决 官方手册地址https://www.kancloud.cn/manual/thinkphp5_1/489844 解决在我们的route目录下的route.php，可以分组配置路由 这个是默认的跨域设置，当然这个都可以自己添加的 123Access-Control-Allow-Origin:*Access-Control-Allow-Methods:GET, POST, PATCH, PUT, DELETEAccess-Control-Allow-Headers:Authorization, Content-Type, If-Match, If-Modified-Since, If-None-Match, If-Unmodified-Since, X-Requested-With 添加可以像这样的 12345Route::get('new/:id', 'News/read') -&gt;ext('html') -&gt;header('Access-Control-Allow-Origin','thinkphp.cn') -&gt;header('Access-Control-Allow-Credentials', 'true') -&gt;allowCrossDomain(); 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue解决跨域","slug":"Electron-vue解决跨域","date":"2020-07-10T03:39:56.714Z","updated":"2020-07-29T15:12:01.829Z","comments":true,"path":"2020/07/10/Electron-vue解决跨域/","link":"","permalink":"https://tangleia.github.io/2020/07/10/Electron-vue%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/","excerpt":"Electron-vue解决跨域","text":"Electron-vue解决跨域 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍在前后端分离开发的时候就会遇到跨域的问题，在本地调试的时候可能不会出现什么太大的问题，但是上线部署的时候难免会遇到问题 解决在.electron-vue下面的dev-runner.js里面的WebpackDevServer添加配置 代码1234567891011121314151617proxy: &#123; '/api': &#123; // 请求的目标服务器地址 target: 'https://www.domain.com', // 如果是https接口，需要配置这个参数 secure: false, // 设置允许跨域 changeOrigin: true, // 重写路径 pathRewrite: &#123; '^/api': '' &#125;, headers: &#123; referer: '' &#125; &#125;&#125;, 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue运行之后出现了文件浏览器","slug":"Electron-vue运行之后出现了文件浏览器","date":"2020-07-08T02:00:48.920Z","updated":"2020-07-29T15:17:21.412Z","comments":true,"path":"2020/07/08/Electron-vue运行之后出现了文件浏览器/","link":"","permalink":"https://tangleia.github.io/2020/07/08/Electron-vue%E8%BF%90%E8%A1%8C%E4%B9%8B%E5%90%8E%E5%87%BA%E7%8E%B0%E4%BA%86%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"Electron-vue运行之后出现了文件浏览器","text":"Electron-vue运行之后出现了文件浏览器 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题介绍在运行项目的时候出现了文件浏览器 问题原因（官方解释）你的 src/renderer 包含错误。请检查 控制台 (console)，修复错误，然后用 CommandOrControl+R 刷新 electron。 详述如果你的 src/renderer 中出现错误，则会在首次运行时与 ESLint 产生冲突。接着，一个无效的 webpack 的 renderer.js 会被生成出来，它会打断 HtmlWebpackPlugin 创建 index.html。由于 webpack-dev-server 没有 index.html 可以提供服务，所以服务器失败，程序返回到文件浏览器。 问题解决主要适合ESlint有关，将ESlint检查关闭就可以了，具体的在.electron-vue下面的三个配置文件里面的ESlint代码注释掉 那么这个问题就解决了 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Electron-vue取消代码检查","slug":"Electron-vue取消代码检查","date":"2020-07-08T01:34:48.713Z","updated":"2020-07-29T15:16:24.600Z","comments":true,"path":"2020/07/08/Electron-vue取消代码检查/","link":"","permalink":"https://tangleia.github.io/2020/07/08/Electron-vue%E5%8F%96%E6%B6%88%E4%BB%A3%E7%A0%81%E6%A3%80%E6%9F%A5/","excerpt":"Electron-vue取消代码检查Eslint","text":"Electron-vue取消代码检查Eslint 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍在项目运行的时候容易出现错误，特别是这种检查代码的，什么格式啊，甚至分号呀，一来就是一大推 方法一在创建项目的时候不使用eslint 这里选择no 方法二在.elerton-vue目录下里面的三个文件都修改一下 把有关eslint的都注释掉 记得要重新npm run dev 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"使用Composer安装TP5.1出现zsh no matches found 5.1","slug":"使用Composer安装TP5.1出现zsh no matches found 5.1","date":"2020-07-05T09:14:47.456Z","updated":"2020-07-29T15:09:16.834Z","comments":true,"path":"2020/07/05/使用Composer安装TP5.1出现zsh no matches found 5.1/","link":"","permalink":"https://tangleia.github.io/2020/07/05/%E4%BD%BF%E7%94%A8Composer%E5%AE%89%E8%A3%85TP5.1%E5%87%BA%E7%8E%B0zsh%20no%20matches%20found%205.1/","excerpt":"使用Composer安装TP5.1出现zsh: no matches found: 5.1.*","text":"使用Composer安装TP5.1出现zsh: no matches found: 5.1.* 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题提示zsh: no matches found: 5.1.* 问题解决在之前还是可以执行的，现在新建的时候出现了现在的问题 解决办法是不使用这个版本模糊的命令，直接确定版本 1composer create-project topthink&#x2F;think&#x3D;5.1.31 sight 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Composer切换国内源","slug":"Composer切换国内源","date":"2020-07-05T09:06:50.852Z","updated":"2020-07-29T15:11:34.945Z","comments":true,"path":"2020/07/05/Composer切换国内源/","link":"","permalink":"https://tangleia.github.io/2020/07/05/Composer%E5%88%87%E6%8D%A2%E5%9B%BD%E5%86%85%E6%BA%90/","excerpt":"Composer切换国内源","text":"Composer切换国内源 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 局部切换在当前项目下的composer.json中添加 1234567&#123;\"repositories\": [ &#123; \"type\": \"composer\", \"url\": \"https://mirrors.aliyun.com/composer/\" //第一个源 &#125;&#125; 全局切换首先把默认的源给禁用掉 1composer config -g secure-http false 再修改镜像源，这里使用阿里的源 1composer config -g repo.packagist composer https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;composer&#x2F; 查看 1composer config -g -l 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"TP5.1出现A non well formed numeric value encountered问题","slug":"TP5.1出现A non well formed numeric value encountered问题","date":"2020-07-05T08:57:09.443Z","updated":"2020-07-29T16:07:11.429Z","comments":true,"path":"2020/07/05/TP5.1出现A non well formed numeric value encountered问题/","link":"","permalink":"https://tangleia.github.io/2020/07/05/TP5.1%E5%87%BA%E7%8E%B0A%20non%20well%20formed%20numeric%20value%20encountered%E9%97%AE%E9%A2%98/","excerpt":"TP5.1出现A non well formed numeric value encountered问题","text":"TP5.1出现A non well formed numeric value encountered问题 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题介绍A non well formed numeric value encountered 出现这样的问题是tp5.1自动转化时间格式失败出现的问题 比如在数据库里面的字段是varchar格式的，在tp5.1里代码又是写的该字段是自动转化时间戳格式的，就会出错 问题解决在数据库中使用时间类的字段，或者使用int类型，或者不使用tp5.1的自动转化 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac正确解决checkPermissions Missing write access to问题","slug":"Mac正确解决checkPermissions Missing write access to问题","date":"2020-07-04T04:27:29.817Z","updated":"2020-07-29T16:04:56.309Z","comments":true,"path":"2020/07/04/Mac正确解决checkPermissions Missing write access to问题/","link":"","permalink":"https://tangleia.github.io/2020/07/04/Mac%E6%AD%A3%E7%A1%AE%E8%A7%A3%E5%86%B3checkPermissions%20Missing%20write%20access%20to%E9%97%AE%E9%A2%98/","excerpt":"Mac正确解决checkPermissions Missing write access to问题","text":"Mac正确解决checkPermissions Missing write access to问题 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题详情npm WARN checkPermissions Missing write access to /Users/tanglei/Downloads/sight/node_modules/uview-ui 问题解决刚开始以为是权限不够，那么就加权限sudo 然而还是没有用 那么就可能是已经有了这个文件了，把node_modules目录删除，再试一次 那么就解决了 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"LeetCode–最长公共前缀","slug":"LeetCode–最长公共前缀","date":"2020-07-01T10:19:34.000Z","updated":"2020-07-29T16:03:35.152Z","comments":true,"path":"2020/07/01/LeetCode–最长公共前缀/","link":"","permalink":"https://tangleia.github.io/2020/07/01/LeetCode%E2%80%93%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","excerpt":"LeetCode–最长公共前缀","text":"LeetCode–最长公共前缀 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明leetcode题，14题 最长公共前缀 题目编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 12输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot; 解释: 输入不存在公共前缀。 说明: 1所有输入只包含小写字母 a-z Java水平扫描法依次遍历字符串数组中的每个字符串，对于每个遍历到的字符串，更新最长公共前缀，当遍历完所有的字符串以后，即可得到字符串数组中的最长公共前缀。 12345678910111213141516171819202122232425262728class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if(strs == null || strs.length == 0)&#123; return \"\"; &#125; //假设第一个字段为公共前缀 String prefix = strs[0]; int count = strs.length; for(int i = 1;i&lt;count;i++)&#123; //获取两个字符串最长前缀 prefix = longestCommonPrefix(prefix,strs[i]); if(prefix.length() == 0)&#123; break; &#125; &#125; return prefix; &#125; //获取两个字符串最长前缀 public String longestCommonPrefix(String str1,String str2)&#123; int length = Math.min(str1.length(),str2.length()); int index = 0; while(index&lt;length &amp;&amp; str1.charAt(index) == str2.charAt(index))&#123; index++; &#125; return str1.substring(0,index); &#125;&#125; Python水平扫描法 123456789101112131415161718class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: if not strs: return \"\" #假设第一个字段为公共前缀 prefix , count = strs[0],len(strs) for i in range(1,count): #获取两个字符串最长前缀 prefix = self.commonPrefix(prefix,strs[i]) if not prefix: return \"\" return prefix #获取两个字符串最长前缀 def commonPrefix(self,str1,str2): length,index = min(len(str1),len(str2)),0 while index &lt; length and str1[index] == str2[index]: index += 1 return str1[:index] C++水平扫描法 123456789101112131415161718192021222324252627class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(!strs.size())&#123; return \"\"; &#125; string prefix = strs[0]; int count = strs.size(); for (int i = 1;i &lt; count; i++)&#123; prefix = longestCommonPrefix(prefix,strs[i]); if (!prefix.size())&#123; break; &#125; &#125; return prefix; &#125; string longestCommonPrefix(const string&amp; str1,const string&amp; str2)&#123; int index = 0; int length = min(str1.size(),str2.size()); while(index &lt; length &amp;&amp; str1[index] == str2[index])&#123; index++; &#125; return str1.substr(0,index); &#125;&#125;; PHP水平扫描法 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; /** * @param String[] $strs * @return String */ function longestCommonPrefix($strs) &#123; $prefix = ''; $i = 0; //判断其中是否有字符串长度为0 foreach($strs as $key =&gt; $value)&#123; if($value == '')&#123; return $prefix; &#125; &#125; //判断个数是否为空 if(count($strs)&lt;1)&#123; return $prefix; &#125; while(true)&#123; //获取当前第i个字符 $current = $strs[0]&#123;$i&#125;; if(!$current)&#123; return $prefix; &#125; foreach($strs as $key =&gt; $value)&#123; if($value&#123;$i&#125; != $current)&#123; return $prefix; &#125; &#125; $prefix .= $current; $i++; &#125; return $prefix; &#125;&#125; 感谢 leetcode 以及勤劳的自己","categories":[],"tags":[]},{"title":"查找--差值查找（Java）","slug":"查找--差值查找（Java）","date":"2020-07-01T00:53:03.000Z","updated":"2020-07-29T15:03:12.162Z","comments":true,"path":"2020/07/01/查找--差值查找（Java）/","link":"","permalink":"https://tangleia.github.io/2020/07/01/%E6%9F%A5%E6%89%BE--%E5%B7%AE%E5%80%BC%E6%9F%A5%E6%89%BE%EF%BC%88Java%EF%BC%89/","excerpt":"查找–差值查找（Java）","text":"查找–差值查找（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。 自适应计算自适应mid int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left]) 代码1234567891011121314151617181920212223242526272829303132package cn.guizimo.search;public class InsertValueSearch &#123; public static void main(String[] args) &#123; int max = 100; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = i + 1; &#125; int index = insertValueSearch(arr, 0, arr.length - 1, 100); if(index == -1)&#123; System.out.println(\"未找到\"); &#125;else &#123; System.out.println(\"下标为：\"+index); &#125; &#125; public static int insertValueSearch(int[] arr, int left, int right, int value) &#123; if (left &gt; right || value &lt; arr[0] || value &gt; arr[arr.length - 1]) &#123; return -1; &#125; int mid = left + (right - left) * (value - arr[left]) / (arr[right] - arr[left]); int midValue = arr[left]; if (value &gt; arr[mid]) &#123; return insertValueSearch(arr, mid + 1, right, value); &#125; else if (value &lt; arr[mid]) &#123; return insertValueSearch(arr, left, mid - 1, value); &#125; else &#123; return mid; &#125; &#125;&#125; 注意的事项 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找, 速度较快. 关键字分布不均匀的情况下，该方法不一定比折半查找要好 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"查找--二分查找（Java）","slug":"查找--二分查找（Java）","date":"2020-06-30T06:22:39.000Z","updated":"2020-07-29T15:05:57.187Z","comments":true,"path":"2020/06/30/查找--二分查找（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/30/%E6%9F%A5%E6%89%BE--%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%88Java%EF%BC%89/","excerpt":"查找–二分查找（Java）","text":"查找–二分查找（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 过程首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 代码12345678910111213141516171819202122232425262728package cn.guizimo.search;public class BinarySearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 5, 26, 68, 100, 235, 667, 896, 999&#125;; int index = binarySearch(arr, 0, arr.length - 1, 26); if(index == -1)&#123; System.out.println(\"未找到\"); &#125;else &#123; System.out.println(\"下标为：\"+index); &#125; &#125; public static int binarySearch(int[] arr, int left, int right, int value) &#123; if (left &gt; right) &#123; return -1; &#125; int mid = (right + left) / 2; int midValue = arr[mid]; if (value &gt; midValue) &#123; return binarySearch(arr, mid + 1, right, value); &#125; else if (value &lt; midValue) &#123; return binarySearch(arr, left, mid - 1, value); &#125; else &#123; return mid; &#125; &#125;&#125; 优化将数列中重复的数的下标全部找到 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package cn.guizimo.search;import java.util.ArrayList;import java.util.List;public class BinarySearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 5, 26, 26, 26, 26, 68, 100, 235, 667, 896, 999&#125;; List&lt;Integer&gt; arrayList = binarySearch(arr, 0, arr.length - 1, 25); if (arrayList.size() == 0) &#123; System.out.println(\"未找到\"); &#125; else &#123; System.out.println(\"下标集为：\" + arrayList); &#125; &#125; public static List&lt;Integer&gt; binarySearch(int[] arr, int left, int right, int value) &#123; if (left &gt; right) &#123; return new ArrayList&lt;Integer&gt;(); &#125; int mid = (left + right) / 2; int midValue = arr[mid]; if (value &gt; midValue) &#123; return binarySearch(arr, mid + 1, right, value); &#125; else if (value &lt; midValue) &#123; return binarySearch(arr, left, mid - 1, value); &#125; else &#123; List&lt;Integer&gt; resIndexList = new ArrayList&lt;Integer&gt;(); int temp = mid - 1; while (true) &#123; if (temp &lt; 0 || arr[temp] != value) &#123; break; &#125; resIndexList.add(temp); temp -= 1; &#125; resIndexList.add(mid); temp = mid + 1; while (true) &#123; if (temp &gt; arr.length - 1 || arr[temp] != value) &#123; break; &#125; resIndexList.add(temp); temp += 1; &#125; return resIndexList; &#125; &#125;&#125; 感谢 尚硅谷 百度百科 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"查找--线性查找（Java）","slug":"查找--线性查找（Java）","date":"2020-06-30T04:23:01.000Z","updated":"2020-07-29T15:05:53.319Z","comments":true,"path":"2020/06/30/查找--线性查找（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/30/%E6%9F%A5%E6%89%BE--%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%EF%BC%88Java%EF%BC%89/","excerpt":"查找–线性查找（Java）","text":"查找–线性查找（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 介绍线性查找又称顺序查找，是一种最简单的查找方法，它的基本思想是从第一个记录开始，逐个比较记录的关键字，直到和给定的K值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败 线性查找可以的数列可以是有序的也可以是无序的 代码12345678910111213141516171819202122package cn.guizimo.search;public class OrderSearch &#123; public static void main(String[] args) &#123; int[] arr = &#123;1, 69, 35, 89, 1100, 456, 2&#125;; int index = orderSearch(arr, 2); if(index == -1)&#123; System.out.println(\"未找到\"); &#125;else &#123; System.out.println(\"下标为：\"+index); &#125; &#125; public static int orderSearch(int[] arr,int value)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == value)&#123; return i; &#125; &#125; return -1; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--小项目（登录、增删改查、分页、搜索）","slug":"Java--小项目（登录、增删改查、分页、搜索）","date":"2020-06-29T11:24:31.000Z","updated":"2020-07-29T15:25:28.585Z","comments":true,"path":"2020/06/29/Java--小项目（登录、增删改查、分页、搜索）/","link":"","permalink":"https://tangleia.github.io/2020/06/29/Java--%E5%B0%8F%E9%A1%B9%E7%9B%AE%EF%BC%88%E7%99%BB%E5%BD%95%E3%80%81%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E3%80%81%E5%88%86%E9%A1%B5%E3%80%81%E6%90%9C%E7%B4%A2%EF%BC%89/","excerpt":"Java–小项目（登录、增删改查、分页、搜索）","text":"Java–小项目（登录、增删改查、分页、搜索） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念技术选型Servlet、JSP、MySQL、JDBCTempleat、Duird、BeanUtilS、tomcat 功能介绍登录功能，列表展示，数据添加，数据编辑，数据删除，批量删除，分页展示，关键字搜索 创建JavaWeb项目 导入依赖 添加页面文件 数据库12345678910111213create database little; -- 创建数据库use little; -- 使用数据库create table user( -- 创建表 id int primary key auto_increment, name varchar(20) not null, gender varchar(5), age int, address varchar(32), qq varchar(20), email varchar(50, username varchar(32), password varchar(32),); 列表展示思路首先我们需要一组列表的数据，那么我们就需要一个相对应servlet，通过我们的三层架构，使用service同一做接口，然后调用dao层使用JBDC操作数据库，这样我们可以获得一个map集合的数据，然后就是渲染数据到jsp页面了，通过JSTL和EL把数据循环渲染到表里面，达到列表的展示 list.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/28 Time: 下午2:15 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; td, th &#123; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;h3 style=\"text-align: center\"&gt;用户信息列表&lt;/h3&gt; &lt;table border=\"1\" class=\"table table-bordered table-hover\"&gt; &lt;tr class=\"success\"&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;users&#125;\" var=\"user\" varStatus=\"s\"&gt; &lt;tr&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt;&lt;a class=\"btn btn-default btn-sm\" href=\"update.html\"&gt;修改&lt;/a&gt;&amp;nbsp;&lt;a class=\"btn btn-default btn-sm\" href=\"\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;tr&gt; &lt;td colspan=\"8\" align=\"center\"&gt;&lt;a class=\"btn btn-primary\" href=\"add.html\"&gt;添加联系人&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; servlet代码文件很多，就不一一展示了 UserListServlet1234567891011121314151617181920212223242526272829303132package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@WebServlet(\"/userListServlet\")public class UserListServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //调用UserService完成查询 UserService userService = new UserServiceImpl(); List&lt;User&gt; users = userService.findAll(); //存入request域 req.setAttribute(\"users\",users); //转发到list.jsp req.getRequestDispatcher(\"/list.jsp\").forward(req,resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 登录思路登录功能首先就是对表单提交的数据进行比对，验证码可以在生成的时候就把它存入到session中，然后在servlet中进行比对，其他的字段在通过调用dao层的JDBC操作数据库进行比对，最后把登录成功的用户信息存入session中 login.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/28 Time: 下午7:37 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"/&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/&gt; &lt;title&gt;管理员登录&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function refreshCode() &#123; let vcode = document.getElementById(\"vcode\"); vcode.src = \"$&#123;pageContext.request.contextPath&#125;/checkCodeServlet?=\" + new Date().getTime(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\" style=\"width: 400px;\"&gt; &lt;h3 style=\"text-align: center;\"&gt;管理员登录&lt;/h3&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/loginServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"user\"&gt;用户名：&lt;/label&gt; &lt;input type=\"text\" name=\"username\" class=\"form-control\" id=\"user\" placeholder=\"请输入用户名\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"password\"&gt;密码：&lt;/label&gt; &lt;input type=\"password\" name=\"password\" class=\"form-control\" id=\"password\" placeholder=\"请输入密码\"/&gt; &lt;/div&gt; &lt;div class=\"form-inline\"&gt; &lt;label for=\"vcode\"&gt;验证码：&lt;/label&gt; &lt;input type=\"text\" name=\"verifycode\" class=\"form-control\" id=\"verifycode\" placeholder=\"请输入验证码\" style=\"width: 120px;\"/&gt; &lt;a href=\"javascript:refreshCode()\"&gt;&lt;img src=\"$&#123;pageContext.request.contextPath&#125;/checkCodeServlet\" title=\"看不清点击刷新\" id=\"vcode\"/&gt;&lt;/a&gt; &lt;/div&gt; &lt;hr/&gt; &lt;div class=\"form-group\" style=\"text-align: center;\"&gt; &lt;input class=\"btn btn btn-primary\" type=\"submit\" value=\"登录\"&gt; &lt;/div&gt; &lt;/form&gt; &lt;!-- 出错显示的信息框 --&gt; &lt;div class=\"alert alert-warning alert-dismissible\" role=\"alert\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"alert\"&gt; &lt;span&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;strong&gt;$&#123;login_msg&#125;&lt;/strong&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; LoginServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(\"/loginServlet\")public class LoginServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 req.setCharacterEncoding(\"utf-8\"); //传递过来的验证码 String verifycode = req.getParameter(\"verifycode\"); HttpSession session = req.getSession(); //session里面的验证码 String checkcode_server = (String) session.getAttribute(\"CHECKCODE_SERVER\"); session.removeAttribute(\"CHECKCODE_SERVER\"); //比对验证码 if (!checkcode_server.equalsIgnoreCase(verifycode)) &#123; req.setAttribute(\"login_msg\", \"验证码错误\"); req.getRequestDispatcher(\"/login.jsp\").forward(req, resp); return; &#125; Map&lt;String, String[]&gt; parameterMap = req.getParameterMap(); User user = new User(); try &#123; BeanUtils.populate(user, parameterMap); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; UserService userService = new UserServiceImpl(); User loginUser = userService.login(user); if(loginUser != null)&#123; session.setAttribute(\"user\",loginUser); resp.sendRedirect(req.getContextPath()+\"/index.jsp\"); &#125;else &#123; req.setAttribute(\"login_msg\", \"登录失败\"); req.getRequestDispatcher(\"/login.jsp\").forward(req, resp); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; CheckCodeServlet12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package cn.guizimo.little.web.servlet;import java.awt.Color;import java.awt.Font;import java.awt.Graphics;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 验证码 */@WebServlet(\"/checkCodeServlet\")public class CheckCodeServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException &#123; //服务器通知浏览器不要缓存 response.setHeader(\"pragma\",\"no-cache\"); response.setHeader(\"cache-control\",\"no-cache\"); response.setHeader(\"expires\",\"0\"); //在内存中创建一个长80，宽30的图片，默认黑色背景 //参数一：长 //参数二：宽 //参数三：颜色 int width = 80; int height = 30; BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); //获取画笔 Graphics g = image.getGraphics(); //设置画笔颜色为灰色 g.setColor(Color.GRAY); //填充图片 g.fillRect(0,0, width,height); //产生4个随机验证码，12Ey String checkCode = getCheckCode(); //将验证码放入HttpSession中 request.getSession().setAttribute(\"CHECKCODE_SERVER\",checkCode); //设置画笔颜色为黄色 g.setColor(Color.YELLOW); //设置字体的小大 g.setFont(new Font(\"黑体\",Font.BOLD,24)); //向图片上写入验证码 g.drawString(checkCode,15,25); //将内存中的图片输出到浏览器 //参数一：图片对象 //参数二：图片的格式，如PNG,JPG,GIF //参数三：图片输出到哪里去 ImageIO.write(image,\"PNG\",response.getOutputStream()); &#125; /** * 产生4位随机字符串 */ private String getCheckCode() &#123; String base = \"0123456789ABCDEFGabcdefg\"; int size = base.length(); Random r = new Random(); StringBuffer sb = new StringBuffer(); for(int i=1;i&lt;=4;i++)&#123; //产生0到size-1的随机值 int index = r.nextInt(size); //在base字符串中获取下标为index的字符 char c = base.charAt(index); //将c放入到StringBuffer中去 sb.append(c); &#125; return sb.toString(); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doGet(request,response); &#125;&#125; 测试 添加人员思路添加操作就是把jsp提交的表单的数据向数据库里面存储，过程为jsp-&gt;servlet-&gt;service-&gt;dao add.jsp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/28 Time: 下午8:55 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!-- HTML5文档--&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;添加用户&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;center&gt;&lt;h3&gt;添加联系人页面&lt;/h3&gt;&lt;/center&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/addUserServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" placeholder=\"请输入姓名\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" checked=\"checked\"/&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\"/&gt;女 &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"age\" name=\"age\" placeholder=\"请输入年龄\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"address\"&gt;籍贯：&lt;/label&gt; &lt;select name=\"address\" class=\"form-control\" id=\"jiguan\"&gt; &lt;option value=\"广东\"&gt;广东&lt;/option&gt; &lt;option value=\"广西\"&gt;广西&lt;/option&gt; &lt;option value=\"湖南\"&gt;湖南&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"qq\"&gt;QQ：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" name=\"qq\" placeholder=\"请输入QQ号码\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"email\"&gt;Email：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" name=\"email\" placeholder=\"请输入邮箱地址\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"text-align: center\"&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" value=\"提交\" /&gt; &lt;input class=\"btn btn-default\" type=\"reset\" value=\"重置\" /&gt; &lt;input class=\"btn btn-default\" type=\"button\" value=\"返回\" /&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; AddUserServlet12345678910111213141516171819202122232425262728293031323334353637383940package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(\"/addUserServlet\")public class AddUserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; req.setCharacterEncoding(\"utf-8\"); Map&lt;String, String[]&gt; parameterMap = req.getParameterMap(); User user = new User(); try &#123; BeanUtils.populate(user,parameterMap); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; UserService userService = new UserServiceImpl(); userService.addUser(user); resp.sendRedirect(req.getContextPath()+\"/userListServlet\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 修改思路首先我们需要在打开jsp页面的时候就查询到这样的一条记录，通过这一条记录的id作为表单的隐藏域，在servlet里面将数据进行保存即可 update.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/29 Time: 上午10:44 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;title&gt;修改用户&lt;/title&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\" style=\"width: 400px;\"&gt; &lt;h3 style=\"text-align: center;\"&gt;修改联系人&lt;/h3&gt; &lt;form action=\"$&#123;pageContext.request.contextPath&#125;/updateUserServlet\" method=\"post\"&gt; &lt;!-- 隐藏域 提交id--&gt; &lt;input type=\"hidden\" name=\"id\" value=\"$&#123;user.id&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"name\"&gt;姓名：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"name\" name=\"name\" value=\"$&#123;user.name&#125;\" readonly=\"readonly\" placeholder=\"请输入姓名\" /&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;性别：&lt;/label&gt; &lt;c:if test=\"$&#123;user.gender == '男'&#125;\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" checked /&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\" /&gt;女 &lt;/c:if&gt; &lt;c:if test=\"$&#123;user.gender == '女'&#125;\"&gt; &lt;input type=\"radio\" name=\"gender\" value=\"男\" /&gt;男 &lt;input type=\"radio\" name=\"gender\" value=\"女\" checked /&gt;女 &lt;/c:if&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"age\"&gt;年龄：&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" value=\"$&#123;user.age&#125;\" id=\"age\" name=\"age\" placeholder=\"请输入年龄\" /&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"address\"&gt;籍贯：&lt;/label&gt; &lt;select name=\"address\" id=\"address\" class=\"form-control\" &gt; &lt;c:if test=\"$&#123;user.address == '陕西'&#125;\"&gt; &lt;option value=\"陕西\" selected&gt;陕西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;user.address == '北京'&#125;\"&gt; &lt;option value=\"陕西\" &gt;陕西&lt;/option&gt; &lt;option value=\"北京\" selected&gt;北京&lt;/option&gt; &lt;option value=\"上海\"&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;user.address == '上海'&#125;\"&gt; &lt;option value=\"陕西\" &gt;陕西&lt;/option&gt; &lt;option value=\"北京\"&gt;北京&lt;/option&gt; &lt;option value=\"上海\" selected&gt;上海&lt;/option&gt; &lt;/c:if&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"qq\"&gt;QQ：&lt;/label&gt; &lt;input type=\"text\" id=\"qq\" class=\"form-control\" value=\"$&#123;user.qq&#125;\" name=\"qq\" placeholder=\"请输入QQ号码\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"email\"&gt;Email：&lt;/label&gt; &lt;input type=\"text\" id=\"email\" class=\"form-control\" value=\"$&#123;user.email&#125;\" name=\"email\" placeholder=\"请输入邮箱地址\"/&gt; &lt;/div&gt; &lt;div class=\"form-group\" style=\"text-align: center\"&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" value=\"提交\" /&gt; &lt;input class=\"btn btn-default\" type=\"reset\" value=\"重置\" /&gt; &lt;a class=\"btn btn-default\" href=\"$&#123;pageContext.request.contextPath&#125;/userListServlet\"&gt;返回&lt;/a&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; FindUserServlet12345678910111213141516171819202122232425262728293031323334package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/findUserServlet\")public class FindUserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取id String id = req.getParameter(\"id\"); //2.调用Service查询 UserService service = new UserServiceImpl(); User user = service.findUserById(id); //3.将user存入request req.setAttribute(\"user\",user); //4.转发到update.jsp req.getRequestDispatcher(\"/update.jsp\").forward(req,resp); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; UpdateUserServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import org.apache.commons.beanutils.BeanUtils;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.lang.reflect.InvocationTargetException;import java.util.Map;@WebServlet(\"/updateUserServlet\")public class UpdateUserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置编码 req.setCharacterEncoding(\"utf-8\"); //2.获取map Map&lt;String, String[]&gt; map = req.getParameterMap(); //3.封装对象 User user = new User(); try &#123; BeanUtils.populate(user,map); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; //4.调用Service修改 UserService service = new UserServiceImpl(); service.updateUser(user); //5.跳转到查询所有Servlet resp.sendRedirect(req.getContextPath()+\"/userListServlet\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 删除思路通过获取到对应的id即可到servlet中处理，操作数据库删除，在进行删除的时候可出现提示框 DelUserServlet12345678910111213141516171819202122232425262728293031package cn.guizimo.little.web.servlet;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/delUserServlet\")public class DelUserServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取id String id = req.getParameter(\"id\"); //2.调用service删除 UserService service = new UserServiceImpl(); service.deleteUser(id); //3.跳转到查询所有Servlet resp.sendRedirect(req.getContextPath()+\"/userListServlet\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 删除选择的多个思路和删除差不多，最主要是获取id的集合 DelSelectedServlet12345678910111213141516171819202122232425262728293031package cn.guizimo.little.web.servlet;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@WebServlet(\"/delSelectedServlet\")public class DelSelectedServlet extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.获取所有id String[] ids = req.getParameterValues(\"uid\"); //2.调用service删除 UserService service = new UserServiceImpl(); service.delSelectedUser(ids); //3.跳转查询所有Servlet resp.sendRedirect(req.getContextPath()+\"/userListServlet\"); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试 分页思路在jsp中获取查询的总条数，每页显示的条数，当前的页码，将之传递给服务器，操作数据库进行查询 list.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/28 Time: 下午2:15 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;!DOCTYPE html&gt;&lt;!-- 网页使用的语言 --&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;!-- 指定字符集 --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;!-- 使用Edge最新的浏览器的渲染方式 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;!-- viewport视口：网页可以根据设置的宽度自动进行适配，在浏览器的内部虚拟一个容器，容器的宽度与设备的宽度相同。 width: 默认宽度与设备的宽度相同 initial-scale: 初始的缩放比，为1:1 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt; &lt;title&gt;用户信息管理系统&lt;/title&gt; &lt;!-- 1. 导入CSS的全局样式 --&gt; &lt;link href=\"css/bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- 2. jQuery导入，建议使用1.9以上的版本 --&gt; &lt;script src=\"js/jquery-2.1.0.min.js\"&gt;&lt;/script&gt; &lt;!-- 3. 导入bootstrap的js文件 --&gt; &lt;script src=\"js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; td, th &#123; text-align: center; &#125; &lt;/style&gt; &lt;script&gt; function deleteUser(id) &#123; //用户安全提示 if (confirm(\"您确定要删除吗？\")) &#123; //访问路径 location.href = \"$&#123;pageContext.request.contextPath&#125;/delUserServlet?id=\" + id; &#125; &#125; window.onload = function () &#123; //给删除选中按钮添加单击事件 document.getElementById(\"delSelected\").onclick = function () &#123; if (confirm(\"您确定要删除选中条目吗？\")) &#123; var flag = false; //判断是否有选中条目 var cbs = document.getElementsByName(\"uid\"); for (var i = 0; i &lt; cbs.length; i++) &#123; if (cbs[i].checked) &#123; //有一个条目选中了 flag = true; break; &#125; &#125; if (flag) &#123;//有条目被选中 //表单提交 document.getElementById(\"form\").submit(); &#125; &#125; &#125; //1.获取第一个cb document.getElementById(\"firstCb\").onclick = function () &#123; //2.获取下边列表中所有的cb var cbs = document.getElementsByName(\"uid\"); //3.遍历 for (var i = 0; i &lt; cbs.length; i++) &#123; //4.设置这些cbs[i]的checked状态 = firstCb.checked cbs[i].checked = this.checked; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container\"&gt; &lt;h3 style=\"text-align: center\"&gt;用户信息列表&lt;/h3&gt; &lt;div style=\"float: left;\"&gt; &lt;form class=\"form-inline\" action=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName2\"&gt;姓名&lt;/label&gt; &lt;input type=\"text\" name=\"name\" value=\"$&#123;condition.name[0]&#125;\" class=\"form-control\" id=\"exampleInputName2\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName3\"&gt;籍贯&lt;/label&gt; &lt;input type=\"text\" name=\"address\" value=\"$&#123;condition.address[0]&#125;\" class=\"form-control\" id=\"exampleInputName3\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail2\"&gt;邮箱&lt;/label&gt; &lt;input type=\"text\" name=\"email\" value=\"$&#123;condition.email[0]&#125;\" class=\"form-control\" id=\"exampleInputEmail2\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;div style=\"float: right;margin: 5px;\"&gt; &lt;a class=\"btn btn-primary\" href=\"$&#123;pageContext.request.contextPath&#125;/add.jsp\"&gt;添加联系人&lt;/a&gt; &lt;a class=\"btn btn-primary\" href=\"javascript:void(0);\" id=\"delSelected\"&gt;删除选中&lt;/a&gt; &lt;/div&gt; &lt;form id=\"form\" action=\"$&#123;pageContext.request.contextPath&#125;/delSelectedServlet\" method=\"post\"&gt; &lt;table border=\"1\" class=\"table table-bordered table-hover\"&gt; &lt;tr class=\"success\"&gt; &lt;th&gt;&lt;input type=\"checkbox\" id=\"firstCb\"&gt;&lt;/th&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;籍贯&lt;/th&gt; &lt;th&gt;QQ&lt;/th&gt; &lt;th&gt;邮箱&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;c:forEach items=\"$&#123;pb.list&#125;\" var=\"user\" varStatus=\"s\"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" name=\"uid\" value=\"$&#123;user.id&#125;\"&gt;&lt;/td&gt; &lt;td&gt;$&#123;s.count&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.gender&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.age&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.qq&#125;&lt;/td&gt; &lt;td&gt;$&#123;user.email&#125;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-default btn-sm\" href=\"$&#123;pageContext.request.contextPath&#125;/findUserServlet?id=$&#123;user.id&#125;\"&gt;修改&lt;/a&gt;&amp;nbsp; &lt;a class=\"btn btn-default btn-sm\" href=\"javascript:deleteUser($&#123;user.id&#125;);\"&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; &lt;/form&gt; &lt;div&gt; &lt;nav aria-label=\"Page navigation\"&gt; &lt;ul class=\"pagination\"&gt; &lt;c:if test=\"$&#123;pb.currentPage == 1&#125;\"&gt; &lt;li class=\"disabled\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=1&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;pb.currentPage != 1&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage - 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\" aria-label=\"Previous\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;laquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:forEach begin=\"1\" end=\"$&#123;pb.totalPage&#125;\" var=\"i\"&gt; &lt;c:if test=\"$&#123;pb.currentPage == i&#125;\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\"&gt;$&#123;i&#125;&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;pb.currentPage != i&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;i&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\"&gt;$&#123;i&#125;&lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;/c:forEach&gt; &lt;c:if test=\"$&#123;pb.currentPage == pb.totalPage&#125;\"&gt; &lt;li class=\"disabled\"&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.totalPage&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;c:if test=\"$&#123;pb.currentPage != pb.totalPage&#125;\"&gt; &lt;li&gt; &lt;a href=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet?currentPage=$&#123;pb.currentPage + 1&#125;&amp;rows=5&amp;name=$&#123;condition.name[0]&#125;&amp;address=$&#123;condition.address[0]&#125;&amp;email=$&#123;condition.email[0]&#125;\" aria-label=\"Next\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;raquo;&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;/c:if&gt; &lt;span style=\"font-size: 25px;margin-left: 5px;\"&gt; 共$&#123;pb.totalCount&#125;条记录，共$&#123;pb.totalPage&#125;页 &lt;/span&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; FindUserByPageServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.guizimo.little.web.servlet;import cn.guizimo.little.domain.PageBean;import cn.guizimo.little.domain.User;import cn.guizimo.little.service.UserService;import cn.guizimo.little.service.impl.UserServiceImpl;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.Map;@WebServlet(\"/findUserByPageServlet\")public class FindUserByPageServlet extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; request.setCharacterEncoding(\"utf-8\"); //1.获取参数 String currentPage = request.getParameter(\"currentPage\");//当前页码 String rows = request.getParameter(\"rows\");//每页显示条数 if(currentPage == null || \"\".equals(currentPage))&#123; currentPage = \"1\"; &#125; if(rows == null || \"\".equals(rows))&#123; rows = \"5\"; &#125; //获取条件查询参数 Map&lt;String, String[]&gt; condition = request.getParameterMap(); //2.调用service查询 UserService service = new UserServiceImpl(); PageBean&lt;User&gt; pb = service.findUserByPage(currentPage,rows,condition); System.out.println(pb); //3.将PageBean存入request request.setAttribute(\"pb\",pb); request.setAttribute(\"condition\",condition);//将查询条件存入request //4.转发到list.jsp request.getRequestDispatcher(\"/list.jsp\").forward(request,response); &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 测试 条件查询思路主要是在sql语句的编写 jsp12345678910111213141516171819&lt;div style=\"float: left;\"&gt; &lt;form class=\"form-inline\" action=\"$&#123;pageContext.request.contextPath&#125;/findUserByPageServlet\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName2\"&gt;姓名&lt;/label&gt; &lt;input type=\"text\" name=\"name\" value=\"$&#123;condition.name[0]&#125;\" class=\"form-control\" id=\"exampleInputName2\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputName3\"&gt;籍贯&lt;/label&gt; &lt;input type=\"text\" name=\"address\" value=\"$&#123;condition.address[0]&#125;\" class=\"form-control\" id=\"exampleInputName3\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail2\"&gt;邮箱&lt;/label&gt; &lt;input type=\"text\" name=\"email\" value=\"$&#123;condition.email[0]&#125;\" class=\"form-control\" id=\"exampleInputEmail2\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;查询&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; dao层方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Override public int findTotalCount(Map&lt;String, String[]&gt; condition) &#123; //1.定义模板初始化sql String sql = \"select count(*) from user where 1 = 1 \"; StringBuilder sb = new StringBuilder(sql); //2.遍历map Set&lt;String&gt; keySet = condition.keySet(); //定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) &#123; //排除分页条件参数 if(\"currentPage\".equals(key) || \"rows\".equals(key))&#123; continue; &#125; //获取value String value = condition.get(key)[0]; //判断value是否有值 if(value != null &amp;&amp; !\"\".equals(value))&#123; //有值 sb.append(\" and \"+key+\" like ? \"); params.add(\"%\"+value+\"%\");//？条件的值 &#125; &#125; System.out.println(sb.toString()); System.out.println(params); return template.queryForObject(sb.toString(),Integer.class,params.toArray()); &#125; @Override public List&lt;User&gt; findByPage(int start, int rows, Map&lt;String, String[]&gt; condition) &#123; String sql = \"select * from user where 1 = 1 \"; StringBuilder sb = new StringBuilder(sql); //2.遍历map Set&lt;String&gt; keySet = condition.keySet(); //定义参数的集合 List&lt;Object&gt; params = new ArrayList&lt;Object&gt;(); for (String key : keySet) &#123; //排除分页条件参数 if(\"currentPage\".equals(key) || \"rows\".equals(key))&#123; continue; &#125; //获取value String value = condition.get(key)[0]; //判断value是否有值 if(value != null &amp;&amp; !\"\".equals(value))&#123; //有值 sb.append(\" and \"+key+\" like ? \"); params.add(\"%\"+value+\"%\");//？条件的值 &#125; &#125; //添加分页查询 sb.append(\" limit ?,? \"); //添加分页查询参数值 params.add(start); params.add(rows); sql = sb.toString(); System.out.println(sql); System.out.println(params); return template.query(sql,new BeanPropertyRowMapper&lt;User&gt;(User.class),params.toArray()); &#125; 测试 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"JSP--EL表达式","slug":"JSP--EL表达式","date":"2020-06-28T05:10:48.000Z","updated":"2020-07-29T16:01:34.503Z","comments":true,"path":"2020/06/28/JSP--EL表达式/","link":"","permalink":"https://tangleia.github.io/2020/06/28/JSP--EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"JSP–EL表达式","text":"JSP–EL表达式 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念Expression Language 表达式语言 JSP表达式语言（EL）使得访问存储在JavaBean中的数据变得非常简单。JSP EL既可以用来创建算术表达式也可以用来创建逻辑表达式。在JSP EL表达式内可以使用整型数，浮点数，字符串，常量true、false，还有null 作用替换和简化jsp页面中java代码的编写 语法1$&#123;表达式&#125; 注意 jsp默认支持el表达式的。如果要忽略el表达式 设置jsp中page指令中 1isELIgnored&#x3D;&quot;true&quot; 忽略当前jsp页面中所有的el表达式 忽略当前这个el表达式 1\\$&#123;表达式&#125; 使用运算 运算符： 算数运算符： + - * /(div) %(mod) 比较运算符： &gt; &lt; &gt;= &lt;= == != 逻辑运算符： &amp;&amp;(and) ||(or) !(not) 空运算符： empty 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0 ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度&gt;0 获取值 el表达式只能从域对象中获取值 语法： ${域名称.键名}：从指定域中获取指定键的值 域名称： pageScope –&gt; pageContext requestScope –&gt; request sessionScope –&gt; session applicationScope –&gt; application（ServletContext） 举例：在request域中存储了name=张三 获取：${requestScope.name} ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。 获取对象、List集合、Map集合的值 对象：${域名称.键名.属性名} 本质上会去调用对象的getter方法 List集合：${域名称.键名[索引]} Map集合： ${域名称.键名.key名称} ${域名称.键名[“key名称”]} 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"JSP--JSTL（JSP标准标签库）","slug":"JSP--JSTL（JSP标准标签库）","date":"2020-06-28T03:57:11.000Z","updated":"2020-07-29T16:02:46.985Z","comments":true,"path":"2020/06/28/JSP--JSTL（JSP标准标签库）/","link":"","permalink":"https://tangleia.github.io/2020/06/28/JSP--JSTL%EF%BC%88JSP%E6%A0%87%E5%87%86%E6%A0%87%E7%AD%BE%E5%BA%93%EF%BC%89/","excerpt":"JSP–JSTL（JSP标准标签库）","text":"JSP–JSTL（JSP标准标签库） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念JavaServer Pages Tag Library JSP标准标签库 是由Apache组织提供的开源的免费的jsp标签 作用用于简化和替换jsp页面上的java代码 安装菜鸟教程文档地址 https://www.runoob.com/jsp/jsp-jstl.html 下载地址 官方下载地址：http://archive.apache.org/dist/jakarta/taglibs/standard/binaries/ 菜鸟教程下载地址：jakarta-taglibs-standard-1.1.2.zip 下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文件：standard.jar 和 jstl.jar 文件拷贝到 /WEB-INF/lib/ 下。 将 tld 下的需要引入的 tld 文件复制到 WEB-INF 目录下。 接下来我们在 web.xml 文件中添加以下配置： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt; &lt;jsp-config&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/fmt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/fmt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/fmt-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/fmt-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/core&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/c.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/core-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/c-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/sql&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/sql.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/sql-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/sql-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/x&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/x.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;taglib&gt; &lt;taglib-uri&gt;http://java.sun.com/jsp/jstl/x-rt&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/x-rt.tld&lt;/taglib-location&gt; &lt;/taglib&gt; &lt;/jsp-config&gt;&lt;/web-app&gt; 使用步骤 导入jstl相关jar包 引入标签库：taglib指令： 1&lt;%@ taglib %&gt; 使用标签 常用的JSTL标签if–相当于java代码的if语句 属性： test 必须属性，接受boolean表达式 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容 一般情况下，test属性值会结合el表达式一起使用 注意： c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签 choose–相当于java代码的switch语句 使用choose标签声明 相当于switch声明 使用when标签做判断 相当于case 使用otherwise标签做其他情况的声明 相当于default foreach–相当于java代码的for语句感谢 菜鸟教程 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--MVC开发模式","slug":"Java--MVC开发模式","date":"2020-06-28T03:23:16.000Z","updated":"2020-07-29T15:26:04.644Z","comments":true,"path":"2020/06/28/Java--MVC开发模式/","link":"","permalink":"https://tangleia.github.io/2020/06/28/Java--MVC%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/","excerpt":"Java–MVC开发模式","text":"Java–MVC开发模式 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ Jsp演变历史 早期只有servlet，只能使用response输出标签数据，非常麻烦 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性 MVC开发模式示意图 再来一张 M：Model–模型–JavaBeanModel层：Model指模型部分，一般在应用中Model层包括业务处理层Service和数据访问层Dao。数据访问层主要是对数据库的一些操作的封装。业务处理层主要是用作将从Controller层获取的数据和数据库的数据进行桥接。除此以外，对复杂业务逻辑进行处理,比如事务处理 完成具体的业务操作，如：查询数据库，封装对象 V：View–视图–JSPView层：View指视图部分，这一部分的内容是展示给用户实际进行交互的，通常使用JSP和HTML进行构建 展示数据 C：Controller–控制器–ServletController层：Controller指控制部分，一般是对View层提交的请求为其设置对应的Servlet进行特定功能的处理，这里的进行特定功能的处理一般是编写在Model中的业务处理层中的。Controller一般只是在Web应用中充当一个中介者的作用 获取用户的输入 调用模型 将数据交给视图进行展示 优缺点 优点： 耦合性低，方便维护，可以利于分工协作 重用性高 缺点： 使得项目架构变得复杂，对开发人员要求高 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"十大排序算法的分析","slug":"十大排序算法的分析","date":"2020-06-27T07:49:25.000Z","updated":"2020-07-29T15:09:05.885Z","comments":true,"path":"2020/06/27/十大排序算法的分析/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90/","excerpt":"十大排序算法的分析","text":"十大排序算法的分析 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 十大算法比对图（来自尚硅谷） 相关术语解释稳定如果a原本在b前面，而a=b，排序之后a仍然在b的前面； 不稳定如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面； 内排序所有排序操作都在内存中完成； 外排序由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行； 时间复杂度 一个算法执行所耗费的时间。 空间复杂度运行完一个程序所需内存的大小。 n数据规模 k“桶”的个数 In-place不占用额外内存 Out-place占用额外内存 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"基数排序（Java）","slug":"基数排序（Java）","date":"2020-06-27T07:36:30.000Z","updated":"2020-07-29T15:06:50.844Z","comments":true,"path":"2020/06/27/基数排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"基数排序（Java）","text":"基数排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 基数排序(桶排序)介绍基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法 基数排序(Radix Sort)是桶排序的扩展 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。 基数排序基本思想将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。 特点空间换时间，稳定 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.guizimo.sort;import java.util.Arrays;public class RadixSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;53,45,6,378,15,234,78&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); radixSort(arr); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void radixSort(int arr[]) &#123; //获取最大位数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //计算位数 int maxLength = (max + \"\").length(); int[][] bucket = new int[10][arr.length]; int[] bucketElemtCounts = new int[10]; for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; int digitOfElemt = arr[j] / n % 10; bucket[digitOfElemt][bucketElemtCounts[digitOfElemt]] = arr[j]; bucketElemtCounts[digitOfElemt]++; &#125; int index = 0; for (int k = 0; k &lt; bucketElemtCounts.length; k++) &#123; if (bucketElemtCounts[k] != 0) &#123; for (int l = 0; l &lt; bucketElemtCounts[k]; l++) &#123; arr[index++] = bucket[k][l]; &#125; &#125; bucketElemtCounts[k] = 0; &#125; System.out.println(\"第\"+(i+1)+\"轮排序\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 测试速度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package cn.guizimo.sort;import java.util.Arrays;public class RadixSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 80000); &#125; long date1 = System.currentTimeMillis(); radixSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"位移式希尔排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void radixSort(int arr[]) &#123; //获取最大位数 int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; //计算位数 int maxLength = (max + \"\").length(); int[][] bucket = new int[10][arr.length]; int[] bucketElemtCounts = new int[10]; for (int i = 0, n = 1; i &lt; maxLength; i++, n *= 10) &#123; for (int j = 0; j &lt; arr.length; j++) &#123; int digitOfElemt = arr[j] / n % 10; bucket[digitOfElemt][bucketElemtCounts[digitOfElemt]] = arr[j]; bucketElemtCounts[digitOfElemt]++; &#125; int index = 0; for (int k = 0; k &lt; bucketElemtCounts.length; k++) &#123; if (bucketElemtCounts[k] != 0) &#123; for (int l = 0; l &lt; bucketElemtCounts[k]; l++) &#123; arr[index++] = bucket[k][l]; &#125; &#125; bucketElemtCounts[k] = 0; &#125; &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"归并排序（Java）","slug":"归并排序（Java）","date":"2020-06-27T06:41:48.000Z","updated":"2020-07-29T15:06:41.161Z","comments":true,"path":"2020/06/27/归并排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"归并排序（Java）","text":"归并排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 归并排序介绍归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package cn.guizimo.sort;import java.util.Arrays;public class MergetSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;; int temp[] = new int[arr.length]; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); mergeSort(arr, 0, arr.length - 1, temp); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; mergeSort(arr, left, mid, temp); mergeSort(arr, mid + 1, right, temp); merge(arr, left, mid, right, temp); &#125; &#125; public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; int j = mid + 1; int t = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; temp[t] = arr[j]; t += 1; j += 1; &#125; &#125; while (i &lt;= mid) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; while (j &lt;= right) &#123; temp[t] = arr[j]; t += 1; j += 1; &#125; t = 0; int tempIndex = left; while (tempIndex &lt;= right) &#123; arr[tempIndex] = temp[t]; t += 1; tempIndex += 1; &#125; &#125;&#125; 测试 速度测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package cn.guizimo.sort;import java.util.Arrays;public class MergetSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; int temp[] = new int[arr.length]; long date1 = System.currentTimeMillis(); mergeSort(arr, 0, arr.length - 1, temp); long date2 = System.currentTimeMillis(); System.out.println(\"归并排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void mergeSort(int[] arr, int left, int right, int[] temp) &#123; if (left &lt; right) &#123; int mid = (left + right) / 2; mergeSort(arr, left, mid, temp); mergeSort(arr, mid + 1, right, temp); merge(arr, left, mid, right, temp); &#125; &#125; public static void merge(int[] arr, int left, int mid, int right, int[] temp) &#123; int i = left; int j = mid + 1; int t = 0; while (i &lt;= mid &amp;&amp; j &lt;= right) &#123; if (arr[i] &lt;= arr[j]) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; else &#123; temp[t] = arr[j]; t += 1; j += 1; &#125; &#125; while (i &lt;= mid) &#123; temp[t] = arr[i]; t += 1; i += 1; &#125; while (j &lt;= right) &#123; temp[t] = arr[j]; t += 1; j += 1; &#125; t = 0; int tempIndex = left; while (tempIndex &lt;= right) &#123; arr[tempIndex] = temp[t]; t += 1; tempIndex += 1; &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"交换排序之快速排序（Java）","slug":"交换排序之快速排序（Java）","date":"2020-06-27T05:39:54.000Z","updated":"2020-07-29T15:07:06.091Z","comments":true,"path":"2020/06/27/交换排序之快速排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"交换排序之快速排序（Java）","text":"交换排序之快速排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 快速排序法介绍快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package cn.guizimo.sort;import java.util.Arrays;public class QuickSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;-9, 78, 0, 23, -587, 71&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); quickSort(arr, 0, arr.length - 1); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void quickSort(int[] arr, int left, int right) &#123; int l = left; int r = right; int temp = 0; int pivot = arr[(left + right) / 2]; while (l &lt; r) &#123; while (arr[l] &lt; pivot) &#123; l += 1; &#125; while (arr[r] &gt; pivot) &#123; r -= 1; &#125; if (l &gt;= r) &#123; break; &#125; temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; if (arr[l] == pivot) &#123; r -= 1; &#125; if (arr[r] == pivot) &#123; l += 1; &#125; &#125; if (l == r) &#123; l += 1; r -= 1; &#125; //向左递归 if (left &lt; r) &#123; quickSort(arr, left, r); &#125; //向右递归 if (right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125;&#125; 测试 测试速度12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package cn.guizimo.sort;import java.util.Arrays;public class QuickSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); quickSort(arr, 0, arr.length - 1); long date2 = System.currentTimeMillis(); System.out.println(\"快速排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void quickSort(int[] arr, int left, int right) &#123; int l = left; int r = right; int temp = 0; int pivot = arr[(left + right) / 2]; while (l &lt; r) &#123; while (arr[l] &lt; pivot) &#123; l += 1; &#125; while (arr[r] &gt; pivot) &#123; r -= 1; &#125; if (l &gt;= r) &#123; break; &#125; temp = arr[l]; arr[l] = arr[r]; arr[r] = temp; if (arr[l] == pivot) &#123; r -= 1; &#125; if (arr[r] == pivot) &#123; l += 1; &#125; &#125; if (l == r) &#123; l += 1; r -= 1; &#125; //向左递归 if (left &lt; r) &#123; quickSort(arr, left, r); &#125; //向右递归 if (right &gt; l) &#123; quickSort(arr, l, right); &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"插入排序之希尔排序（Java）","slug":"插入排序之希尔排序（Java）","date":"2020-06-27T03:45:20.000Z","updated":"2020-07-29T15:02:34.319Z","comments":true,"path":"2020/06/27/插入排序之希尔排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/27/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"插入排序之希尔排序（Java）","text":"插入排序之希尔排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 希尔排序法介绍希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。 希尔排序法基本思想希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止 代码（交换式）12345678910111213141516171819202122232425262728293031323334package cn.guizimo.sort;import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); shellSort(arr); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void shellSort(int[] arr) &#123; int count = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; count++; int temp = 0; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i - gap; j &gt;= 0; j -= gap) &#123; if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; &#125; &#125; &#125; System.out.println(\"第\"+count+\"轮排序\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 测试速度123456789101112131415161718192021222324252627282930313233package cn.guizimo.sort;import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); shellSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"交换式希尔排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void shellSort(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; int temp = 0; for (int i = gap; i &lt; arr.length; i++) &#123; for (int j = i - gap; j &gt;= 0; j -= gap) &#123; if (arr[j] &gt; arr[j + gap]) &#123; temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; &#125; &#125; &#125; &#125; &#125;&#125; 代码（位移式）123456789101112131415161718192021222324252627282930313233343536package cn.guizimo.sort;import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;8, 9, 1, 7, 2, 3, 5, 4, 6, 0&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); shellSort(arr); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void shellSort(int[] arr) &#123; int count = 0; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; count++; for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[i]; if(arr[j]&lt;arr[j-gap])&#123; while (j-gap &gt;= 0 &amp;&amp; temp &lt; arr[j-gap])&#123; arr[j] = arr[j-gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125; System.out.println(\"第\"+count+\"轮排序\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 速度测试12345678910111213141516171819202122232425262728293031323334package cn.guizimo.sort;import java.util.Arrays;public class ShellSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); shellSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"位移式希尔排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void shellSort(int[] arr) &#123; for (int gap = arr.length / 2; gap &gt; 0; gap /= 2) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int j = i; int temp = arr[i]; if(arr[j]&lt;arr[j-gap])&#123; while (j-gap &gt;= 0 &amp;&amp; temp &lt; arr[j-gap])&#123; arr[j] = arr[j-gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125; &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"插入排序之直接插入排序（Java）","slug":"插入排序之直接插入排序（Java）","date":"2020-06-26T15:08:42.000Z","updated":"2020-07-29T15:02:48.632Z","comments":true,"path":"2020/06/26/插入排序之直接插入排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%B9%8B%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"插入排序之直接插入排序（Java）","text":"插入排序之直接插入排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 插入排序法思想插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。 代码12345678910111213141516171819202122232425262728293031package cn.guizimo.sort;import java.util.Arrays;public class InsertSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;12, 28, 3, 109, 50&#125;; System.out.println(\"插入前\"); System.out.println(Arrays.toString(arr)); insertSort(arr); System.out.println(\"插入后\"); System.out.println(Arrays.toString(arr)); &#125; public static void insertSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int insertVal = arr[i]; int insertIndex = i - 1; while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; System.out.println(\"第\" + i + \"轮插入\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 测试速度12345678910111213141516171819202122232425262728293031package cn.guizimo.sort;public class InsertSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); insertSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"冒泡排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void insertSort(int[] arr) &#123; for (int i = 1; i &lt; arr.length; i++) &#123; int insertVal = arr[i]; int insertIndex = i - 1; while (insertIndex &gt;= 0 &amp;&amp; insertVal &lt; arr[insertIndex]) &#123; arr[insertIndex + 1] = arr[insertIndex]; insertIndex--; &#125; if (insertIndex + 1 != i) &#123; arr[insertIndex + 1] = insertVal; &#125; &#125; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"选择排序之简单选择排序（Java）","slug":"选择排序之简单选择排序（Java）","date":"2020-06-26T14:18:15.000Z","updated":"2020-07-29T15:10:23.206Z","comments":true,"path":"2020/06/26/选择排序之简单选择排序（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E4%B9%8B%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%88Java%EF%BC%89/","excerpt":"选择排序之简单选择排序（Java）","text":"选择排序之简单选择排序（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。 代码1234567891011121314151617181920212223242526272829303132package cn.guizimo.sort;import java.util.Arrays;public class SelectSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;102, 34, 98, 6&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); selectSort(arr); &#125; public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; System.out.println(\"第\" + (i + 1) + \"轮后\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 测试速度1234567891011121314151617181920212223242526272829303132333435package cn.guizimo.sort;import java.util.Arrays;public class SelectSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); selectSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"冒泡排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void selectSort(int[] arr) &#123; for (int i = 0; i &lt; arr.length - 1; i++) &#123; int minIndex = i; int min = arr[i]; for (int j = i + 1; j &lt; arr.length; j++) &#123; if (min &gt; arr[j]) &#123; min = arr[j]; minIndex = j; &#125; &#125; if (minIndex != i) &#123; arr[minIndex] = arr[i]; arr[i] = min; &#125; &#125; &#125;&#125; 运行的时间与自身的电脑有关 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"交换排序之冒泡排序（java）","slug":"交换排序之冒泡排序（java）","date":"2020-06-26T13:46:42.000Z","updated":"2020-07-29T15:07:15.374Z","comments":true,"path":"2020/06/26/交换排序之冒泡排序（java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%88java%EF%BC%89/","excerpt":"交换排序之冒泡排序（java）","text":"交换排序之冒泡排序（java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。 代码123456789101112131415161718192021package cn.guizimo.sort;import java.util.Arrays;public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; int temp = 0; for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; System.out.println(\"第\"+(i+1)+\"躺排序后的数组\"); System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 测试 优化减少未曾发生交换的次数 1234567891011121314151617181920212223242526272829303132333435package cn.guizimo.sort;import java.util.Arrays;public class BubbleSort &#123; public static void main(String[] args) &#123; int arr[] = &#123;3, 9, -1, 10, -2&#125;; System.out.println(\"排序前\"); System.out.println(Arrays.toString(arr)); bubbledSort(arr); System.out.println(\"排序后\"); System.out.println(Arrays.toString(arr)); &#125; public static void bubbledSort(int[] arr)&#123; int temp = 0; boolean flag = false; //标识，是否发生交换 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; if(!flag)&#123; //没有发生交换 break; &#125;else &#123; //进行下次交换 flag = false; &#125; &#125; &#125;&#125; 测试 测试速度1234567891011121314151617181920212223242526272829303132333435363738394041package cn.guizimo.sort;import java.text.SimpleDateFormat;import java.util.Arrays;import java.util.Date;public class BubbleSort &#123; public static void main(String[] args) &#123; int max = 80000; int[] arr = new int[max]; for (int i = 0; i &lt; max; i++) &#123; arr[i] = (int)(Math.random() * 8000000); &#125; long date1 = System.currentTimeMillis(); bubbledSort(arr); long date2 = System.currentTimeMillis(); System.out.println(\"冒泡排序\"+max+\"数组的时间为：\"+(date2-date1)); &#125; public static void bubbledSort(int[] arr)&#123; int temp = 0; boolean flag = false; //标识，是否发生交换 for (int i = 0; i &lt; arr.length - 1; i++) &#123; for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; flag = true; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; if(!flag)&#123; //没有发生交换 break; &#125;else &#123; //进行下次交换 flag = false; &#125; &#125; &#125;&#125; 运行的时间与自身的电脑有关 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"算法的时间复杂度和空间复杂度","slug":"算法的时间复杂度和空间复杂度","date":"2020-06-26T12:29:29.000Z","updated":"2020-07-29T15:09:57.061Z","comments":true,"path":"2020/06/26/算法的时间复杂度和空间复杂度/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","excerpt":"算法的时间复杂度和空间复杂度","text":"算法的时间复杂度和空间复杂度 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 算法的时间复杂度时间频度一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。 时间复杂度一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) ) 为算法的渐进时间复杂度，简称时间复杂度。 计算时间复杂度的方法 用常数1代替运行时间中的所有加法常数 修改后的运行次数函数中，只保留最高阶项 去除最高阶项的系数 常见的时间复杂度常数阶O(1)无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1) 1234int i = 1;int j = 2;i++;j++; 上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。 对数阶O(log2n)1234int i = 1;while(i&lt;n)&#123; i = i * 2;&#125; 在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n) 。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) 线性阶O(n)123for(i = 1; i &lt;= n; i++)&#123; j = i;&#125; 这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度 线性对数阶O(nlog2n)123456for(m =1;m&lt;n;m++)&#123; i = 1; while(i&lt;n)&#123; i = i * 2; &#125;&#125; 线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN) 平方阶O(n^2)12345for(j=1;j&lt;n;j++)&#123; for(i=1;i&lt;n;i++)&#123; m = j+i; &#125;&#125; 平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(nn)，即 O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(mn) 立方阶O(n^3)三层循环 k次方阶O(n^k)k层循环 指数阶O(2^n)常见的算法时间复杂度大小由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低从图中可见， 建议尽可能避免使用指数阶的算法 平均时间复杂度和最坏时间复杂度 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。 最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。 平均时间复杂度和最坏时间复杂度是否一致，和算法有关 算法的空间复杂度 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况 在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间. 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Session--验证码案例（Java）","slug":"Session--验证码案例（Java）","date":"2020-06-26T10:35:13.000Z","updated":"2020-07-29T16:06:07.163Z","comments":true,"path":"2020/06/26/Session--验证码案例（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/Session--%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A1%88%E4%BE%8B%EF%BC%88Java%EF%BC%89/","excerpt":"Session–验证码案例（Java）","text":"Session–验证码案例（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 案例用户输入用户名，密码以及验证码。 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误 如果验证码输入有误，跳转登录页面，提示：验证码错误 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您 思路在生成验证码的时候将它的值存入到session中，在比对的时候再取出来进行对比 代码index.jsp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/26 Time: 下午12:48 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;login&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; document.getElementById(\"img\").onclick = function()&#123; this.src=\"/login_time_war_exploded/checkCode?time=\"+new Date().getTime(); &#125; &#125; &lt;/script&gt; &lt;style&gt; div&#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/login_time_war_exploded/login\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;验证码&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"checkCode\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;img id=\"img\" src=\"/login_time_war_exploded/checkCode\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt;&lt;div&gt;&lt;%=request.getAttribute(\"cc_error\") == null ? \"\" : request.getAttribute(\"cc_error\")%&gt;&lt;/div&gt;&lt;div&gt;&lt;%=request.getAttribute(\"login_error\") == null ? \"\" : request.getAttribute(\"login_error\") %&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; success.jsp12345678910111213141516&lt;%-- Created by IntelliJ IDEA. User: tanglei Date: 2020/6/26 Time: 下午6:27 To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&lt;%=request.getSession().getAttribute(\"user\")%&gt;,欢迎您&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 验证码checkCode.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package cn.guizimo.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(\"/checkCode\")public class CheckCode extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int width = 100; int height = 50; //创建图片对象 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR); //美化 Graphics g = image.getGraphics(); //背景 g.setColor(Color.PINK); g.fillRect(0, 0, width, height); //边框 g.setColor(Color.BLUE); g.drawRect(0, 0, width - 1, height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; Random ran = new Random(); StringBuilder sb = new StringBuilder(); for (int i = 1; i &lt;= 4; i++) &#123; int index = ran.nextInt(str.length()); char ch = str.charAt(index); sb.append(ch); g.drawString(ch+\"\",width/5*i,height/2); &#125; String checkCode_session = sb.toString(); //将验证码存入session req.getSession().setAttribute(\"checkCode_session\",checkCode_session); //干扰线 g.setColor(Color.GREEN); for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2= ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); &#125; //输出图片到浏览器 ImageIO.write(image, \"jpg\", resp.getOutputStream()); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; login.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.guizimo.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;@WebServlet(\"/login\")public class Login extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置request编码 req.setCharacterEncoding(\"utf-8\"); //2.获取参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); String checkCode = req.getParameter(\"checkCode\"); //3.先获取生成的验证码 HttpSession session = req.getSession(); String checkCode_session = (String) session.getAttribute(\"checkCode_session\"); //删除session中存储的验证码 //session.removeAttribute(\"checkCode_session\"); //3.先判断验证码是否正确 if(checkCode_session!= null &amp;&amp; checkCode_session.equalsIgnoreCase(checkCode))&#123; //忽略大小写比较 //验证码正确 //判断用户名和密码是否一致 if(\"zhangsan\".equals(username) &amp;&amp; \"123\".equals(password))&#123;//需要调用UserDao查询数据库 //登录成功 //存储信息，用户信息 session.setAttribute(\"user\",username); //重定向到success.jsp resp.sendRedirect(req.getContextPath()+\"/success.jsp\"); &#125;else&#123; //登录失败 //存储提示信息到request req.setAttribute(\"login_error\",\"用户名或密码错误\"); //转发到登录页面 req.getRequestDispatcher(\"/login.jsp\").forward(req,resp); &#125; &#125;else&#123; //验证码不一致 //存储提示信息到request req.setAttribute(\"cc_error\",\"验证码错误\"); //转发到登录页面 req.getRequestDispatcher(\"/login.jsp\").forward(req,resp); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试登录界面 验证码错误 用户名密码错误 登录成功 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"服务端会话技术--Session","slug":"服务端会话技术--Session","date":"2020-06-26T04:40:34.000Z","updated":"2020-07-29T15:06:29.702Z","comments":true,"path":"2020/06/26/服务端会话技术--Session/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF--Session/","excerpt":"服务端会话技术–Session","text":"服务端会话技术–Session 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession 快速入门 获取HttpSession对象： 1HttpSession session = request.getSession(); 使用HttpSession对象： 123Object getAttribute(String name) void setAttribute(String name, Object value)void removeAttribute(String name) 原理Session的实现是依赖于Cookie的。 细节 当客户端关闭后，服务器不关闭，两次获取Session是否为同一个？ 默认情况下。不是。 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。 123Cookie c = new Cookie(\"JSESSIONID\",session.getId()); c.setMaxAge(60*60); response.addCookie(c); 客户端不关闭，服务器关闭后，两次获取的Session是同一个吗？ 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作 Session的钝化： 在服务器正常关闭之前，将Session对象系列化到硬盘上 Session的活化： 在服务器启动后，将Session文件转化为内存中的Session对象即可。 Session什么时候被销毁？ 服务器关闭 Session对象调用invalidate() 。 Session默认失效时间 30分钟 选择性配置修改 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; Session的特点 session用于存储一次会话的多次请求的数据，存在服务器端 session可以存储任意类型，任意大小的数据 session与Cookie的区别： session存储数据在服务器端，Cookie在客户端 session没有数据大小限制，Cookie有 session数据安全，Cookie相对于不安全 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--JSP简介","slug":"Java--JSP简介","date":"2020-06-26T04:29:25.000Z","updated":"2020-07-29T15:25:53.478Z","comments":true,"path":"2020/06/26/Java--JSP简介/","link":"","permalink":"https://tangleia.github.io/2020/06/26/Java--JSP%E7%AE%80%E4%BB%8B/","excerpt":"Java–JSP简介","text":"Java–JSP简介 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明JSP（全称JavaServer Pages）是由Su 公司主导创建的一种动态网页技术标准。JSP部署于网络服务器上，可以响应客户端发送的请求，并根据请求内容动态地生成HTML、XML或其他格式文档的Web网页，然后返回给请求者。JSP技术以Java语言作为脚本语言，为用户的HTTP请求提供服务，并能与服务器上的其它Java程序共同处理复杂的业务需求。 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码 原理JSP本质上就是一个Servlet JSP的脚本JSP定义Java代码的方式 &lt;% 代码 %&gt;：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。 &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员位置。 &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。 JSP的内置对象 在jsp页面中不需要获取和创建，可以直接使用的对象 out：JSPWriter，用来写入响应流的数据 page：servlet自身 pageContext：一个PageContext实例包括和整个页面相联系的数据，一个给定的HTML页面可以在多个JSP之间传递。 request：HTTP request（请求）对象 response：HTTP response（响应）对象 session：HTTP session（服务端会话）对象 JSP动作JSP动作是一系列可以调用内建于网络服务器中的功能的XML标签。JSP提供了以下动作： jsp:include 和子过程类似，JAVA SERVLET暂时接管对其它指定的JSP页的请求和响应。当处理完该JSP页后就马上把控制权交还当前JSP页。这样JSP代码就可以在多个JSP页中共享而不用复制。 jsp:param 可以在jsp:include, jsp:forward或jsp:params块之间使用。指定一个将加入请求的当前参数组中的参数。 jsp:forward 用于处理对另一个JSP或SERVLET的请求和响应。控制权永远不会交还给当前JSP页。 jsp:plugin Netscape Navigator使用不同的标签以嵌入一个applet。这个动作产生为嵌入一个APPLET所需要的指定浏览器标签。 jsp:fallback 如果浏览器不支持APPLETS则会显示的内容。 jsp:getProperty 从指定的JavaBean中获取一个属性值。 jsp:setProperty 在指定的JavaBean中设置一个属性值。 jsp:useBean 创建或者复用一个JavaBean变量到JSP页。 为什么使用JSPJSP程序与CGI程序有着相似的功能，但和CGI程序相比，JSP程序有如下优势： 性能更加优越，因为JSP可以直接在HTML网页中动态嵌入元素而不需要单独引用CGI文件。 服务器调用的是已经编译好的JSP文件，而不像CGI/Perl那样必须先载入解释器和目标脚本。 JSP 基于Java Servlet API，因此，JSP拥有各种强大的企业级Java API，包括JDBC，JNDI，EJB，JAXP等等。 JSP页面可以与处理业务逻辑的 Servlet 一起使用，这种模式被Java servlet 模板引擎所支持。 最后，JSP是Java EE不可或缺的一部分，是一个完整的企业级应用平台。这意味着JSP可以用最简单的方式来实现最复杂的应用。 感谢 百度百科 菜鸟教程 以及勤劳的自己","categories":[],"tags":[]},{"title":"Cookie--记住上一次访问时间案例（Java）","slug":"Cookie--记住上一次访问时间案例（Java）","date":"2020-06-26T02:56:26.000Z","updated":"2020-07-29T15:11:50.427Z","comments":true,"path":"2020/06/26/Cookie--记住上一次访问时间案例（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/26/Cookie--%E8%AE%B0%E4%BD%8F%E4%B8%8A%E4%B8%80%E6%AC%A1%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4%E6%A1%88%E4%BE%8B%EF%BC%88Java%EF%BC%89/","excerpt":"Cookie–记住上一次访问时间案例（Java）","text":"Cookie–记住上一次访问时间案例（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 需求 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串 分析 可以采用Cookie来完成 在服务器中的Servlet判断是否有一个名为lastTime的cookie 有：不是第一次访问 响应数据：欢迎回来，您上次访问时间为:2020年06月26日 10:52:29 写回Cookie：lastTime=2020年06月26日 10:52:29 没有：是第一次访问 响应数据：您好，欢迎您首次访问 写回Cookie：lastTime=2020年06月26日 10:52:29 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package cn.guizimo.cookie;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.Cookie;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.net.URLDecoder;import java.net.URLEncoder;import java.text.SimpleDateFormat;import java.util.Date;@WebServlet(\"/cookieTest\")public class CookieTest extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置响应的编码 resp.setContentType(\"text/html;charset=utf-8\"); boolean flag = false; //获取所有的cookie Cookie[] cookies = req.getCookies(); if (cookies != null &amp;&amp; cookies.length &gt; 0) &#123; for (Cookie cookie : cookies) &#123; String name = cookie.getName(); //判断是否第一次登录 if (\"lastTime\".equals(name)) &#123; //获取当前时间，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str_date = sdf.format(date); //编码 str_date = URLEncoder.encode(str_date, \"utf-8\"); cookie.setValue(str_date); //设置存活时间，一个月 cookie.setMaxAge(60 * 60 * 24 * 30); resp.addCookie(cookie); //响应数据 String value = cookie.getValue(); //解码 value = URLDecoder.decode(value, \"utf-8\"); resp.getWriter().write(\"&lt;h1&gt;欢迎回来，您上次的登录时间为：\" + value + \"&lt;/h1&gt;\"); &#125; &#125; &#125; if (cookies == null || cookies.length == 0 || flag == false) &#123; //获取当前时间，重新发送cookie Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); String str_date = sdf.format(date); //编码 str_date = URLEncoder.encode(str_date, \"utf-8\"); Cookie cookie = new Cookie(\"lastTime\", str_date); //设置存活时间，一个月 cookie.setMaxAge(60 * 60 * 24 * 30); resp.addCookie(cookie); resp.getWriter().write(\"&lt;h1&gt;欢迎首次访问&lt;/h1&gt;\"); &#125; &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; 测试第一次访问 再次访问 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"客户端会话技术--Cookie","slug":"客户端会话技术--Cookie","date":"2020-06-26T01:36:53.000Z","updated":"2020-07-29T15:07:29.195Z","comments":true,"path":"2020/06/26/客户端会话技术--Cookie/","link":"","permalink":"https://tangleia.github.io/2020/06/26/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF--Cookie/","excerpt":"客户端会话技术–Cookie","text":"客户端会话技术–Cookie 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念客户端会话技术，将数据保存到客户端 快速入门 创建Cookie对象，绑定数据 new Cookie(String name, String value) 发送Cookie对象 response.addCookie(Cookie cookie) 获取Cookie，拿到数据 Cookie[] request.getCookies() 实现原理基于响应头set-cookie和请求头cookie实现 cookie的细节处理 一次可不可以发送多个cookie? 可以 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。 cookie在浏览器中保存多长时间？ 默认情况下，当浏览器关闭后，Cookie数据被销毁 持久化存储： setMaxAge(int seconds) 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效 负数：默认值 零：删除cookie信息 cookie能不能存中文？ 在tomcat 8 之前 cookie中不能直接存储中文数据。 需要将中文数据转码—一般采用URL编码(%E3) 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析 cookie共享问题？ 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？ 默认情况下cookie不能共享 setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录 如果要共享，则可以将path设置为”/“ 不同的tomcat服务器间cookie共享问题？ setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享 setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享 Cookie的特点和作用 cookie存储数据在客户端浏览器 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个) 作用： cookie一般用于存出少量的不太敏感的数据 在不登录的情况下，完成服务器对客户端的身份识别 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--ServletContext对象","slug":"Java--ServletContext对象","date":"2020-06-25T14:02:49.000Z","updated":"2020-07-29T15:28:36.235Z","comments":true,"path":"2020/06/25/Java--ServletContext对象/","link":"","permalink":"https://tangleia.github.io/2020/06/25/Java--ServletContext%E5%AF%B9%E8%B1%A1/","excerpt":"Java–ServletContext对象","text":"Java–ServletContext对象 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念代表整个web应用，可以和程序的容器(服务器)来通信 获取 通过request对象获取 1request.getServletContext(); 通过HttpServlet获取 1this.getServletContext(); 功能 获取MIME类型： MIME类型: 在互联网通信过程中定义的一种文件数据类型 * 格式： 大类型/小类型 text/html image/jpeg * 获取： 1String getMimeType(String file) 域对象：共享数据 ServletContext对象范围：所有用户所有请求的数据 常用方法 123setAttribute(String name,Object value)getAttribute(String name)removeAttribute(String name) 获取文件的真实(服务器)路径 123456789String getRealPath(String path) String b = context.getRealPath(\"/b.txt\");//web目录下资源访问System.out.println(b);String c = context.getRealPath(\"/WEB-INF/c.txt\");//WEB-INF目录下的资源访问System.out.println(c);String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//src目录下的资源访问System.out.println(a); 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"动态生成验证码案例（Java）","slug":"动态生成验证码案例（Java）","date":"2020-06-25T13:43:04.000Z","updated":"2020-07-29T15:06:18.823Z","comments":true,"path":"2020/06/25/动态生成验证码案例（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E9%AA%8C%E8%AF%81%E7%A0%81%E6%A1%88%E4%BE%8B%EF%BC%88Java%EF%BC%89/","excerpt":"动态生成验证码案例（Java）","text":"动态生成验证码案例（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ servlet代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package cn.guizimo.web.servlet;import javax.imageio.ImageIO;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.awt.*;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;@WebServlet(\"/checkCode\")public class CheckCode extends HttpServlet &#123; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int width = 100; int height = 50; //创建图片对象 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_BGR); //美化 Graphics g = image.getGraphics(); //背景 g.setColor(Color.PINK); g.fillRect(0, 0, width, height); //边框 g.setColor(Color.BLUE); g.drawRect(0, 0, width - 1, height - 1); String str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; Random ran = new Random(); for (int i = 1; i &lt;= 4; i++) &#123; int index = ran.nextInt(str.length()); char ch = str.charAt(index); g.drawString(ch+\"\",width/5*i,height/2); &#125; //干扰线 g.setColor(Color.GREEN); for (int i = 0; i &lt; 10; i++) &#123; int x1 = ran.nextInt(width); int x2= ran.nextInt(width); int y1 = ran.nextInt(height); int y2 = ran.nextInt(height); g.drawLine(x1,y1,x2,y2); &#125; //输出图片到浏览器 ImageIO.write(image, \"jpg\", resp.getOutputStream()); &#125; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125;&#125; html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; window.onload = function () &#123; var img = document.getElementById(\"checkCode\"); img.onclick = function () &#123; var data = new Date().getTime(); img.src = \"/tomcat_test_war_exploded/checkCode?\" + data; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img id=\"checkCode\" src=\"/tomcat_test_war_exploded/checkCode\"/&gt;&lt;/body&gt;&lt;/html&gt; 启动项目 点击图片可以切换验证码 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"HTTP–Response详解","slug":"HTTP–Response详解","date":"2020-06-25T10:14:35.000Z","updated":"2020-07-29T15:25:01.389Z","comments":true,"path":"2020/06/25/HTTP–Response详解/","link":"","permalink":"https://tangleia.github.io/2020/06/25/HTTP%E2%80%93Response%E8%AF%A6%E8%A7%A3/","excerpt":"HTTP–Response详解","text":"HTTP–Response详解 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 响应消息数据格式响应行 组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态 态码都是3位数字 分类： 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误 404（请求路径没有对应的资源） 405：请求方式没有对应的doXxx方法 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应头 格式：头名称： 值 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 in-line:默认值,在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。文件下载 响应空行响应体:传输的数据响应字符串格式 123456789101112131415HTTP&#x2F;1.1 200 OKContent-Type: text&#x2F;html;charset&#x3D;UTF-8Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT&lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; hello , response &lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Response对象设置响应消息 设置响应行 格式：HTTP/1.1 200 ok 设置状态码：setStatus(int sc) 设置响应头：setHeader(String name, String value) 设置响应体： 使用步骤： 获取输出流 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"完整逆波兰计算器（Java）","slug":"完整逆波兰计算器（Java）","date":"2020-06-25T09:43:54.000Z","updated":"2020-07-29T15:10:08.793Z","comments":true,"path":"2020/06/25/完整逆波兰计算器（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E5%AE%8C%E6%95%B4%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%A1%E7%AE%97%E5%99%A8%EF%BC%88Java%EF%BC%89/","excerpt":"完整逆波兰计算器（Java）","text":"完整逆波兰计算器（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 功能支持 + - * / ( )多位数，支持小数,兼容处理, 过滤任何空白字符，包括空格、制表符、换页符 基本思路中缀表达式转后缀表达式 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;import java.util.Collections;import java.util.regex.Pattern;public class ReversePolishMultiCalc &#123; //匹配运算符 static final String SYMBOL = \"\\\\+|-|\\\\*|/|\\\\(|\\\\)\"; static final String LEFT = \"(\"; static final String RIGHT = \")\"; static final String ADD = \"+\"; static final String MINUS = \"-\"; static final String TIMES = \"*\"; static final String DIVISION = \"/\"; //优先级 static final int LEVEL_01 = 1; static final int LEVEL_02 = 2; static final int LEVEL_HIGH = Integer.MAX_VALUE; static Stack&lt;String&gt; stack = new Stack&lt;&gt;(); static List&lt;String&gt; data = Collections.synchronizedList(new ArrayList&lt;String&gt;()); //去除所有空白符号 public static String replaceAllBlank(String s) &#123; return s.replaceAll(\"\\\\s+\", \"\"); &#125; //判断是否为数字 public static boolean isNumber(String s) &#123; Pattern pattern = Pattern.compile(\"^[-\\\\+]?[.\\\\d]*$\"); return pattern.matcher(s).matches(); &#125; //判断是否是运算符 public static boolean isSymbol(String s) &#123; return s.matches(SYMBOL); &#125; //匹配运算优先级 public static int calcLevel(String s) &#123; if (\"+\".equals(s) || \"-\".equals(s)) &#123; return LEVEL_01; &#125; else if (\"*\".equals(s) || \"/\".equals(s)) &#123; return LEVEL_02; &#125; return LEVEL_HIGH; &#125; //匹配 public static List&lt;String&gt; doMatch(String s) throws Exception &#123; if (s == null || \"\".equals(s.trim())) throw new RuntimeException(\"data is empty\"); if (!isNumber(s.charAt(0) + \"\")) throw new RuntimeException(\"data illeagle,start not with a number\"); s = replaceAllBlank(s); String each; int start = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (isSymbol(s.charAt(i) + \"\")) &#123; each = s.charAt(i) + \"\"; if (stack.isEmpty() || LEFT.equals(each) || ((calcLevel(each) &gt; calcLevel(stack.peek())) &amp;&amp; calcLevel(each) &lt; LEVEL_HIGH)) &#123; stack.push(each); &#125; else if (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek())) &#123; while (!stack.isEmpty() &amp;&amp; calcLevel(each) &lt;= calcLevel(stack.peek())) &#123; if (calcLevel(stack.peek()) == LEVEL_HIGH) &#123; break; &#125; data.add(stack.pop()); &#125; stack.push(each); &#125; else if (RIGHT.equals(each)) &#123; while (!stack.isEmpty() &amp;&amp; LEVEL_HIGH &gt;= calcLevel(stack.peek())) &#123; if (LEVEL_HIGH == calcLevel(stack.peek())) &#123; stack.pop(); break; &#125; data.add(stack.pop()); &#125; &#125; start = i; &#125; else if (i == s.length() - 1 || isSymbol(s.charAt(i + 1) + \"\")) &#123; each = start == 0 ? s.substring(start, i + 1) : s.substring(start + 1, i + 1); if (isNumber(each)) &#123; data.add(each); continue; &#125; throw new RuntimeException(\"data not match number\"); &#125; &#125; Collections.reverse(stack); data.addAll(new ArrayList&lt;&gt;(stack)); System.out.println(data); return data; &#125; //计算结果 public static Double doCalc(List&lt;String&gt; list)&#123; Double d = 0d; if(list == null || list.isEmpty())&#123; return null; &#125; if(list.size() == 1)&#123; System.out.println(list); d = Double.valueOf(list.get(0)); return d; &#125; ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) &#123; list1.add(list.get(i)); if(isSymbol(list.get(i)))&#123; Double d1 = doTheMath(list.get(i-2),list.get(i-1),list.get(i)); list1.remove(i); list1.remove(i-1); list1.set(i-2,d1+\"\"); list1.addAll(list.subList(i+1,list.size())); break; &#125; &#125; doCalc(list1); return d; &#125; //运算 public static Double doTheMath(String s1,String s2,String symbol)&#123; Double result; switch (symbol)&#123; case ADD: result = Double.valueOf(s1) + Double.valueOf(s2); break; case MINUS: result = Double.valueOf(s1) - Double.valueOf(s2); break; case TIMES: result = Double.valueOf(s1) * Double.valueOf(s2); break; case DIVISION: result = Double.valueOf(s1) / Double.valueOf(s2); break; default: result = null; &#125; return result; &#125; public static void main(String[] args) &#123; String math = \"12.8 + (2-3.55)*4+10/5.0\"; try&#123; doCalc(doMatch(math)); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 结果 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"中缀表达式转换为后缀表达式（Java）","slug":"中缀表达式转换为后缀表达式（Java）","date":"2020-06-25T08:26:38.000Z","updated":"2020-07-29T15:10:33.012Z","comments":true,"path":"2020/06/25/中缀表达式转换为后缀表达式（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Java%EF%BC%89/","excerpt":"中缀表达式转换为后缀表达式（Java）","text":"中缀表达式转换为后缀表达式（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 步骤 初始化两个栈:运算符栈 s1 和储存中间结果的栈 s2 从左至右扫描中缀表达式 遇到操作数时，将其压 s2 遇到运算符时，比较其与 s1 栈顶运算符的优先级: 如果 s1 为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈 否则，若优先级比栈顶运算符的高，也将运算符压入 s1; 否则，将 s1 栈顶的运算符弹出并压入到 s2 中，再次转到(4-1)与 s1 中新的栈顶运算符相比较; 遇到括号时: 如果是左括号“(”，则直接压入 s1 如果是右括号“)”，则依次弹出 s1 栈顶的运算符，并压入 s2，直到遇到左括号为止，此时将这一对括号丢弃 重复步骤 2 至 5，直到表达式的最右边 将 s1 中剩余的运算符依次弹出并压入 s2 依次弹出 s2 中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 案例将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下 因此结果为 :”123+4 × +5 –” 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140package stack;import java.util.ArrayList;import java.util.List;import java.util.Stack;/** * @author guizimo * @date 2020/4/6 12:25 下午 */public class PolandNotation &#123; public static void main(String[] args) &#123; //表达式 String suffixExpression = \"1+((2+3)*4)-5\"; //中缀表达式对应的List System.out.println(\"中缀表达式对应的List\"); List&lt;String&gt; infixExpressionList = toInfixExpressionList(suffixExpression); System.out.println(infixExpressionList); //后缀表达式对应的List System.out.println(\"后缀表达式对应的List\"); List&lt;String&gt; suffixExpressionList = parseSuffixExpressionList(infixExpressionList); System.out.println(suffixExpressionList); //计算逆波兰表达式 System.out.printf(\"suffixExpression=%d\", calculate(suffixExpressionList)); &#125; public static List&lt;String&gt; parseSuffixExpressionList(List&lt;String&gt; ls) &#123; //定义两个栈 Stack&lt;String&gt; s1 = new Stack&lt;String&gt;(); //符号栈 List&lt;String&gt; s2 = new ArrayList&lt;String&gt;(); //结果 for (String item : ls) &#123; //如果是一个数 if (item.matches(\"\\\\d+\")) &#123; s2.add(item); &#125; else if (item.equals(\"(\")) &#123; s1.push(item); &#125; else if (item.equals(\")\")) &#123; while (!s1.peek().equals(\"(\")) &#123; s2.add(s1.pop()); &#125; s1.pop(); &#125; else &#123; while (s1.size() != 0 &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item)) &#123; s2.add(s1.pop()); &#125; s1.push(item); &#125; &#125; while (s1.size() != 0) &#123; s2.add(s1.pop()); &#125; return s2; &#125; //将中缀表达式转换成list public static List&lt;String&gt; toInfixExpressionList(String s) &#123; List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); int i = 0; String str; //多位数 char c; do &#123; //非数字 if ((c = s.charAt(i)) &lt; 48 || (c = s.charAt(i)) &gt; 57) &#123; ls.add(\"\" + c); i++; &#125; else &#123; //数字，但是考虑到多位数 str = \"\"; while (i &lt; s.length() &amp;&amp; (c = s.charAt(i)) &gt;= 48 &amp;&amp; (c = s.charAt(i)) &lt;= 57) &#123; str += c; i++; &#125; ls.add(str); &#125; &#125; while (i &lt; s.length()); return ls; &#125; //完成对逆波兰表达式的计算 public static int calculate(List&lt;String&gt; ls) &#123; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for (String item : ls) &#123; //使用正则表达式 if (item.matches(\"\\\\d+\")) &#123; //匹配多位数 //入栈 stack.push(item); &#125; else &#123; int num2 = Integer.parseInt(stack.pop()); int num1 = Integer.parseInt(stack.pop()); int res = 0; if (item.equals(\"+\")) &#123; res = num1 + num2; &#125; else if (item.equals(\"-\")) &#123; res = num1 - num2; &#125; else if (item.equals(\"*\")) &#123; res = num1 * num2; &#125; else if (item.equals(\"/\")) &#123; res = num1 / num2; &#125; else &#123; throw new RuntimeException(\"运算符有问题\"); &#125; //把结果入栈 stack.push(\"\" + res); &#125; &#125; return Integer.parseInt(stack.pop()); &#125;&#125;class Operation &#123; private static int ADD = 1; private static int SUB = 1; private static int MUL = 2; private static int DIV = 2; public static int getValue(String operation) &#123; int result = 0; switch (operation) &#123; case \"+\": result = ADD; break; case \"-\": result = SUB; break; case \"*\": result = MUL; break; case \"/\": result = DIV; break; default: System.out.println(\"不存在\"); break; &#125; return result; &#125;&#125; 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"递归--迷宫问题（Java）","slug":"递归--迷宫问题（Java）","date":"2020-06-25T08:03:58.000Z","updated":"2020-07-29T15:06:07.608Z","comments":true,"path":"2020/06/25/递归--迷宫问题（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E9%80%92%E5%BD%92--%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%EF%BC%88Java%EF%BC%89/","excerpt":"递归–迷宫问题（Java）","text":"递归–迷宫问题（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题说明制定好小球的移动路线，让它在迷宫里面找到终点的位置 问题思路 创建一个二维数组作为迷宫的地图 制定好小球的起点和终点位置 确定小球的运动规则，如下右上左 使用递归判断小球是否到达终点 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package question;public class Migong &#123; public static void main(String[] args) &#123; //创建一个地图 int[][] map = new int[8][7]; //1表示墙，0表示可以移动，2代表已经走过，3代表失败 //上下为墙 for (int i = 0; i &lt; 7; i++) &#123; map[0][i] = 1; map[7][i] = 1; &#125; //左右为墙 for (int i = 0; i &lt; 8; i++) &#123; map[i][0] = 1; map[i][6] = 1; &#125; //设置障碍物 map[3][1] = 1; map[3][2] = 1; //输出地图 System.out.println(\"地图\"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; //递归 setWay(map,1,1); //输出新的地图 System.out.println(\"到达终点地图\"); for (int i = 0; i &lt; 8; i++) &#123; for (int j = 0; j &lt; 7; j++) &#123; System.out.print(map[i][j] + \" \"); &#125; System.out.println(); &#125; &#125; public static boolean setWay(int[][] map,int i,int j)&#123; if(map[6][5] == 2)&#123; //到达终点 return true; &#125;else &#123; if(map[i][j] == 0)&#123; //继续 //制定策略，下右上左 map[i][j] = 2; if(setWay(map,i+1,j))&#123; //向下走 return true; &#125;else if(setWay(map,i,j+1))&#123; //向右走 return true; &#125;else if(setWay(map,i-1,j))&#123; //向上走 return true; &#125;else if(setWay(map,i,j-1))&#123; //向左走 return true; &#125;else &#123; //走不通 map[i][j] = 3; return false; &#125; &#125;else &#123; return false; &#125; &#125; &#125;&#125; 结果 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"递归--八皇后问题（Java）","slug":"递归--八皇后问题（Java）","date":"2020-06-25T07:39:16.000Z","updated":"2020-07-29T15:05:50.006Z","comments":true,"path":"2020/06/25/递归--八皇后问题（Java）/","link":"","permalink":"https://tangleia.github.io/2020/06/25/%E9%80%92%E5%BD%92--%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%88Java%EF%BC%89/","excerpt":"递归–八皇后问题（Java）","text":"递归–八皇后问题（Java） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题介绍八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即：任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法 问题思路 第一个皇后先放第一行第一列 第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适 继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解 当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到. 然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤 代码思路创建一个一维数组代替原本的二维数组，只针对列和斜线的判断 采用循环来判断在第n个皇后的不同列（i）是否冲突 使用递归来判断不同的皇后的情况 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package question;public class Queen &#123; //定义最大的行 int max = 8; //创建一维数组存储每行的列的位置 int[] array = new int[max]; //结果数 static int count = 0; //检查是否冲突的次数 static int judgecount = 0; public static void main(String[] args) &#123; Queen queen = new Queen(); queen.check(0); System.out.printf(\"一共有%d总解法\", count); System.out.println(); System.out.printf(\"一共有%d次判断冲突\", judgecount); &#125; //放置皇后 private void check(int n) &#123; if (n == max) &#123; //已经放置好 //打印函数 print(); return; &#125; //依次放置皇后的列数 for (int i = 0; i &lt; max; i++) &#123; //把皇后放置到该行的第一列 array[n] = i; //判断当前皇后在i列时是否冲突 if (judge(n)) &#123; //不冲突 //接着放n+1个皇后（递归） check(n + 1); &#125; &#125; &#125; //判断是否冲突 private boolean judge(int n) &#123; judgecount++; for (int i = 0; i &lt; n; i++) &#123; //由于n代表行，所以不会出现在同一行的情况，判断是否在同一列，判断是否在同一斜线上 if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123; return false; &#125; &#125; return true; &#125; //打印结果 private void print() &#123; count++; for (int i = 0; i &lt; array.length; i++) &#123; System.out.print(array[i] + \" \"); &#125; System.out.println(); &#125;&#125; 结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293940 4 7 5 2 6 1 3 0 5 7 2 6 3 1 4 0 6 3 5 7 1 4 2 0 6 4 7 1 3 5 2 1 3 5 7 2 0 6 4 1 4 6 0 2 7 5 3 1 4 6 3 0 7 5 2 1 5 0 6 3 7 2 4 1 5 7 2 0 3 6 4 1 6 2 5 7 4 0 3 1 6 4 7 0 3 5 2 1 7 5 0 2 4 6 3 2 0 6 4 7 1 3 5 2 4 1 7 0 6 3 5 2 4 1 7 5 3 6 0 2 4 6 0 3 1 7 5 2 4 7 3 0 6 1 5 2 5 1 4 7 0 6 3 2 5 1 6 0 3 7 4 2 5 1 6 4 0 7 3 2 5 3 0 7 4 6 1 2 5 3 1 7 4 6 0 2 5 7 0 3 6 4 1 2 5 7 0 4 6 1 3 2 5 7 1 3 0 6 4 2 6 1 7 4 0 3 5 2 6 1 7 5 3 0 4 2 7 3 6 0 5 1 4 3 0 4 7 1 6 2 5 3 0 4 7 5 2 6 1 3 1 4 7 5 0 2 6 3 1 6 2 5 7 0 4 3 1 6 2 5 7 4 0 3 1 6 4 0 7 5 2 3 1 7 4 6 0 2 5 3 1 7 5 0 2 4 6 3 5 0 4 1 7 2 6 3 5 7 1 6 0 2 4 3 5 7 2 0 6 4 1 3 6 0 7 4 1 5 2 3 6 2 7 1 4 0 5 3 6 4 1 5 0 2 7 3 6 4 2 0 5 7 1 3 7 0 2 5 1 6 4 3 7 0 4 6 1 5 2 3 7 4 2 0 6 1 5 4 0 3 5 7 1 6 2 4 0 7 3 1 6 2 5 4 0 7 5 2 6 1 3 4 1 3 5 7 2 0 6 4 1 3 6 2 7 5 0 4 1 5 0 6 3 7 2 4 1 7 0 3 6 2 5 4 2 0 5 7 1 3 6 4 2 0 6 1 7 5 3 4 2 7 3 6 0 5 1 4 6 0 2 7 5 3 1 4 6 0 3 1 7 5 2 4 6 1 3 7 0 2 5 4 6 1 5 2 0 3 7 4 6 1 5 2 0 7 3 4 6 3 0 2 7 5 1 4 7 3 0 2 5 1 6 4 7 3 0 6 1 5 2 5 0 4 1 7 2 6 3 5 1 6 0 2 4 7 3 5 1 6 0 3 7 4 2 5 2 0 6 4 7 1 3 5 2 0 7 3 1 6 4 5 2 0 7 4 1 3 6 5 2 4 6 0 3 1 7 5 2 4 7 0 3 1 6 5 2 6 1 3 7 0 4 5 2 6 1 7 4 0 3 5 2 6 3 0 7 1 4 5 3 0 4 7 1 6 2 5 3 1 7 4 6 0 2 5 3 6 0 2 4 1 7 5 3 6 0 7 1 4 2 5 7 1 3 0 6 4 2 6 0 2 7 5 3 1 4 6 1 3 0 7 4 2 5 6 1 5 2 0 3 7 4 6 2 0 5 7 4 1 3 6 2 7 1 4 0 5 3 6 3 1 4 7 0 2 5 6 3 1 7 5 0 2 4 6 4 2 0 5 7 1 3 7 1 3 0 6 4 2 5 7 1 4 2 0 6 3 5 7 2 0 5 1 4 6 3 7 3 0 2 5 1 6 4 一共有92总解法一共有15720次判断冲突 感谢 尚硅谷 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java--用户登录（JDBC，MYSQL，Servlet）","slug":"Java--用户登录（JDBC，MYSQL，Servlet）","date":"2020-06-22T05:13:15.000Z","updated":"2020-07-29T15:25:25.820Z","comments":true,"path":"2020/06/22/Java--用户登录（JDBC，MYSQL，Servlet）/","link":"","permalink":"https://tangleia.github.io/2020/06/22/Java--%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%EF%BC%88JDBC%EF%BC%8CMYSQL%EF%BC%8CServlet%EF%BC%89/","excerpt":"Java–用户登录（JDBC，MYSQL，Servlet）","text":"Java–用户登录（JDBC，MYSQL，Servlet） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 用户登录案例需求 编写login.html登录页面username &amp; password 两个输入框 使用Druid数据库连接池技术,操作mysql，day14数据库中user表 使用JdbcTemplate技术封装JDBC 登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您 登录失败跳转到FailServlet展示：登录失败，用户名或密码错误 登录页面12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/login_test/loginServlet\" method=\"post\"&gt; 用户名:&lt;input type=\"text\" name=\"username\"&gt; &lt;br&gt; 密码:&lt;input type=\"password\" name=\"password\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 创建数据库123456789CREATE DATABASE login;USE login;CREATE TABLE user( id INT PRIMARY KEY auto_increment, username VARCHAR(32) UNIQUE NOT NULL, password VARCHAR(32) NOT NULL) 配置文件1234567driverClassName&#x3D;com.mysql.jdbc.Driverurl&#x3D;jdbc:mysql:&#x2F;&#x2F;&#x2F;loginusername&#x3D;rootpassword&#x3D;rootinitialSize&#x3D;5maxActive&#x3D;10maxWait&#x3D;3000 项目依赖 创建用户实体类创建包cn.guizimo.domain,创建类User 1234567891011121314151617181920212223242526272829303132333435363738394041424344package cn.guizimo.domain;/** * @author tanglei * @date 2020/6/22 10:28 上午 */public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"id=\" + id + \", username='\" + username + '\\'' + \", password='\" + password + '\\'' + '&#125;'; &#125;&#125; 创建工具类创建包cn.guizimo.util,编写工具类JDBCUtils 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.guizimo.util;import com.alibaba.druid.pool.DruidDataSourceFactory;import javax.sql.DataSource;import java.io.IOException;import java.io.InputStream;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;/** * @author tanglei * @date 2020/6/22 10:38 上午 */public class JDBCUtils &#123; private static DataSource ds ; static &#123; try &#123; //1.加载配置文件 Properties pro = new Properties(); //使用ClassLoader加载配置文件，获取字节输入流 InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"); pro.load(is); //2.初始化连接池对象 ds = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获取连接池对象 */ public static DataSource getDataSource()&#123; return ds; &#125; /** * 获取连接Connection对象 */ public static Connection getConnection() throws SQLException &#123; return ds.getConnection(); &#125;&#125; 创建数据操作类创建包cn.guizimo.dao,创建类UserDao,提供login方法 123456789101112131415161718192021222324252627282930package cn.guizimo.dao;import cn.guizimo.domain.User;import cn.guizimo.util.JDBCUtils;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.BeanPropertyRowMapper;import org.springframework.jdbc.core.JdbcTemplate;/** * @author tanglei * @date 2020/6/22 10:34 上午 */public class UserDao &#123; private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource()); public User login(User loginUser) &#123; try &#123; String sql = \"select * from user where username = ? and password = ?\"; User user = template.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), loginUser.getUsername(), loginUser.getPassword()); return user; &#125; catch (DataAccessException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 创建servlet类cn.guizimo.web.servlet.LoginServlet类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package cn.guizimo.web.servlet;import cn.guizimo.dao.UserDao;import cn.guizimo.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author tanglei * @date 2020/6/22 11:15 上午 */@WebServlet(\"/loginServlet\")public class LoginServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //1.设置编码 req.setCharacterEncoding(\"utf-8\"); //2.获取请求参数 String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); //3.封装user对象 User loginUser = new User(); loginUser.setUsername(username); loginUser.setPassword(password); //4.调用UserDao的login方法 UserDao dao = new UserDao(); User user = dao.login(loginUser); //5.判断user if(user == null)&#123; //登录失败 req.getRequestDispatcher(\"/failServlet\").forward(req,resp); &#125;else&#123; //登录成功 //存储数据 req.setAttribute(\"user\",user); //转发 req.getRequestDispatcher(\"/successServlet\").forward(req,resp); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doGet(req,resp); &#125;&#125; cn.guizimo.web.servlet.FailServlet类 1234567891011121314151617181920212223242526272829package cn.guizimo.web.servlet;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author tanglei * @date 2020/6/22 11:26 上午 */@WebServlet(\"/failServlet\")public class FailServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置编码 resp.setContentType(\"text/html;charset=utf-8\"); //输出 resp.getWriter().write(\"登录失败，用户名或密码错误\"); &#125;&#125; cn.guizimo.web.servlet.SuccessServlet类 1234567891011121314151617181920212223242526272829303132333435package cn.guizimo.web.servlet;import cn.guizimo.domain.User;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author tanglei * @date 2020/6/22 11:31 上午 */@WebServlet(\"/successServlet\")public class SuccessServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取request域中共享的user对象 User user = (User) req.getAttribute(\"user\"); if(user != null)&#123; //设置编码 resp.setContentType(\"text/html;charset=utf-8\"); //输出 resp.getWriter().write(\"登录成功！\"+user.getUsername()+\",欢迎您\"); &#125; &#125;&#125; 运行在浏览器中打开http://localhost:8080/login_test/login.html 登录成功 登录失败 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Java问题解决--java.lang.NoClassDefFoundError","slug":"Java问题解决--java.lang.NoClassDefFoundError","date":"2020-06-22T04:47:54.000Z","updated":"2020-07-29T15:57:54.445Z","comments":true,"path":"2020/06/22/Java问题解决--java.lang.NoClassDefFoundError/","link":"","permalink":"https://tangleia.github.io/2020/06/22/Java%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3--java.lang.NoClassDefFoundError/","excerpt":"Java问题解决–java.lang.NoClassDefFoundError","text":"Java问题解决–java.lang.NoClassDefFoundError 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 问题 java.lang.NoClassDefFoundError: org/springframework/dao/DataAccessException 问题截图 问题解决这个是由于不能找到导入的依赖 注意在WEB-INF的lib目录下导入，名字不要写错 右击lib目录，Add as Library 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"HTTP--Request详解","slug":"HTTP--Request详解","date":"2020-06-22T01:58:51.000Z","updated":"2020-07-29T15:24:46.656Z","comments":true,"path":"2020/06/22/HTTP--Request详解/","link":"","permalink":"https://tangleia.github.io/2020/06/22/HTTP--Request%E8%AF%A6%E8%A7%A3/","excerpt":"HTTP–Request详解","text":"HTTP–Request详解 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 请求消息数据格式请求行12请求方式 请求url 请求协议&#x2F;版本GET &#x2F;login.html HTTP&#x2F;1.1 请求头客户端浏览器告诉服务器一些信息 1请求头名称: 请求头值 常见的请求头： User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息 可以在服务器端获取该头的信息，解决浏览器的兼容性问题 Referer：http://localhost/login.html 告诉服务器，我(当前请求)从哪里来？ 作用： 防盗链： 统计工作： 请求空行空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文) 封装POST请求消息的请求参数的 字符串格式： 1234567891011POST &#x2F;login.html HTTP&#x2F;1.1Host: localhostUser-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko&#x2F;20100101 Firefox&#x2F;60.0Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8Accept-Language: zh-CN,zh;q&#x3D;0.8,zh-TW;q&#x3D;0.7,zh-HK;q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2Accept-Encoding: gzip, deflateReferer: http:&#x2F;&#x2F;localhost&#x2F;login.htmlConnection: keep-aliveUpgrade-Insecure-Requests: 1username&#x3D;zhangsan 获取请求消息数据 获取请求行数据 GET /day14/demo1?name=zhangsan HTTP/1.1 方法： 获取请求方式 ：GET String getMethod() (*)获取虚拟目录：/day14 String getContextPath() 获取Servlet路径: /demo1 String getServletPath() 获取get方式请求参数：name=zhangsan String getQueryString() (*)获取请求URI：/day14/demo1 String getRequestURI(): /day14/demo1 StringBuffer getRequestURL() :http://localhost/day14/demo1 URL:统一资源定位符 ： http://localhost/day14/demo1 URI：统一资源标识符 : /day14/demo1 获取协议及版本：HTTP/1.1 String getProtocol() 获取客户机的IP地址： String getRemoteAddr() 获取请求头数据 方法： (*)String getHeader(String name):通过请求头的名称获取请求头的值 Enumeration getHeaderNames():获取所有的请求头名称 获取请求体数据: 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数 步骤： 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 再从流对象中拿数据 获取请求参数通用方式不论get还是post请求方式都可以使用下列方法来获取请求参数 String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game Enumeration getParameterNames():获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 请求转发一种在服务器内部的资源跳转方式 步骤： 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path) 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) 特点： 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中。 转发是一次请求 共享数据 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 方法： void setAttribute(String name,Object obj):存储数据 Object getAttitude(String name):通过键获取值 void removeAttribute(String name):通过键移除键值对 获取ServletContextServletContext getServletContext() 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"HTTP--协议详解","slug":"HTTP--协议详解","date":"2020-06-22T01:24:34.000Z","updated":"2020-07-29T15:24:09.048Z","comments":true,"path":"2020/06/22/HTTP--协议详解/","link":"","permalink":"https://tangleia.github.io/2020/06/22/HTTP--%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/","excerpt":"HTTP–协议详解","text":"HTTP–协议详解 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ HTTP 简介HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP 工作原理HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80，但是你也可以改为8080或者其他端口。 HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP 协议的 8 种请求类型介绍HTTP 协议中共定义了八种方法或者叫“动作”来表明对 Request-URI 指定的资源的不同操作方式，具体介绍如下： OPTIONS：返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。 HEAD：向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET：向特定的资源发出请求。 POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和/或已有资源的修改。 PUT：向指定资源位置上传其最新内容。 DELETE：请求服务器删除 Request-URI 所标识的资源。 TRACE：回显服务器收到的请求，主要用于测试或诊断。 CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 虽然 HTTP 的请求方式有 8 种，但是我们在实际应用中常用的也就是 get 和 post，其他请求方式也都可以通过这两种方式间接的来实现。 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Servlet--生命周期","slug":"Servlet--生命周期","date":"2020-06-22T01:05:48.000Z","updated":"2020-07-29T16:05:36.445Z","comments":true,"path":"2020/06/22/Servlet--生命周期/","link":"","permalink":"https://tangleia.github.io/2020/06/22/Servlet--%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","excerpt":"Servlet–生命周期","text":"Servlet–生命周期 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 生命周期Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程： Servlet 通过调用 init () 方法进行初始化。 Servlet 调用 service() 方法来处理客户端的请求。 Servlet 通过调用 destroy() 方法终止（结束）。 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。 init() 方法init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。因此，它是用于一次性初始化，就像 Applet 的 init 方法一样。 Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。 当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。 123public void init() throws ServletException &#123; // 初始化代码...&#125; service() 方法service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。 1234public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException&#123;&#125; service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。 doGet() 方法GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。 12345public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码&#125; doPost() 方法POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。 12345public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // Servlet 代码&#125; destroy() 方法destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。 在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。 123public void destroy() &#123; // 终止化代码...&#125; 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Servlet 简介","slug":"Servlet 简介","date":"2020-06-21T10:39:54.000Z","updated":"2020-07-29T16:05:24.846Z","comments":true,"path":"2020/06/21/Servlet 简介/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Servlet%20%E7%AE%80%E4%BB%8B/","excerpt":"Servlet 简介","text":"Servlet 简介 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 简介Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 Servlet的位置 Servlet的工作 读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Servlet--实例","slug":"Servlet--实例","date":"2020-06-21T10:38:10.000Z","updated":"2020-07-29T16:05:48.202Z","comments":true,"path":"2020/06/21/Servlet--实例/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Servlet--%E5%AE%9E%E4%BE%8B/","excerpt":"Servlet–实例","text":"Servlet–实例 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ HelloWorld创建Java Web项目，在src目录下新建类文件Helloworld.java 12345678910111213141516171819202122232425262728293031323334353637import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @author tanglei * @date 2020/6/21 6:04 下午 */public class HelloWorld extends HttpServlet &#123; private String message; public void init() throws ServletException &#123; // 执行必需的初始化 message = \"Hello World\"; &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // 设置响应内容类型 response.setContentType(\"text/html\"); // 实际的逻辑是在这里 PrintWriter out = response.getWriter(); out.println(\"&lt;h1&gt;\" + message + \"&lt;/h1&gt;\"); &#125; public void destroy() &#123; // 什么也不做 &#125;&#125; 编写配置文件在web目录下的WEB-INF里面的web.xml里面配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;servlet-class&gt;HelloWorld&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt; &lt;url-pattern&gt;/HelloWorld&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 启动项目点击启动项目，等待项目成功启动之后，会自动打开浏览器的localhost:8080的默认项目，由于我们这里是Idea启动的，所以启动的项目就是我们当前的项目，名称为tomcat_test_war_exploded 我们在浏览器中输入完整的url路径http://localhost:8080/tomcat_test_war_exploded/HelloWorld 打开检查，找到接口的回应 感谢 菜鸟教程 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Tomcat--在IDEA创建Java Web项目，通过tomcat启动","slug":"Tomcat--在IDEA创建Java Web项目，通过tomcat启动","date":"2020-06-21T09:34:30.000Z","updated":"2020-07-29T16:06:50.549Z","comments":true,"path":"2020/06/21/Tomcat--在IDEA创建Java Web项目，通过tomcat启动/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Tomcat--%E5%9C%A8IDEA%E5%88%9B%E5%BB%BAJava%20Web%E9%A1%B9%E7%9B%AE%EF%BC%8C%E9%80%9A%E8%BF%87tomcat%E5%90%AF%E5%8A%A8/","excerpt":"Tomcat–在IDEA创建Java Web项目，通过tomcat启动","text":"Tomcat–在IDEA创建Java Web项目，通过tomcat启动 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 配置Idea找到run菜单，找到配置 选择模版，找到tomcat 选择自己的tomcat的目录 创建Java Web项目选择新建项目，选择好版本 当我们创建好了之后。tomcat服务器相应的也搭建好了 运行 在浏览器中localhost:8080 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Tomcat--配置","slug":"Tomcat--配置","date":"2020-06-21T02:58:57.000Z","updated":"2020-07-29T16:06:32.765Z","comments":true,"path":"2020/06/21/Tomcat--配置/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Tomcat--%E9%85%8D%E7%BD%AE/","excerpt":"Tomcat–配置","text":"Tomcat–配置 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明web服务器软件 下载和启动这里就不多说了，之前有过博客的 配置部署项目的方式 直接将项目放到webapps目录下即可。 直接部署：项目的访问路径–&gt;虚拟目录（把html页面放入其中） 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。 war包会自动解压缩 配置conf/server.xml文件 在标签体中配置 * docBase:项目存放的路径 * path：虚拟目录 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写 * 虚拟目录：xml文件的名称 静态项目和动态项目 目录结构 java动态项目的目录结构： 项目的根目录 WEB-INF目录： web.xml：web项目的核心配置文件 classes目录：放置字节码文件的目录 lib目录：放置依赖的jar包 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Mac安装Tomcat","slug":"Mac安装Tomcat","date":"2020-06-21T01:38:03.000Z","updated":"2020-07-29T16:04:24.508Z","comments":true,"path":"2020/06/21/Mac安装Tomcat/","link":"","permalink":"https://tangleia.github.io/2020/06/21/Mac%E5%AE%89%E8%A3%85Tomcat/","excerpt":"Mac安装Tomcat","text":"Mac安装Tomcat 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 下载官网地址http://tomcat.apache.org/ 注意下载的版本，我这里是mac的 启动将文件解压，可以改名成为Tomcat，进入到bin目录下 开启1sh .&#x2F;startup.sh 关闭1sh .&#x2F;shutdown.sh 测试在浏览器中打开localhost:8080 感谢 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"XML--解析","slug":"XML--解析","date":"2020-06-21T00:38:29.000Z","updated":"2020-07-29T16:08:01.233Z","comments":true,"path":"2020/06/21/XML--解析/","link":"","permalink":"https://tangleia.github.io/2020/06/21/XML--%E8%A7%A3%E6%9E%90/","excerpt":"XML–解析","text":"XML–解析 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 解析操作xml文档，将文档中的数据读取到内存中 操作xml文档 解析(读取)：将文档中的数据读取到内存中 写入：将内存中的数据保存到xml文档中。持久化的存储 解析xml的方式 DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树 优点：操作方便，可以对文档进行CRUD的所有操作 缺点：占内存 SAX：逐行读取，基于事件驱动的。 优点：不占内存。 缺点：只能读取，不能增删改 xml常见的解析器 JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。 PULL：Android操作系统内置的解析器，sax方式的。 Jsoup快速入门 步骤： 导入jar包 获取Document对象 获取对应的标签Element对象 获取数据 代码 123456789101112//2.1获取student.xml的path String path = JsoupDemo1.class.getClassLoader().getResource(\"student.xml\").getPath(); //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document Document document = Jsoup.parse(new File(path), \"utf-8\"); //3.获取元素对象 Element Elements elements = document.getElementsByTag(\"name\"); System.out.println(elements.size()); //3.1获取第一个name的Element对象 Element element = elements.get(0); //3.2获取数据 String name = element.text(); System.out.println(name); 对象的使用 1. Jsoup：工具类，可以解析html或xml文档，返回Document * parse：解析html或xml文档，返回Document * parse(File in, String charsetName)：解析xml或html文件的。 * parse(String html)：解析xml或html字符串 * parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 Document：文档对象。代表内存中的dom树 获取Element对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 Elements：元素Element对象的集合。可以当做 ArrayList来使用 Element：元素对象 获取子元素对象 getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据对应的属性名和属性值获取元素对象集合 获取属性值 String attr(String key)：根据属性名称获取属性值 获取属性值 String attr(String key)：根据属性名称获取属性值 获取文本内容 String text():获取文本内容 String html():获取标签体的所有内容(包括字标签的字符串内容) 5、Node：节点对象 是Document和Element的父类 快捷查询方式 selector:选择器 使用的方法：Elements select(String cssQuery) 语法：参考Selector类中定义的语法 XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言 使用Jsoup的Xpath需要额外导入jar包。 代码： 123456789101112131415161718192021222324252627282930313233343536 //1.获取student.xml的path String path = JsoupDemo6.class.getClassLoader().getResource(\"student.xml\").getPath();//2.获取Document对象 Document document = Jsoup.parse(new File(path), \"utf-8\"); //3.根据document对象，创建JXDocument对象 JXDocument jxDocument = new JXDocument(document); //4.结合xpath语法查询 //4.1查询所有student标签 List&lt;JXNode&gt; jxNodes = jxDocument.selN(\"//student\"); for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode); &#125; System.out.println(\"--------------------\"); //4.2查询所有student标签下的name标签 List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(\"//student/name\"); for (JXNode jxNode : jxNodes2) &#123; System.out.println(jxNode); &#125; System.out.println(\"--------------------\"); //4.3查询student标签下带有id属性的name标签 List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(\"//student/name[@id]\"); for (JXNode jxNode : jxNodes3) &#123; System.out.println(jxNode); &#125; System.out.println(\"--------------------\"); //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(\"//student/name[@id='itcast']\"); for (JXNode jxNode : jxNodes4) &#123; System.out.println(jxNode); &#125; 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"XML--简介和基本用法","slug":"XML--简介和基本用法","date":"2020-06-20T08:19:06.000Z","updated":"2020-07-29T16:07:47.397Z","comments":true,"path":"2020/06/20/XML--简介和基本用法/","link":"","permalink":"https://tangleia.github.io/2020/06/20/XML--%E7%AE%80%E4%BB%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","excerpt":"XML–简介和基本用法","text":"XML–简介和基本用法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念Extensible Markup Language 可扩展标记语言 可扩展标签都是自定义的。 功能：存储数据配置文件 在网络中传输 xml与html的区别xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 语法基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 案例123456789101112131415&lt;?xml version='1.0' ?&gt; &lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 组成部分：文档声明 格式： 1&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值： yes：不依赖其他文件 no：依赖其他文件 指令(了解)：结合css的 1&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;a.css&quot; ?&gt; 标签：标签名称自定义的 规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性 id属性值唯一 文本： CDATA区：在该区域中的数据会被原样展示 1&lt;![CDATA[ 数据 ]]&gt; 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"XML--约束","slug":"XML--约束","date":"2020-06-20T08:17:30.000Z","updated":"2020-07-29T16:08:20.359Z","comments":true,"path":"2020/06/20/XML--约束/","link":"","permalink":"https://tangleia.github.io/2020/06/20/XML--%E7%BA%A6%E6%9D%9F/","excerpt":"XML–简介和基本用法","text":"XML–简介和基本用法 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 概念Extensible Markup Language 可扩展标记语言 可扩展标签都是自定义的。 功能：存储数据配置文件 在网络中传输 xml与html的区别xml标签都是自定义的，html标签是预定义。 xml的语法严格，html语法松散 xml是存储数据的，html是展示数据 语法基本语法 xml文档的后缀名 .xml xml第一行必须定义为文档声明 xml文档中有且仅有一个根标签 属性值必须使用引号(单双都可)引起来 标签必须正确关闭 xml标签名称区分大小写 案例123456789101112131415&lt;?xml version='1.0' ?&gt; &lt;users&gt; &lt;user id='1'&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;male&lt;/gender&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id='2'&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;24&lt;/age&gt; &lt;gender&gt;female&lt;/gender&gt; &lt;/user&gt; &lt;/users&gt; 组成部分：文档声明 格式： 1&lt;?xml 属性列表 ?&gt; 属性列表： version：版本号，必须的属性 encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 standalone：是否独立 取值： yes：不依赖其他文件 no：依赖其他文件 指令(了解)：结合css的 1&lt;?xml-stylesheet type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;a.css&quot; ?&gt; 标签：标签名称自定义的 规则： 名称可以包含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字母 xml（或者 XML、Xml 等等）开始 名称不能包含空格 属性 id属性值唯一 文本： * CDATA区：在该区域中的数据会被原样展示 1&lt;![CDATA[ 数据 ]]&gt; 感谢 黑马程序员 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"博客园添加live2d看板娘","slug":"博客园添加live2d看板娘","date":"2020-06-18T15:22:32.000Z","updated":"2020-06-18T15:28:34.840Z","comments":true,"path":"2020/06/18/博客园添加live2d看板娘/","link":"","permalink":"https://tangleia.github.io/2020/06/18/%E5%8D%9A%E5%AE%A2%E5%9B%AD%E6%B7%BB%E5%8A%A0live2d%E7%9C%8B%E6%9D%BF%E5%A8%98/","excerpt":"博客园添加live2d看板娘","text":"博客园添加live2d看板娘 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 配置添加代码到博客园侧边栏公告 代码12345678910111213141516171819202122232425&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;eqcn.ajz.miesnfu.com&#x2F;wp-content&#x2F;plugins&#x2F;wp-3d-pony&#x2F;live2dw&#x2F;lib&#x2F;L2Dwidget.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt; L2Dwidget.init(&#123; &quot;model&quot;: &#123; jsonPath: &quot;https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-shizuku@1.0.5&#x2F;assets&#x2F;shizuku.model.json&quot;, &quot;scale&quot;: 1 &#125;, &quot;display&quot;: &#123; &quot;position&quot;: &quot;right&quot;, &quot;width&quot;: 75, &quot;height&quot;: 150, &quot;hOffset&quot;: 0, &quot;vOffset&quot;: -20 &#125;, &quot;mobile&quot;: &#123; &quot;show&quot;: true, &quot;scale&quot;: 0.5 &#125;, &quot;react&quot;: &#123; &quot;opacityDefault&quot;: 0.7, &quot;opacityOnHover&quot;: 0.2 &#125; &#125;);&lt;&#x2F;script&gt; 选择人物在上面jsonPath切换就可以啦 123456黑猫：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-hijiki@1.0.5&#x2F;assets&#x2F;hijiki.model.json萌娘：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-shizuku@1.0.5&#x2F;assets&#x2F;shizuku.model.json白猫：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-tororo@1.0.5&#x2F;assets&#x2F;tororo.model.json狗狗：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json小可爱：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-z16@1.0.5&#x2F;assets&#x2F;z16.model.json小可爱：https:&#x2F;&#x2F;unpkg.com&#x2F;live2d-widget-model-koharu@1.0.5&#x2F;assets&#x2F;koharu.model.json 测试 当然这个大小可以去调整的 感谢 hexo+github+live2d+volantis 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"使用GitHub+Hexo+live2d搭建个人博客","slug":"使用GitHub+Hexo+live2d搭建个人博客","date":"2020-06-18T14:51:12.000Z","updated":"2020-06-18T15:25:07.180Z","comments":true,"path":"2020/06/18/使用GitHub+Hexo+live2d搭建个人博客/","link":"","permalink":"https://tangleia.github.io/2020/06/18/%E4%BD%BF%E7%94%A8GitHub+Hexo+live2d%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"使用GitHub+Hexo+live2d搭建个人博客","text":"使用GitHub+Hexo+live2d搭建个人博客 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 安装hexo1sudo npm install hexo-cli -g 创建博客目录123hexo init username.github.iocd username.github.ionpm install 运行123hexo clean #清理文件hexo g #生成文件hexo s #运行 打开浏览器，输入地址localhost:4000即可看到博客页面 安装主题主题官网可以查看 https://hexo.io/themes/[](https://hexo.io/themes/) 我使用的是volantis，文档地址 https://volantis.js.org/v2/getting-started/[](https://volantis.js.org/v2/getting-started/) 下载主题1git clone https:&#x2F;&#x2F;github.com&#x2F;xaoxuu&#x2F;hexo-theme-volantis themes&#x2F;volantis 修改配置文件项目根目录下_config.yml文件 1theme: volantis 安装依赖12npm i -S hexo-generator-search hexo-generator-json-contentnpm i -S hexo-renderer-stylus 配置文件一般在/_config.yml配置网页图标名称等 一般在/theme/{theme}/_config.yml配置主题等页面显示的问题 部署到Github在GitHub创建一个&lt;username&gt;.github.io的public仓库，如果你的用户名是xxx,则需要创建一个xxx.github.io的public仓库，这个步骤很简单就跳过了 安装依赖1npm install hexo-deployer-git --save 网站配置git在网站的_config.yml中配置deploy 1234deploy: type: git repo: &lt;repository url&gt; #你的仓库地址 branch: master 部署1hexo d 需要Github的用户名和密码，填入即可 现在的样子当然这个需要你们根据主题里面的文档进行配置 配置live2dhexo可以直接当做插件使用live2d，不过很慢 下载依赖1npm install --save hexo-helper-live2d 下载主题可以选择主题下载，选择不同的人物 1npm install live2d-widget-model-shizuku 配置主题在/_config.yml配置文件里面添加一段配置 12345678910111213141516171819202122232425262728293031# Live2D## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2d## https:&#x2F;&#x2F;l2dwidget.js.org&#x2F;docs&#x2F;class&#x2F;src&#x2F;index.js~L2Dwidget.html#instance-method-initlive2d: enable: true #enable: false scriptFrom: local # 默认 pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径) pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径 pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-shizuku # use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名 # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径 # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url display: position: left width: 150 height: 300 mobile: show: true # 是否在移动设备上显示 scale: 0.5 # 移动设备上的缩放 react: opacityDefault: 0.7 opacityOnHover: 0.8 可以自己选择大小和位置 配置好了之后再次部署 123hexo cleanhexo ghexo d 测试下面那个人物等了一会再出现的 感谢 hexo+github+live2d+volantis 万能的网络 以及勤劳的自己","categories":[],"tags":[]},{"title":"Go--Beego新建项目（解决不能访问的问题)","slug":"Go--Beego新建项目（解决不能访问的问题)","date":"2020-06-18T08:06:58.000Z","updated":"2020-06-18T15:25:25.360Z","comments":true,"path":"2020/06/18/Go--Beego新建项目（解决不能访问的问题)/","link":"","permalink":"https://tangleia.github.io/2020/06/18/Go--Beego%E6%96%B0%E5%BB%BA%E9%A1%B9%E7%9B%AE%EF%BC%88%E8%A7%A3%E5%86%B3%E4%B8%8D%E8%83%BD%E8%AE%BF%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98)/","excerpt":"Go–Beego新建项目（解决不能访问的问题）","text":"Go–Beego新建项目（解决不能访问的问题） 博客说明 文章所涉及的资料来自互联网整理和个人总结，意在于个人学习和经验汇总，如有什么地方侵权，请联系本人删除，谢谢！ 说明beego开发文档 https://beego.me/docs/quickstart/new.md 安装beego请首先安装beego和bee 12go get github.com/astaxie/beegogo get github.com/beego/bee 使用bee创建项目 进入gopath下src里面 1MacBook-Air :: ~/go/src » bee new project 在Goland中打开项目 运行项目 1bee run 发现不能够访问 修改配置文件在conf/app.conf文件里面添加 1httpaddr &#x3D; 127.0.0.1 测试再次运行，发现可以了 在浏览器中打开 感谢 beego 万能的网络 以及勤劳的自己","categories":[],"tags":[]}],"categories":[],"tags":[]}